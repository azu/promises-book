<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.5">
<meta name="description" content="JavaScriptのPromiseを使った非同期処理の書き方、テスト、アンチパターンについて解説した無料の電子書籍">
<meta name="keywords" content="JavaScript, ECMAScript, Promise, 仕様, 日本語, 使い方, チュートリアル, リファレンス, 無料">
<meta name="author" content="azu">
<title>JavaScript Promiseの本</title>
<style>
/* Asciidoctor default stylesheet | MIT License | http://asciidoctor.org */
article, aside, details, figcaption, figure, footer, header, hgroup, main, nav, section, summary {
    display: block
}

audio, canvas, video {
    display: inline-block
}

audio:not([controls]) {
    display: none;
    height: 0
}

[hidden], template {
    display: none
}

script {
    display: none !important
}

html {
    font-family: "Helvetica Neue", "Helvetica", Helvetica, Arial, sans-serif;
}

body {
    margin: 0
}

a {
    background: transparent
}

a:focus {
    outline: thin dotted
}

a:active, a:hover {
    outline: 0
}

h1 {
    font-size: 2em;
    margin: .67em 0
}

abbr[title] {
    border-bottom: 1px dotted
}

b, strong {
    font-weight: bold
}

dfn {
    font-style: italic
}

hr {
    -moz-box-sizing: content-box;
    box-sizing: content-box;
    height: 0
}

mark {
    background: #ff0;
    color: #000
}

code, kbd, pre, samp {
    font-family: monospace;
    font-size: 1em
}

pre {
    white-space: pre-wrap
}

q {
    quotes: "\201C" "\201D" "\2018" "\2019"
}

small {
    font-size: 80%
}

sub, sup {
    font-size: 75%;
    line-height: 0;
    position: relative;
    vertical-align: baseline
}

sup {
    top: -.5em
}

sub {
    bottom: -.25em
}

img {
    border: 0
}

svg:not(:root) {
    overflow: hidden
}

figure {
    margin: 0
}

fieldset {
    border: 1px solid silver;
    margin: 0 2px;
    padding: .35em .625em .75em
}

legend {
    border: 0;
    padding: 0
}

button, input, select, textarea {
    font-family: inherit;
    font-size: 100%;
    margin: 0
}

button, input {
    line-height: normal
}

button, select {
    text-transform: none
}

button, html input[type="button"], input[type="reset"], input[type="submit"] {
    -webkit-appearance: button;
    cursor: pointer
}

button[disabled], html input[disabled] {
    cursor: default
}

input[type="checkbox"], input[type="radio"] {
    box-sizing: border-box;
    padding: 0
}

input[type="search"] {
    -webkit-appearance: textfield;
    -moz-box-sizing: content-box;
    -webkit-box-sizing: content-box;
    box-sizing: content-box
}

input[type="search"]::-webkit-search-cancel-button, input[type="search"]::-webkit-search-decoration {
    -webkit-appearance: none
}

button::-moz-focus-inner, input::-moz-focus-inner {
    border: 0;
    padding: 0
}

textarea {
    overflow: auto;
    vertical-align: top
}

table {
    border-collapse: collapse;
    border-spacing: 0
}

*, *:before, *:after {
    -moz-box-sizing: border-box;
    -webkit-box-sizing: border-box;
    box-sizing: border-box
}

html, body {
    font-size: 100%
}

body {
    background: #fff;
    color: rgba(0, 0, 0, .8);
    padding: 0;
    margin: 0;
    font-family: "Helvetica Neue", "Helvetica", Helvetica, Arial, sans-serif, serif;
    font-weight: 400;
    font-style: normal;
    line-height: 1;
    position: relative;
    cursor: auto
}

a:hover {
    cursor: pointer
}

img, object, embed {
    max-width: 100%;
    height: auto
}

object, embed {
    height: 100%
}

#map_canvas img, #map_canvas embed, #map_canvas object, .map_canvas img, .map_canvas embed, .map_canvas object {
    max-width: none !important
}

.left {
    float: left !important
}

.right {
    float: right !important
}

.text-left {
    text-align: left !important
}

.text-right {
    text-align: right !important
}

.text-center {
    text-align: center !important
}

.text-justify {
    text-align: justify !important
}

.hide {
    display: none
}

img {
    display: inline-block;
    vertical-align: middle
}

textarea {
    height: auto;
    min-height: 50px
}

select {
    width: 100%
}

p.lead, .paragraph.lead > p, #preamble > .sectionbody > .paragraph:first-of-type p {
    font-size: 1.21875em;
    line-height: 1.6
}

.subheader, .admonitionblock td.content > .title, .audioblock > .title, .exampleblock > .title, .imageblock > .title, .listingblock > .title, .literalblock > .title, .stemblock > .title, .openblock > .title, .paragraph > .title, .quoteblock > .title, table.tableblock > .title, .verseblock > .title, .videoblock > .title, .dlist > .title, .olist > .title, .ulist > .title, .qlist > .title, .hdlist > .title {
    line-height: 1.45;
    color: #7a2518;
    font-weight: 400;
    margin-top: 0;
    margin-bottom: .25em
}

div, dl, dt, dd, ul, ol, li, h1, h2, h3, #toctitle, .sidebarblock > .content > .title, h4, h5, h6, pre, form, p, blockquote, th, td {
    margin: 0;
    padding: 0;
    direction: ltr
}

a {
    color: #2156a5;
    text-decoration: underline;
    line-height: inherit
}

a:hover, a:focus {
    color: #1d4b8f
}

a img {
    border: none
}

p {
    font-family: inherit;
    font-weight: 400;
    font-size: 1em;
    line-height: 1.6;
    margin-bottom: 1.25em;
}

p aside {
    font-size: .875em;
    line-height: 1.35;
    font-style: italic
}

h1, h2, h3, #toctitle, .sidebarblock > .content > .title, h4, h5, h6 {
    font-family: "Helvetica Neue", "Helvetica", Helvetica, Arial, sans-serif;
    font-weight: 300;
    font-style: normal;
    color: #ba3925;
    margin-top: 1em;
    margin-bottom: .5em;
    line-height: 1.0125em
}

h1 small, h2 small, h3 small, #toctitle small, .sidebarblock > .content > .title small, h4 small, h5 small, h6 small {
    font-size: 60%;
    color: #e99b8f;
    line-height: 0
}

h1 {
    font-size: 2.125em
}

h2 {
    font-size: 1.6875em
}

h3, #toctitle, .sidebarblock > .content > .title {
    font-size: 1.375em
}

h4, h5 {
    font-size: 1.125em
}

h6 {
    font-size: 1em
}

hr {
    border: solid #ddddd8;
    border-width: 1px 0 0;
    clear: both;
    margin: 1.25em 0 1.1875em;
    height: 0
}

em, i {
    font-style: italic;
    line-height: inherit
}

strong, b {
    font-weight: bold;
    line-height: inherit
}

small {
    font-size: 60%;
    line-height: inherit
}

code {
    font-family: Consolas, "Liberation Mono", Courier, monospace;
    font-weight: 400;
    color: rgba(0, 0, 0, .9)
}

ul, ol, dl {
    font-size: 1em;
    line-height: 1.6;
    margin-bottom: 1.25em;
    list-style-position: outside;
    font-family: inherit
}

ul, ol, ul.no-bullet, ol.no-bullet {
    margin-left: 1.5em
}

ul li ul, ul li ol {
    margin-left: 1.25em;
    margin-bottom: 0;
    font-size: 1em
}

ul.square li ul, ul.circle li ul, ul.disc li ul {
    list-style: inherit
}

ul.square {
    list-style-type: square
}

ul.circle {
    list-style-type: circle
}

ul.disc {
    list-style-type: disc
}

ul.no-bullet {
    list-style: none
}

ol li ul, ol li ol {
    margin-left: 1.25em;
    margin-bottom: 0
}

dl dt {
    margin-bottom: .3125em;
    font-weight: bold
}

dl dd {
    margin-bottom: 1.25em
}

abbr, acronym {
    text-transform: uppercase;
    font-size: 90%;
    color: rgba(0, 0, 0, .8);
    border-bottom: 1px dotted #ddd;
    cursor: help
}

abbr {
    text-transform: none
}

blockquote {
    margin: 0 0 1.25em;
    padding: .5625em 1.25em 0 1.1875em;
    border-left: 1px solid #ddd
}

blockquote cite {
    display: block;
    font-size: .9375em;
    color: rgba(0, 0, 0, .6)
}

blockquote cite:before {
    content: "\2014 \0020"
}

blockquote cite a, blockquote cite a:visited {
    color: rgba(0, 0, 0, .6)
}

blockquote, blockquote p {
    line-height: 1.6;
    color: rgba(0, 0, 0, .85)
}

@media only screen and (min-width: 768px) {
    h1, h2, h3, #toctitle, .sidebarblock > .content > .title, h4, h5, h6 {
        line-height: 1.2
    }

    h1 {
        font-size: 2.75em
    }

    h2 {
        font-size: 2.3125em
    }

    h3, #toctitle, .sidebarblock > .content > .title {
        font-size: 1.6875em
    }

    h4 {
        font-size: 1.4375em
    }
}

table {
    background: #fff;
    margin-bottom: 1.25em;
    border: solid 1px #dedede
}

table thead, table tfoot {
    background: #f7f8f7;
    font-weight: bold
}

table thead tr th, table thead tr td, table tfoot tr th, table tfoot tr td {
    padding: .5em .625em .625em;
    font-size: inherit;
    color: rgba(0, 0, 0, .8);
    text-align: left
}

table tr th, table tr td {
    padding: .5625em .625em;
    font-size: inherit;
    color: rgba(0, 0, 0, .8)
}

table tr.even, table tr.alt, table tr:nth-of-type(even) {
    background: #f8f8f7
}

table thead tr th, table tfoot tr th, table tbody tr td, table tr td, table tfoot tr td {
    display: table-cell;
    line-height: 1.6
}

h1, h2, h3, #toctitle, .sidebarblock > .content > .title, h4, h5, h6 {
    line-height: 1.2;
    word-spacing: -.05em
}

h1 strong, h2 strong, h3 strong, #toctitle strong, .sidebarblock > .content > .title strong, h4 strong, h5 strong, h6 strong {
    font-weight: 400
}

.clearfix:before, .clearfix:after, .float-group:before, .float-group:after {
    content: " ";
    display: table
}

.clearfix:after, .float-group:after {
    clear: both
}

*:not(pre) > code {
    font-size: .9375em;
    font-style: normal !important;
    padding: .1em .5ex;
    word-spacing: -.15em;
    background-color: #f7f7f8;
    -webkit-border-radius: 4px;
    border-radius: 4px;
    line-height: 1.45;
    text-rendering: optimizeSpeed
}

pre, pre > code {
    line-height: 1.45;
    color: rgba(0, 0, 0, .9);
    font-family: Consolas, "Liberation Mono", Courier, monospace;
    font-weight: 400;
    text-rendering: optimizeSpeed
}

.keyseq {
    color: rgba(51, 51, 51, .8)
}

kbd {
    display: inline-block;
    color: rgba(0, 0, 0, .8);
    font-size: .75em;
    line-height: 1.4;
    background-color: #f7f7f7;
    border: 1px solid #ccc;
    -webkit-border-radius: 3px;
    border-radius: 3px;
    -webkit-box-shadow: 0 1px 0 rgba(0, 0, 0, .2), 0 0 0 .1em white inset;
    box-shadow: 0 1px 0 rgba(0, 0, 0, .2), 0 0 0 .1em #fff inset;
    margin: -.15em .15em 0 .15em;
    padding: .2em .6em .2em .5em;
    vertical-align: middle;
    white-space: nowrap
}

.keyseq kbd:first-child {
    margin-left: 0
}

.keyseq kbd:last-child {
    margin-right: 0
}

.menuseq, .menu {
    color: rgba(0, 0, 0, .8)
}

b.button:before, b.button:after {
    position: relative;
    top: -1px;
    font-weight: 400
}

b.button:before {
    content: "[";
    padding: 0 3px 0 2px
}

b.button:after {
    content: "]";
    padding: 0 2px 0 3px
}

p a > code:hover {
    color: rgba(0, 0, 0, .9)
}

#header, #content, #footnotes, #footer {
    width: 100%;
    margin-left: auto;
    margin-right: auto;
    margin-top: 0;
    margin-bottom: 0;
    max-width: 62.5em;
    *zoom: 1;
    position: relative;
    padding-left: .9375em;
    padding-right: .9375em
}

#header:before, #header:after, #content:before, #content:after, #footnotes:before, #footnotes:after, #footer:before, #footer:after {
    content: " ";
    display: table
}

#header:after, #content:after, #footnotes:after, #footer:after {
    clear: both
}

#content {
    margin-top: 1.25em
}

#content:before {
    content: none
}

#header > h1:first-child {
    color: rgba(0, 0, 0, .85);
    margin-top: 2.25rem;
    margin-bottom: 0
}

#header > h1:first-child + #toc {
    margin-top: 8px;
    border-top: 1px solid #ddddd8
}

#header > h1:only-child, body.toc2 #header > h1:nth-last-child(2) {
    border-bottom: 1px solid #ddddd8;
    padding-bottom: 8px
}

#header .details {
    border-bottom: 1px solid #ddddd8;
    line-height: 1.45;
    padding-top: .25em;
    padding-bottom: .25em;
    padding-left: .25em;
    color: rgba(0, 0, 0, .6);
    display: -ms-flexbox;
    display: -webkit-flex;
    display: flex;
    -ms-flex-flow: row wrap;
    -webkit-flex-flow: row wrap;
    flex-flow: row wrap
}

#header .details span:first-child {
    margin-left: -.125em
}

#header .details span.email a {
    color: rgba(0, 0, 0, .85)
}

#header .details br {
    display: none
}

#header .details br + span:before {
    content: "\00a0\2013\00a0"
}

#header .details br + span.author:before {
    content: "\00a0\22c5\00a0";
    color: rgba(0, 0, 0, .85)
}

#header .details br + span#revremark:before {
    content: "\00a0|\00a0"
}

#header #revnumber {
    text-transform: capitalize
}

#header #revnumber:after {
    content: "\00a0"
}

#content > h1:first-child:not([class]) {
    color: rgba(0, 0, 0, .85);
    border-bottom: 1px solid #ddddd8;
    padding-bottom: 8px;
    margin-top: 0;
    padding-top: 1rem;
    margin-bottom: 1.25rem
}

#toc {
    border-bottom: 1px solid #efefed;
    padding-bottom: .5em
}

#toc > ul {
    margin-left: .125em
}

#toc ul.sectlevel0 > li > a {
    font-style: italic
}

#toc ul.sectlevel0 ul.sectlevel1 {
    margin: .5em 0
}

#toc ul {
    font-family: "Helvetica Neue", "Helvetica", Helvetica, Arial, sans-serif;
    list-style-type: none
}

#toc a {
    text-decoration: none
}

#toc a:active {
    text-decoration: underline
}

#toctitle {
    color: #7a2518;
    font-size: 1.2em
}

@media only screen and (min-width: 768px) {
    #toctitle {
        font-size: 1.375em
    }

    body.toc2 {
        padding-left: 15em;
        padding-right: 0
    }

    #toc.toc2 {
        margin-top: 0 !important;
        background-color: #f8f8f7;
        position: fixed;
        width: 15em;
        left: 0;
        top: 0;
        border-right: 1px solid #efefed;
        border-top-width: 0 !important;
        border-bottom-width: 0 !important;
        z-index: 1000;
        padding: 1.25em 1em;
        height: 100%;
        overflow: auto
    }

    #toc.toc2 #toctitle {
        margin-top: 0;
        font-size: 1.2em
    }

    #toc.toc2 > ul {
        font-size: .9em;
        margin-bottom: 0
    }

    #toc.toc2 ul ul {
        margin-left: 0;
        padding-left: 1em
    }

    #toc.toc2 ul.sectlevel0 ul.sectlevel1 {
        padding-left: 0;
        margin-top: .5em;
        margin-bottom: .5em
    }

    body.toc2.toc-right {
        padding-left: 0;
        padding-right: 15em
    }

    body.toc2.toc-right #toc.toc2 {
        border-right-width: 0;
        border-left: 1px solid #efefed;
        left: auto;
        right: 0
    }
}

@media only screen and (min-width: 1280px) {
    body.toc2 {
        padding-left: 20em;
        padding-right: 0
    }

    #toc.toc2 {
        width: 20em
    }

    #toc.toc2 #toctitle {
        font-size: 1.375em
    }

    #toc.toc2 > ul {
        font-size: .95em
    }

    #toc.toc2 ul ul {
        padding-left: 1.25em
    }

    body.toc2.toc-right {
        padding-left: 0;
        padding-right: 20em
    }
}

#content #toc {
    border-style: solid;
    border-width: 1px;
    border-color: #e0e0dc;
    margin-bottom: 1.25em;
    padding: 1.25em;
    background: #f8f8f7;
    -webkit-border-radius: 4px;
    border-radius: 4px
}

#content #toc > :first-child {
    margin-top: 0
}

#content #toc > :last-child {
    margin-bottom: 0
}

#footer {
    max-width: 100%;
    background-color: rgba(0, 0, 0, .8);
    padding: 1.25em
}

#footer-text {
    color: rgba(255, 255, 255, .8);
    line-height: 1.44
}

.sect1 {
    padding-bottom: .625em
}

@media only screen and (min-width: 768px) {
    .sect1 {
        padding-bottom: 1.25em
    }
}

.sect1 + .sect1 {
    border-top: 1px solid #efefed
}

#content h1 > a.anchor, h2 > a.anchor, h3 > a.anchor, #toctitle > a.anchor, .sidebarblock > .content > .title > a.anchor, h4 > a.anchor, h5 > a.anchor, h6 > a.anchor {
    position: absolute;
    z-index: 1001;
    width: 1.5ex;
    margin-left: -1.5ex;
    display: block;
    text-decoration: none !important;
    visibility: hidden;
    text-align: center;
    font-weight: 400
}

#content h1 > a.anchor:before, h2 > a.anchor:before, h3 > a.anchor:before, #toctitle > a.anchor:before, .sidebarblock > .content > .title > a.anchor:before, h4 > a.anchor:before, h5 > a.anchor:before, h6 > a.anchor:before {
    content: "\00A7";
    font-size: .85em;
    display: block;
    padding-top: .1em
}

#content h1:hover > a.anchor, #content h1 > a.anchor:hover, h2:hover > a.anchor, h2 > a.anchor:hover, h3:hover > a.anchor, #toctitle:hover > a.anchor, .sidebarblock > .content > .title:hover > a.anchor, h3 > a.anchor:hover, #toctitle > a.anchor:hover, .sidebarblock > .content > .title > a.anchor:hover, h4:hover > a.anchor, h4 > a.anchor:hover, h5:hover > a.anchor, h5 > a.anchor:hover, h6:hover > a.anchor, h6 > a.anchor:hover {
    visibility: visible
}

#content h1 > a.link, h2 > a.link, h3 > a.link, #toctitle > a.link, .sidebarblock > .content > .title > a.link, h4 > a.link, h5 > a.link, h6 > a.link {
    color: #ba3925;
    text-decoration: none
}

#content h1 > a.link:hover, h2 > a.link:hover, h3 > a.link:hover, #toctitle > a.link:hover, .sidebarblock > .content > .title > a.link:hover, h4 > a.link:hover, h5 > a.link:hover, h6 > a.link:hover {
    color: #a53221
}

.audioblock, .imageblock, .literalblock, .listingblock, .stemblock, .videoblock {
    margin-bottom: 1.25em
}

.admonitionblock td.content > .title, .audioblock > .title, .exampleblock > .title, .imageblock > .title, .listingblock > .title, .literalblock > .title, .stemblock > .title, .openblock > .title, .paragraph > .title, .quoteblock > .title, table.tableblock > .title, .verseblock > .title, .videoblock > .title, .dlist > .title, .olist > .title, .ulist > .title, .qlist > .title, .hdlist > .title {
    text-align: left;
    font-family: "DejaVu Serif", serif;
    font-size: 1rem;
    font-style: italic
}

table.tableblock > caption.title {
    white-space: nowrap;
    overflow: visible;
    max-width: 0
}

.paragraph.lead > p, #preamble > .sectionbody > .paragraph:first-of-type p {
    color: rgba(0, 0, 0, .85)
}

table.tableblock #preamble > .sectionbody > .paragraph:first-of-type p {
    font-size: inherit
}

.admonitionblock > table {
    border-collapse: separate;
    border: 0;
    background: none;
    width: 100%
}

.admonitionblock > table td.icon {
    text-align: center;
    width: 80px
}

.admonitionblock > table td.icon img {
    max-width: none
}

.admonitionblock > table td.icon .title {
    font-weight: bold;
    font-family: "Helvetica Neue", "Helvetica", Helvetica, Arial, sans-serif;
    text-transform: uppercase
}

.admonitionblock > table td.content {
    padding-left: 1.125em;
    padding-right: 1.25em;
    border-left: 1px solid #ddddd8;
    color: rgba(0, 0, 0, .6)
}

.admonitionblock > table td.content > :last-child > :last-child {
    margin-bottom: 0
}

.exampleblock > .content {
    border-style: solid;
    border-width: 1px;
    border-color: #e6e6e6;
    margin-bottom: 1.25em;
    padding: 1.25em;
    background: #fff;
    -webkit-border-radius: 4px;
    border-radius: 4px
}

.exampleblock > .content > :first-child {
    margin-top: 0
}

.exampleblock > .content > :last-child {
    margin-bottom: 0
}

.sidebarblock {
    border-style: solid;
    border-width: 1px;
    border-color: #e0e0dc;
    margin-bottom: 1.25em;
    padding: 1.25em;
    background: #f8f8f7;
    -webkit-border-radius: 4px;
    border-radius: 4px
}

.sidebarblock > :first-child {
    margin-top: 0
}

.sidebarblock > :last-child {
    margin-bottom: 0
}

.sidebarblock > .content > .title {
    color: #7a2518;
    margin-top: 0;
    text-align: center
}

.exampleblock > .content > :last-child > :last-child, .exampleblock > .content .olist > ol > li:last-child > :last-child, .exampleblock > .content .ulist > ul > li:last-child > :last-child, .exampleblock > .content .qlist > ol > li:last-child > :last-child, .sidebarblock > .content > :last-child > :last-child, .sidebarblock > .content .olist > ol > li:last-child > :last-child, .sidebarblock > .content .ulist > ul > li:last-child > :last-child, .sidebarblock > .content .qlist > ol > li:last-child > :last-child {
    margin-bottom: 0
}

.literalblock pre, .listingblock pre:not(.highlight), .listingblock pre[class="highlight"], .listingblock pre[class^="highlight "], .listingblock pre.CodeRay, .listingblock pre.prettyprint {
    background: #f7f7f8
}

.sidebarblock .literalblock pre, .sidebarblock .listingblock pre:not(.highlight), .sidebarblock .listingblock pre[class="highlight"], .sidebarblock .listingblock pre[class^="highlight "], .sidebarblock .listingblock pre.CodeRay, .sidebarblock .listingblock pre.prettyprint {
    background: #f2f1f1
}

.literalblock pre, .literalblock pre[class], .listingblock pre, .listingblock pre[class] {
    -webkit-border-radius: 4px;
    border-radius: 4px;
    word-wrap: break-word;
    padding: 1em;
    font-size: .8125em
}

.literalblock pre.nowrap, .literalblock pre[class].nowrap, .listingblock pre.nowrap, .listingblock pre[class].nowrap {
    overflow-x: auto;
    white-space: pre;
    word-wrap: normal
}

@media only screen and (min-width: 768px) {
    .literalblock pre, .literalblock pre[class], .listingblock pre, .listingblock pre[class] {
        font-size: .90625em
    }
}

@media only screen and (min-width: 1280px) {
    .literalblock pre, .literalblock pre[class], .listingblock pre, .listingblock pre[class] {
        font-size: 1em
    }
}

.literalblock.output pre {
    color: #f7f7f8;
    background-color: rgba(0, 0, 0, .9)
}

.listingblock pre.highlightjs {
    padding: 0
}

.listingblock pre.highlightjs > code {
    padding: 1em;
    -webkit-border-radius: 4px;
    border-radius: 4px
}

.listingblock pre.prettyprint {
    border-width: 0
}

.listingblock > .content {
    position: relative
}

.listingblock code[data-lang]:before {
    display: none;
    content: attr(data-lang);
    position: absolute;
    font-size: .75em;
    top: .425rem;
    right: .5rem;
    line-height: 1;
    text-transform: uppercase;
    color: #999
}

.listingblock:hover code[data-lang]:before {
    display: block
}

.listingblock.terminal pre .command:before {
    content: attr(data-prompt);
    padding-right: .5em;
    color: #999
}

.listingblock.terminal pre .command:not([data-prompt]):before {
    content: "$"
}

table.pyhltable {
    border-collapse: separate;
    border: 0;
    margin-bottom: 0;
    background: none
}

table.pyhltable td {
    vertical-align: top;
    padding-top: 0;
    padding-bottom: 0
}

table.pyhltable td.code {
    padding-left: .75em;
    padding-right: 0
}

pre.pygments .lineno, table.pyhltable td:not(.code) {
    color: #999;
    padding-left: 0;
    padding-right: .5em;
    border-right: 1px solid #ddddd8
}

pre.pygments .lineno {
    display: inline-block;
    margin-right: .25em
}

table.pyhltable .linenodiv {
    background: none !important;
    padding-right: 0 !important
}

.quoteblock {
    margin: 0 1em 1.25em 1.5em;
    display: table
}

.quoteblock > .title {
    margin-left: -1.5em;
    margin-bottom: .75em
}

.quoteblock blockquote, .quoteblock blockquote p {
    color: rgba(0, 0, 0, .85);
    font-size: 1.15rem;
    line-height: 1.75;
    word-spacing: .1em;
    font-style: italic;
    text-align: justify
}

.quoteblock blockquote {
    margin: 0;
    padding: 0;
    border: 0
}

.quoteblock blockquote:before {
    content: "\201c";
    float: left;
    font-size: 2.75em;
    font-weight: bold;
    line-height: .6em;
    margin-left: -.6em;
    color: #7a2518;
    text-shadow: 0 1px 2px rgba(0, 0, 0, .1)
}

.quoteblock blockquote > .paragraph:last-child p {
    margin-bottom: 0
}

.quoteblock .attribution {
    margin-top: .5em;
    margin-right: .5ex;
    text-align: right
}

.quoteblock .quoteblock {
    margin-left: 0;
    margin-right: 0;
    padding: .5em 0;
    border-left: 3px solid rgba(0, 0, 0, .6)
}

.quoteblock .quoteblock blockquote {
    padding: 0 0 0 .75em
}

.quoteblock .quoteblock blockquote:before {
    display: none
}

.verseblock {
    margin: 0 1em 1.25em 1em
}

.verseblock pre {
    font-family: "Helvetica Neue", "Helvetica", Helvetica, Arial, sans-serif;
    font-size: 1.15rem;
    color: rgba(0, 0, 0, .85);
    font-weight: 300;
}

.verseblock pre strong {
    font-weight: 400
}

.verseblock .attribution {
    margin-top: 1.25rem;
    margin-left: .5ex
}

.quoteblock .attribution, .verseblock .attribution {
    font-size: .9375em;
    line-height: 1.45;
    font-style: italic
}

.quoteblock .attribution br, .verseblock .attribution br {
    display: none
}

.quoteblock .attribution cite, .verseblock .attribution cite {
    display: block;
    color: rgba(0, 0, 0, .6)
}

.quoteblock.abstract {
    margin: 0 0 1.25em 0;
    display: block
}

.quoteblock.abstract blockquote, .quoteblock.abstract blockquote p {
    text-align: left;
    word-spacing: 0
}

.quoteblock.abstract blockquote:before, .quoteblock.abstract blockquote p:first-of-type:before {
    display: none
}

table.tableblock {
    max-width: 100%;
    border-collapse: separate
}

table.tableblock td > .paragraph:last-child p > p:last-child, table.tableblock th > p:last-child, table.tableblock td > p:last-child {
    margin-bottom: 0
}

table.spread {
    width: 100%
}

table.tableblock, th.tableblock, td.tableblock {
    border: 0 solid #dedede
}

table.grid-all th.tableblock, table.grid-all td.tableblock {
    border-width: 0 1px 1px 0
}

table.grid-all tfoot > tr > th.tableblock, table.grid-all tfoot > tr > td.tableblock {
    border-width: 1px 1px 0 0
}

table.grid-cols th.tableblock, table.grid-cols td.tableblock {
    border-width: 0 1px 0 0
}

table.grid-all * > tr > .tableblock:last-child, table.grid-cols * > tr > .tableblock:last-child {
    border-right-width: 0
}

table.grid-rows th.tableblock, table.grid-rows td.tableblock {
    border-width: 0 0 1px 0
}

table.grid-all tbody > tr:last-child > th.tableblock, table.grid-all tbody > tr:last-child > td.tableblock, table.grid-all thead:last-child > tr > th.tableblock, table.grid-rows tbody > tr:last-child > th.tableblock, table.grid-rows tbody > tr:last-child > td.tableblock, table.grid-rows thead:last-child > tr > th.tableblock {
    border-bottom-width: 0
}

table.grid-rows tfoot > tr > th.tableblock, table.grid-rows tfoot > tr > td.tableblock {
    border-width: 1px 0 0 0
}

table.frame-all {
    border-width: 1px
}

table.frame-sides {
    border-width: 0 1px
}

table.frame-topbot {
    border-width: 1px 0
}

th.halign-left, td.halign-left {
    text-align: left
}

th.halign-right, td.halign-right {
    text-align: right
}

th.halign-center, td.halign-center {
    text-align: center
}

th.valign-top, td.valign-top {
    vertical-align: top
}

th.valign-bottom, td.valign-bottom {
    vertical-align: bottom
}

th.valign-middle, td.valign-middle {
    vertical-align: middle
}

table thead th, table tfoot th {
    font-weight: bold
}

tbody tr th {
    display: table-cell;
    line-height: 1.6;
    background: #f7f8f7
}

tbody tr th, tbody tr th p, tfoot tr th, tfoot tr th p {
    color: rgba(0, 0, 0, .8);
    font-weight: bold
}

p.tableblock > code:only-child {
    background: none;
    padding: 0
}

p.tableblock {
    font-size: 1em
}

td > div.verse {
    white-space: pre
}

ol {
    margin-left: 1.75em
}

ul li ol {
    margin-left: 1.5em
}

dl dd {
    margin-left: 1.125em
}

dl dd:last-child, dl dd:last-child > :last-child {
    margin-bottom: 0
}

ol > li p, ul > li p, ul dd, ol dd, .olist .olist, .ulist .ulist, .ulist .olist, .olist .ulist {
    margin-bottom: .625em
}

ul.unstyled, ol.unnumbered, ul.checklist, ul.none {
    list-style-type: none
}

ul.unstyled, ol.unnumbered, ul.checklist {
    margin-left: .625em
}

ul.checklist li > p:first-child > .fa-check-square-o:first-child, ul.checklist li > p:first-child > input[type="checkbox"]:first-child {
    margin-right: .25em
}

ul.checklist li > p:first-child > input[type="checkbox"]:first-child {
    position: relative;
    top: 1px
}

ul.inline {
    margin: 0 auto .625em auto;
    margin-left: -1.375em;
    margin-right: 0;
    padding: 0;
    list-style: none;
    overflow: hidden
}

ul.inline > li {
    list-style: none;
    float: left;
    margin-left: 1.375em;
    display: block
}

ul.inline > li > * {
    display: block
}

.unstyled dl dt {
    font-weight: 400;
    font-style: normal
}

ol.arabic {
    list-style-type: decimal
}

ol.decimal {
    list-style-type: decimal-leading-zero
}

ol.loweralpha {
    list-style-type: lower-alpha
}

ol.upperalpha {
    list-style-type: upper-alpha
}

ol.lowerroman {
    list-style-type: lower-roman
}

ol.upperroman {
    list-style-type: upper-roman
}

ol.lowergreek {
    list-style-type: lower-greek
}

.hdlist > table, .colist > table {
    border: 0;
    background: none
}

.hdlist > table > tbody > tr, .colist > table > tbody > tr {
    background: none
}

td.hdlist1 {
    padding-right: .75em;
    font-weight: bold
}

td.hdlist1, td.hdlist2 {
    vertical-align: top
}

.literalblock + .colist, .listingblock + .colist {
    margin-top: -.5em
}

.colist > table tr > td:first-of-type {
    padding: 0 .75em;
    line-height: 1
}

.colist > table tr > td:last-of-type {
    padding: .25em 0
}

.thumb, .th {
    line-height: 0;
    display: inline-block;
    border: solid 4px #fff;
    -webkit-box-shadow: 0 0 0 1px #ddd;
    box-shadow: 0 0 0 1px #ddd
}

.imageblock.left, .imageblock[style*="float: left"] {
    margin: .25em .625em 1.25em 0
}

.imageblock.right, .imageblock[style*="float: right"] {
    margin: .25em 0 1.25em .625em
}

.imageblock > .title {
    margin-bottom: 0
}

.imageblock.thumb, .imageblock.th {
    border-width: 6px
}

.imageblock.thumb > .title, .imageblock.th > .title {
    padding: 0 .125em
}

.image.left, .image.right {
    margin-top: .25em;
    margin-bottom: .25em;
    display: inline-block;
    line-height: 0
}

.image.left {
    margin-right: .625em
}

.image.right {
    margin-left: .625em
}

a.image {
    text-decoration: none
}

span.footnote, span.footnoteref {
    vertical-align: super;
    font-size: .875em
}

span.footnote a, span.footnoteref a {
    text-decoration: none
}

span.footnote a:active, span.footnoteref a:active {
    text-decoration: underline
}

#footnotes {
    padding-top: .75em;
    padding-bottom: .75em;
    margin-bottom: .625em
}

#footnotes hr {
    width: 20%;
    min-width: 6.25em;
    margin: -.25em 0 .75em 0;
    border-width: 1px 0 0 0
}

#footnotes .footnote {
    padding: 0 .375em;
    line-height: 1.3;
    font-size: .875em;
    margin-left: 1.2em;
    text-indent: -1.2em;
    margin-bottom: .2em
}

#footnotes .footnote a:first-of-type {
    font-weight: bold;
    text-decoration: none
}

#footnotes .footnote:last-of-type {
    margin-bottom: 0
}

#content #footnotes {
    margin-top: -.625em;
    margin-bottom: 0;
    padding: .75em 0
}

.gist .file-data > table {
    border: 0;
    background: #fff;
    width: 100%;
    margin-bottom: 0
}

.gist .file-data > table td.line-data {
    width: 99%
}


.big {
    font-size: larger
}

.small {
    font-size: smaller
}

.underline {
    text-decoration: underline
}

.overline {
    text-decoration: overline
}

.line-through {
    text-decoration: line-through
}

.aqua {
    color: #00bfbf
}

.aqua-background {
    background-color: #00fafa
}

.black {
    color: #000
}

.black-background {
    background-color: #000
}

.blue {
    color: #0000bf
}

.blue-background {
    background-color: #0000fa
}

.fuchsia {
    color: #bf00bf
}

.fuchsia-background {
    background-color: #fa00fa
}

.gray {
    color: #606060
}

.gray-background {
    background-color: #7d7d7d
}

.green {
    color: #006000
}

.green-background {
    background-color: #007d00
}

.lime {
    color: #00bf00
}

.lime-background {
    background-color: #00fa00
}

.maroon {
    color: #600000
}

.maroon-background {
    background-color: #7d0000
}

.navy {
    color: #000060
}

.navy-background {
    background-color: #00007d
}

.olive {
    color: #606000
}

.olive-background {
    background-color: #7d7d00
}

.purple {
    color: #600060
}

.purple-background {
    background-color: #7d007d
}

.red {
    color: #bf0000
}

.red-background {
    background-color: #fa0000
}

.silver {
    color: #909090
}

.silver-background {
    background-color: #bcbcbc
}

.teal {
    color: #006060
}

.teal-background {
    background-color: #007d7d
}

.white {
    color: #bfbfbf
}

.white-background {
    background-color: #fafafa
}

.yellow {
    color: #bfbf00
}

.yellow-background {
    background-color: #fafa00
}

span.icon > .fa {
    cursor: default
}

.admonitionblock td.icon [class^="fa icon-"] {
    font-size: 2.5em;
    text-shadow: 1px 1px 2px rgba(0, 0, 0, .5);
    cursor: default
}

.admonitionblock td.icon .icon-note:before {
    content: "\f05a";
    color: #19407c
}

.admonitionblock td.icon .icon-tip:before {
    content: "\f0eb";
    text-shadow: 1px 1px 2px rgba(155, 155, 0, .8);
    color: #111
}

.admonitionblock td.icon .icon-warning:before {
    content: "\f071";
    color: #bf6900
}

.admonitionblock td.icon .icon-caution:before {
    content: "\f06d";
    color: #bf3400
}

.admonitionblock td.icon .icon-important:before {
    content: "\f06a";
    color: #bf0000
}

.conum[data-value] {
    display: inline-block;
    color: #fff !important;
    background-color: rgba(0, 0, 0, .8);
    -webkit-border-radius: 100px;
    border-radius: 100px;
    text-align: center;
    font-size: .75em;
    width: 1.67em;
    height: 1.67em;
    line-height: 1.67em;
    font-family: "Helvetica Neue", "Helvetica", Helvetica, Arial, sans-serif;
    font-style: normal;
    font-weight: bold
}

.conum[data-value] * {
    color: #fff !important
}

.conum[data-value] + b {
    display: none
}

.conum[data-value]:after {
    content: attr(data-value)
}

pre .conum[data-value] {
    position: relative;
    top: -.125em
}

b.conum * {
    color: inherit !important
}

.conum:not([data-value]):empty {
    display: none
}
/* https://github.com/azu/promises-book/pull/255
h1, h2 {
    letter-spacing: -.01em
}

dt, th.tableblock, td.content {
}

p, td.content {
    letter-spacing: -.01em
}

p strong, td.content strong {
    letter-spacing: -.005em
}
*/
p, blockquote, dt, td.content {
    font-size: 1.0625rem
}

p {
    margin-bottom: 1.25rem
}

.sidebarblock p, .sidebarblock dt, .sidebarblock td.content, p.tableblock {
    font-size: 1em
}

.exampleblock > .content {
    background-color: #fffef7;
    border-color: #e0e0dc;
    -webkit-box-shadow: 0 1px 4px #e0e0dc;
    box-shadow: 0 1px 4px #e0e0dc
}

.print-only {
    display: none !important
}

@media print {
    @page {
        margin: 1.25cm .75cm
    }

    a {
        color: inherit !important;
        text-decoration: underline !important
    }

    a.bare, a[href^="#"], a[href^="mailto:"] {
        text-decoration: none !important
    }

    a[href^="http:"]:not(.bare):after, a[href^="https:"]:not(.bare):after, a[href^="mailto:"]:not(.bare):after {
        content: "(" attr(href) ")";
        display: inline-block;
        font-size: .875em;
        padding-left: .25em
    }

    abbr[title]:after {
        content: " (" attr(title) ")"
    }

    pre, blockquote, tr, img {
        page-break-inside: avoid
    }

    thead {
        display: table-header-group
    }

    img {
        max-width: 100% !important
    }

    p, blockquote, dt, td.content {
        font-size: 1em;
        orphans: 3;
        widows: 3
    }

    h2, h3, #toctitle, .sidebarblock > .content > .title {
        page-break-after: avoid
    }

    #toc, .sidebarblock, .exampleblock > .content {
        background: none !important
    }

    #toc {
        border-bottom: 1px solid #ddddd8 !important;
        padding-bottom: 0 !important
    }

    .sect1 {
        padding-bottom: 0 !important
    }

    .sect1 + .sect1 {
        border: 0 !important
    }

    #header > h1:first-child {
        margin-top: 1.25rem
    }

    body.book #header {
        text-align: center
    }

    body.book #header > h1:first-child {
        border: 0 !important;
        margin: 2.5em 0 1em 0
    }

    body.book #header .details {
        border: 0 !important;
        display: block;
        padding: 0 !important
    }

    body.book #header .details span:first-child {
        margin-left: 0 !important
    }

    body.book #header .details br {
        display: block
    }

    body.book #header .details br + span:before {
        content: none !important
    }

    body.book #toc {
        border: 0 !important;
        text-align: left !important;
        padding: 0 !important;
        margin: 0 !important
    }

    body.book #toc, body.book #preamble, body.book h1.sect0, body.book .sect1 > h2 {
        page-break-before: always
    }

    .listingblock code[data-lang]:before {
        display: block
    }

    #footer {
        background: none !important;
        padding: 0 .9375em
    }

    #footer-text {
        color: rgba(0, 0, 0, .6) !important;
        font-size: .9em
    }

    .hide-on-print {
        display: none !important
    }

    .print-only {
        display: block !important
    }

    .hide-for-print {
        display: none !important
    }

    .show-for-print {
        display: inherit !important
    }
}

</style>
<link rel="stylesheet" href="public/css/font-awesome.min.css">
<style>
/* Stylesheet for CodeRay to match GitHub theme | MIT License | http://foundation.zurb.com */
/*pre.CodeRay {background-color:#f7f7f8;}*/
.CodeRay .line-numbers{border-right:1px solid #d8d8d8;padding:0 0.5em 0 .25em}
.CodeRay span.line-numbers{display:inline-block;margin-right:.5em;color:rgba(0,0,0,.3)}
.CodeRay .line-numbers strong{color:rgba(0,0,0,.4)}
table.CodeRay{border-collapse:separate;border-spacing:0;margin-bottom:0;border:0;background:none}
table.CodeRay td{vertical-align: top;line-height:1.45}
table.CodeRay td.line-numbers{text-align:right}
table.CodeRay td.line-numbers>pre{padding:0;color:rgba(0,0,0,.3)}
table.CodeRay td.code{padding:0 0 0 .5em}
table.CodeRay td.code>pre{padding:0}
.CodeRay .debug{color:#fff !important;background:#000080 !important}
.CodeRay .annotation{color:#007}
.CodeRay .attribute-name{color:#000080}
.CodeRay .attribute-value{color:#700}
.CodeRay .binary{color:#509}
.CodeRay .comment{color:#998;font-style:italic}
.CodeRay .char{color:#04d}
.CodeRay .char .content{color:#04d}
.CodeRay .char .delimiter{color:#039}
.CodeRay .class{color:#458;font-weight:bold}
.CodeRay .complex{color:#a08}
.CodeRay .constant,.CodeRay .predefined-constant{color:#008080}
.CodeRay .color{color:#099}
.CodeRay .class-variable{color:#369}
.CodeRay .decorator{color:#b0b}
.CodeRay .definition{color:#099}
.CodeRay .delimiter{color:#000}
.CodeRay .doc{color:#970}
.CodeRay .doctype{color:#34b}
.CodeRay .doc-string{color:#d42}
.CodeRay .escape{color:#666}
.CodeRay .entity{color:#800}
.CodeRay .error{color:#808}
.CodeRay .exception{color:inherit}
.CodeRay .filename{color:#099}
.CodeRay .function{color:#900;font-weight:bold}
.CodeRay .global-variable{color:#008080}
.CodeRay .hex{color:#058}
.CodeRay .integer,.CodeRay .float{color:#099}
.CodeRay .include{color:#555}
.CodeRay .inline{color:#000}
.CodeRay .inline .inline{background:#ccc}
.CodeRay .inline .inline .inline{background:#bbb}
.CodeRay .inline .inline-delimiter{color:#d14}
.CodeRay .inline-delimiter{color:#d14}
.CodeRay .important{color:#555;font-weight:bold}
.CodeRay .interpreted{color:#b2b}
.CodeRay .instance-variable{color:#008080}
.CodeRay .label{color:#970}
.CodeRay .local-variable{color:#963}
.CodeRay .octal{color:#40e}
.CodeRay .predefined{color:#369}
.CodeRay .preprocessor{color:#579}
.CodeRay .pseudo-class{color:#555}
.CodeRay .directive{font-weight:bold}
.CodeRay .type{font-weight:bold}
.CodeRay .predefined-type{color:inherit}
.CodeRay .reserved,.CodeRay .keyword {color:#000;font-weight:bold}
.CodeRay .key{color:#808}
.CodeRay .key .delimiter{color:#606}
.CodeRay .key .char{color:#80f}
.CodeRay .value{color:#088}
.CodeRay .regexp .delimiter{color:#808}
.CodeRay .regexp .content{color:#808}
.CodeRay .regexp .modifier{color:#808}
.CodeRay .regexp .char{color:#d14}
.CodeRay .regexp .function{color:#404;font-weight:bold}
.CodeRay .string{color:#d20}
.CodeRay .string .string .string{background:#ffd0d0}
.CodeRay .string .content{color:#d14}
.CodeRay .string .char{color:#d14}
.CodeRay .string .delimiter{color:#d14}
.CodeRay .shell{color:#d14}
.CodeRay .shell .delimiter{color:#d14}
.CodeRay .symbol{color:#990073}
.CodeRay .symbol .content{color:#a60}
.CodeRay .symbol .delimiter{color:#630}
.CodeRay .tag{color:#008080}
.CodeRay .tag-special{color:#d70}
.CodeRay .variable{color:#036}
.CodeRay .insert{background:#afa}
.CodeRay .delete{background:#faa}
.CodeRay .change{color:#aaf;background:#007}
.CodeRay .head{color:#f8f;background:#505}
.CodeRay .insert .insert{color:#080}
.CodeRay .delete .delete{color:#800}
.CodeRay .change .change{color:#66f}
.CodeRay .head .head{color:#f4f}
</style>
<!-- Twitter -->
<meta name="twitter:card" content="summary">
<meta name="twitter:site" content="@azu_re">
<meta name="twitter:url" content="https://azu.github.io/promises-book/">
<meta name="twitter:title" content="JavaScript Promiseの本">
<meta name="twitter:description" content="JavaScriptのPromiseを使った非同期処理の書き方、テスト、アンチパターンについて解説した無料の電子書籍">
<meta name="twitter:image" content="https://azu.github.io/promises-book/public/img/promise-catch.png">
<!-- OGP -->
<meta property="og:type" content="website">
<meta property="og:url" content="https://azu.github.io/promises-book/">
<meta property="og:title" content="JavaScript Promiseの本">
<meta property="og:site_name" content="JavaScript Promiseの本">
<meta property="og:description" content="JavaScriptのPromiseを使った非同期処理の書き方、テスト、アンチパターンについて解説した無料の電子書籍">
<meta property="og:image" content="https://azu.github.io/promises-book/public/img/promise-catch.png">
<!-- Meta -->
<meta name="google-site-verification" content="bMotEbgYwkzA3k4PkuyK_NUdz0bKh-Phz0oUwNmRSVo"/>
<link rel="author" href="https://www.hatena.ne.jp/efcl/" />
<script type="text/javascript" src="public/js/google-analytics.js" async></script>
<link rel="canonical" href="https://azu.github.io/promises-book/">
<link rel="alternate" type="application/atom+xml" title="JavaScript Promiseの本"
      href="https://github.com/azu/promises-book/releases.atom">
<link href="public/img/favicon.ico" rel="shortcut icon" type="image/x-icon">
<link rel="icon" sizes="16x16 32x32" href="public/img/favicon.ico">
<link rel="stylesheet" type="text/css" href="public/css/build/all.css"/>
<script type="text/javascript" src="public/js/build/app.js" async defer></script>
</head>
<body class="article toc2 toc-left">
<div id="header">
<h1>JavaScript Promiseの本</h1>
<div class="details">
<span id="author" class="author">azu</span><br>
<span id="revnumber">version 2.0.0</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#introduction">はじめに</a>
<ul class="sectlevel2">
<li><a href="#_書籍の目的">書籍の目的</a></li>
<li><a href="#_本書を読むにあたって">本書を読むにあたって</a></li>
<li><a href="#_表記法">表記法</a></li>
<li><a href="#_推奨ブラウザ">推奨ブラウザ</a></li>
<li><a href="#_サンプルコードの実行">サンプルコードの実行</a></li>
<li><a href="#_本書のソースコード_ライセンス">本書のソースコード/ライセンス</a></li>
<li><a href="#_意見や疑問点">意見や疑問点</a></li>
</ul>
</li>
<li><a href="#chapter1-what-is-promise">1. Chapter.1 - Promiseとは何か</a>
<ul class="sectlevel2">
<li><a href="#what-is-promise">1.1. What Is Promise</a></li>
<li><a href="#promises-overview">1.2. Promise Overview</a></li>
<li><a href="#how-to-write-promise">1.3. Promiseの書き方</a></li>
</ul>
</li>
<li><a href="#chapter2-how-to-write-promise">2. Chapter.2 - Promiseの書き方</a>
<ul class="sectlevel2">
<li><a href="#ch2-promise-resolve">2.1. Promise.resolve</a></li>
<li><a href="#ch2-promise-reject">2.2. Promise.reject</a></li>
<li><a href="#promise-is-always-async">2.3. コラム: Promiseは常に非同期?</a></li>
<li><a href="#ch2-promise.then">2.4. Promise#then</a></li>
<li><a href="#ch2-promise-catch">2.5. Promise#catch</a></li>
<li><a href="#ch2-promise-finally">2.6. Promise#finally</a></li>
<li><a href="#then-return-new-promise">2.7. コラム: thenは常に新しいpromiseオブジェクトを返す</a></li>
<li><a href="#ch2-promise-and-array">2.8. Promiseと配列</a></li>
<li><a href="#ch2-promise-all">2.9. Promise.all</a></li>
<li><a href="#ch2-promise-race">2.10. Promise.race</a></li>
<li><a href="#then-or-catch">2.11. then or catch?</a></li>
</ul>
</li>
<li><a href="#chapter3-promise-testing">3. Chapter.3 - Promiseのテスト</a>
<ul class="sectlevel2">
<li><a href="#basic-tests">3.1. 基本的なテスト</a></li>
<li><a href="#mocha-promise">3.2. MochaのPromiseサポート</a></li>
<li><a href="#controllable-tests">3.3. 意図したテストを書くには</a></li>
</ul>
</li>
<li><a href="#chapter4-advanced-promise">4. Chapter.4 - Advanced</a>
<ul class="sectlevel2">
<li><a href="#promise-library">4.1. Promiseのライブラリ</a></li>
<li><a href="#resolve-thenable">4.2. Promise.resolveとThenable</a></li>
<li><a href="#not-throw-use-reject">4.3. throwしないで、rejectしよう</a></li>
<li><a href="#deferred-and-promise">4.4. DeferredとPromise</a></li>
<li><a href="#race-delay-timeout">4.5. Promise.raceとdelayによるXHRのキャンセル</a></li>
<li><a href="#promise-done">4.6. Promise.prototype.done とは何か?</a></li>
<li><a href="#promise-and-method-chain">4.7. Promiseとメソッドチェーン</a></li>
<li><a href="#promise-sequence">4.8. Promiseによる逐次処理</a></li>
</ul>
</li>
<li><a href="#chapter5-async-function">5. Chapter.5 - Async Function</a>
<ul class="sectlevel2">
<li><a href="#async-function">5.1. Async Functionとは</a></li>
<li><a href="#async-function-syntax">5.2. Async Functionの構文</a></li>
<li><a href="#async-function-await">5.3. <code>await</code>式</a></li>
<li><a href="#promise-chain-to-async-function">5.4. Async Functionと配列</a></li>
</ul>
</li>
<li><a href="#promise-api-reference">6. Promises API Reference</a>
<ul class="sectlevel2">
<li><a href="#promise.then">6.1. Promise#then</a></li>
<li><a href="#promise.catch">6.2. Promise#catch</a></li>
<li><a href="#promise.finally">6.3. Promise#finally</a></li>
<li><a href="#Promise.resolve">6.4. Promise.resolve</a></li>
<li><a href="#Promise.reject">6.5. Promise.reject</a></li>
<li><a href="#Promise.all">6.6. Promise.all</a></li>
<li><a href="#Promise.race">6.7. Promise.race</a></li>
</ul>
</li>
<li><a href="#promise-glossary">7. 用語集</a></li>
<li><a href="#resouce-link">8. 参考サイト</a></li>
<li><a href="#about-author">9. 著者について</a>
<ul class="sectlevel2">
<li><a href="#omake-message">9.1. 著者へのメッセージ/おまけ</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p><span class="icon"><i class="fa fa-globe fa-2x"></i></span> This book has been released in :</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Chinese</strong>: <a href="http://liubin.github.io/promises-book/">JavaScript Promise迷你书（中文版）</a></p>
</li>
<li>
<p><strong>Korean</strong>: <a href="http://www.hanbit.co.kr/store/books/look.php?p_code=E5027975256">한빛미디어 eBook JavaScript Promise（번역서）</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>These translated is based on Promise Book ver 1.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://azu.github.io/promises-book/archives/v1/">JavaScript Promiseの本(v1)</a></p>
</li>
</ul>
</div>
<hr>
<div class="github-ribbon">
<a href="https://github.com/azu/promises-book/"><img style="border: 0;" src="https://github.blog/wp-content/uploads/2008/12/forkme_right_darkblue_121621.png" alt="Fork me on GitHub" data-canonical-src="https://github.blog/wp-content/uploads/2008/12/forkme_right_darkblue_121621.png" /></a>
</div>
<div class="paragraph">
<p><span class="icon"><a class="image" href="https://twitter.com/search?q=%23Promise%E6%9C%AC"><i class="fa fa-twitter fa-2x"></i></a></span> ハッシュタグは <a href="https://twitter.com/search?q=%23Promise%E6%9C%AC">#Promise本</a></p>
</div>
<div class="paragraph">
<p><span class="icon"><a class="image" href="https://github.com/azu/promises-book/releases.atom"><i class="fa fa-rss fa-2x"></i></a></span> 更新情報は <a href="https://github.com/azu/promises-book/releases.atom">RSS</a> から購読できます</p>
</div>
<div class="social-button-wrapper">
<iframe src="https://ghbtns.com/github-btn.html?user=azu&repo=promises-book&type=watch&count=true"
  allowtransparency="true" frameborder="0" scrolling="0" width="100" height="20"></iframe>

<a href="https://twitter.com/share" class="twitter-share-button" data-url="https://azu.github.io/promises-book/" data-lang="ja" data-hashtags="Promise本">ツイート</a>
<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>

<a href="https://b.hatena.ne.jp/entry/https://azu.github.io/promises-book/" class="hatena-bookmark-button" data-hatena-bookmark-title="JavaScript Promiseの本" data-hatena-bookmark-layout="standard" title="このエントリーをはてなブックマークに追加"><img src="https://b.st-hatena.com/images/entry-button/button-only.gif" alt="" width="20" height="20" style="border: none;" /></a><script type="text/javascript" src="https://cdn-ak.b.st-hatena.com/js/bookmark_button.js" charset="utf-8" async="async"></script>
</div>
<div class="paragraph">
<p>この書籍はCreative Commons Attribution-NonCommercialの <a href="https://github.com/azu/promises-book/#license">ライセンス</a> で公開されています。
また、PDFとしてレンダリングしたバージョンは以下からダウンロードすることができます。</p>
</div>
<div class="download-area">
<a class="download-button pdf" id="download-pdf" href="https://azu.github.io/promises-book/javascript-promise-book.pdf" download="javascript-promise-book.pdf">PDF版をダウンロード</a>
<a class="download-button source-code" href="https://github.com/azu/promises-book/">ソースコードをダウンロード</a>
</div>
<div class="paragraph">
<p>作者を金銭的に支援がしたい人は <a href="https://github.com/sponsors/azu">GitHub Sponsors</a> でサポートできます。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/sponsors/azu">Sponsor @azu on GitHub Sponsors</a></p>
</li>
<li>
<p>Monthly または Onetimeでの支援ができます</p>
</li>
<li>
<p>寄付などがしたい場合はこちらを利用してください</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>この電子書籍の作り方に興味がある方は、
以下から <a href="https://gumroad.com/l/javascript-promise">おまけ</a> をダウンロードすることができます。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><span class="image"><a class="image" href="https://gumroad.com/l/javascript-promise"><img src="./public/img/gumroad-green.svg" alt="おまけをダウンロード"></a></span> <a href="https://gumroad.com/l/javascript-promise">おまけをダウンロード</a></p>
</li>
<li>
<p>書き始めた理由や、どのように書いていったか、どのような仕組みで動いているかなどについて書かれています。</p>
</li>
<li>
<p>Gumroadで購入者が0円から任意の値段を決めてダウンロードすることができます。</p>
</li>
<li>
<p>感想を書くコメント欄としても使えます。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>過去のバージョンについては、次のページから参照できます。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://azu.github.io/promises-book/archives/v1/">JavaScript Promiseの本(v1)</a></p>
</li>
</ul>
</div>
<hr>
<div style="page-break-after: always;"></div>
</div>
</div>
<div class="sect1">
<h2 id="introduction">はじめに</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_書籍の目的">書籍の目的</h3>
<div class="paragraph">
<p>この書籍はJavaScript標準仕様の<a href="#es-promises">ECMAScript Promises</a>を中心にし、
JavaScriptにおけるPromiseについて学ぶことが目的です。</p>
</div>
<div class="paragraph">
<p>この書籍では、次の3つを目標としています。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Promiseについて学び、パターンやテストを扱えること</p>
</li>
<li>
<p>Promiseの向き不向きについて学び、何でもPromiseで解決するべきではないと知ること</p>
</li>
<li>
<p>ES Promisesを元に基本をよく学び、より発展した形を自分で形成できること</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>この書籍では、先程も述べたように<a href="#es-promises">ES Promises</a>、
つまりJavaScriptの標準仕様(ECMAScript)をベースとしたPromiseについて書かれています。</p>
</div>
<div class="paragraph">
<p>そのため、FirefoxやChromeなどモダンなブラウザでは、ライブラリを使うこと無く利用できる機能であり、
またES Promisesは元が<a href="#promises-aplus">Promises/A+</a>というコミュニティベースの仕様であるため、多くの実装ライブラリがあります。</p>
</div>
<div class="paragraph">
<p>ブラウザネイティブの機能、またはライブラリを使うことで今すぐ利用できるPromiseについて基本的なAPIから学んでいきます。
その中でPromiseの得意/不得意を知り、Promiseを活用したJavaScriptを書けることを目的としています。</p>
</div>
</div>
<div class="sect2">
<h3 id="_本書を読むにあたって">本書を読むにあたって</h3>
<div class="paragraph">
<p>この書籍では、JavaScriptの基本的な文法や機能をすでに学習している前提です。</p>
</div>
<div class="paragraph">
<p>次のいずれかの書籍を読んでいれば、十分読み解ける内容だと思います。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://www.oreilly.co.jp/books/9784873113913/">JavaScript: The Good Parts</a></p>
</li>
<li>
<p><a href="https://www.oreilly.co.jp/books/9784873114880/">JavaScriptパターン</a></p>
</li>
<li>
<p><a href="https://www.oreilly.co.jp/books/9784873117836/">初めてのJavaScript 第3版</a></p>
</li>
<li>
<p><a href="https://www.oreilly.co.jp/books/9784873115733/">JavaScript 第6版</a></p>
</li>
<li>
<p><a href="https://gihyo.jp/book/2011/978-4-7741-4813-7">パーフェクトJavaScript</a></p>
</li>
<li>
<p><a href="https://gihyo.jp/book/2016/978-4-7741-8411-1">改訂新版JavaScript本格入門</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>この書籍ではECMAScript 2015(ES2015)で追加された構文を利用するため、JavaScriptの基本的な文法や機能に不安がある方は、次の書籍を参照してください。
ES2015以降をベースに、JavaScriptの基礎を一から学べる書籍です。
この書籍と同一の著者によって書かれており、ウェブでも公開されています。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://jsprimer.net">JavaScript Primer #jsprimer</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>または、JavaScriptでウェブアプリケーションを書いた経験やNode.js でコマンドラインアプリやサーバサイドを書いたことがあれば、
どこかで見たことがある内容が出てくるかもしれません。</p>
</div>
<div class="paragraph">
<p>一部セクションではNode.js環境での話となるため、Node.jsについて軽くでも知っておくとより理解がしやすいと思います。</p>
</div>
</div>
<div class="sect2">
<h3 id="_表記法">表記法</h3>
<div class="paragraph">
<p>この書籍では短縮するために幾つかの表記を用いています。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Promiseに関する用語は<a href="#promise-glossary">用語集</a>を参照する。</p>
<div class="ulist">
<ul>
<li>
<p>大体、初回に出てきた際にはリンクを貼っています。</p>
</li>
</ul>
</div>
</li>
<li>
<p>インスタンスメソッドを instance#method という表記で示す。</p>
<div class="ulist">
<ul>
<li>
<p>たとえば、<code>Promise#then</code> という表記は、Promiseのインスタンスオブジェクトの <code>then</code> メソッドを示しています。</p>
</li>
</ul>
</div>
</li>
<li>
<p>オブジェクトメソッドを object.method という表記で示す。</p>
<div class="ulist">
<ul>
<li>
<p>これはJavaScriptの意味そのままで、<code>Promise.all</code> なら静的メソッドを示しています。</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
この部分には文章についての補足が書かれています。
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_推奨ブラウザ">推奨ブラウザ</h3>
<div class="paragraph">
<p>この書籍を読むにあたっての推奨ブラウザとしては、ECMAScript 2015(ES2015)以降をサポートしているブラウザです。
Promiseは、ES2015で導入されたサンプルコードにES2015の文法を利用しているためです。</p>
</div>
<div class="paragraph">
<p>また、推奨環境ではありませんがiOSやAndroidなどのモバイル端末でも閲覧はできます。</p>
</div>
<div class="iframe-wrapper" style="width: 100%; height: 350px; overflow: auto; -webkit-overflow-scrolling: touch;">
<iframe src="https://caniuse.com/promises/embed/agents=desktop" width="100%" height="350px"></iframe>
</div>
</div>
<div class="sect2">
<h3 id="_サンプルコードの実行">サンプルコードの実行</h3>
<div class="paragraph">
<p>このサイトでは、Promiseの<a href="#promise-polyfill">Polyfillライブラリ</a>を読み込んでいるため、
Promiseをサポートしていないブラウザでもサンプルコードを実行できます。</p>
</div>
<div class="paragraph">
<p>また、以下のように実行できるサンプルコードには実行ボタンが表示されています。</p>
</div>
<div class="listingblock executable">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript">const promise = <span class="keyword">new</span> Promise((resolve) =&gt; {
    resolve(<span class="integer">42</span>);
});
promise.then((value) =&gt; {
    console.log(value);
}).<span class="keyword">catch</span>((error) =&gt; {
    console.error(error);
});</code></pre>
</div>
</div>
<div class="tutorial-area">
<button class="mirror-console-button mirror-console-run">実行</button> ボタンを押すことで、
サンプルコードがエディタとなりコードを実行できます。<br />
<button class="mirror-console-button mirror-console-clear">ログをクリア</button>ボタンでは実行結果の console.log で出力した内容を消せます。
<br />
<button class="mirror-console-button mirror-console-exit">終了</button>ボタンではエディタモードを終了します。
</div>
<div class="paragraph">
<p>気になるコードはその場で書き換えて実行できるため、理解するための補助として使って下さい。</p>
</div>
</div>
<div class="sect2">
<h3 id="_本書のソースコード_ライセンス">本書のソースコード/ライセンス</h3>
<div class="paragraph">
<p>この書籍に登場するサンプルのソースコード また その文章のソースコードは全てGitHubから取得できます。</p>
</div>
<div class="paragraph">
<p>この書籍は <a href="http://asciidoctor.org/">AsciiDoc</a> という形式で書かれています。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/azu/promises-book">azu/promises-book</a> <span class="image"><a class="image" href="https://travis-ci.org/azu/promises-book"><img src="https://travis-ci.org/azu/promises-book.svg?branch=master" alt="Build Status"></a></span></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>また、リポジトリには書籍中に出てくるサンプルコードのテストも含まれています。</p>
</div>
<div class="paragraph">
<p>ソースコードのライセンスはMITライセンスで、文章はCC-BY-NCで利用できます。</p>
</div>
</div>
<div class="sect2">
<h3 id="_意見や疑問点">意見や疑問点</h3>
<div class="paragraph">
<p>意見や疑問点がある場合はGitHubに直接Issueを作成できます。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/azu/promises-book/issues?state=open">Issues · azu/promises-book</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>また、この書籍についての <a href="https://gitter.im/azu/promises-book">チャットページ</a> に書いていくのもいいでしょう。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><span class="image"><a class="image" href="https://gitter.im/azu/promises-book"><img src="https://badges.gitter.im/azu/promises-book.png" alt="Gitter"></a></span></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Twitterでのハッシュタグは <span class="icon"><a class="image" href="https://twitter.com/search?q=%23Promise%E6%9C%AC"><i class="fa fa-twitter fa-2x"></i></a></span> <a href="https://twitter.com/search?q=%23Promise%E6%9C%AC">#Promise本</a>
なので、こちらを利用するのもいいでしょう。</p>
</div>
<div class="paragraph">
<p>この書籍は読める権利と同時に編集する権利があるため、
GitHubで <a href="https://github.com/azu/promises-book/pulls">Pull Requests</a> も歓迎しています。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="chapter1-what-is-promise">1. Chapter.1 - Promiseとは何か</h2>
<div class="sectionbody">
<div class="paragraph">
<p>この章では、JavaScriptにおけるPromiseについて簡単に紹介していきます。</p>
</div>
<div class="sect2">
<h3 id="what-is-promise">1.1. What Is Promise</h3>
<div class="paragraph">
<p>まずPromiseとはそもそもどのようなものでしょうか?</p>
</div>
<div class="paragraph">
<p>Promiseは非同期処理を抽象化したオブジェクトとそれを操作する仕組みのことをいいます。
詳しくはこれから学んでいくとして、PromiseはJavaScriptで発見された概念ではありません。</p>
</div>
<div class="paragraph">
<p>最初に発見されたのは <a href="http://erights.org/elib/distrib/pipeline.html">E言語</a>におけるもので、
並列/並行処理におけるプログラミング言語のデザインの一種です。</p>
</div>
<div class="paragraph">
<p>このデザインをJavaScriptに持ってきたものが、この書籍で学ぶJavaScript Promiseです。
Promiseは、JavaScriptの仕様を決めるECMAScript 2015で導入され動作が定義されています。</p>
</div>
<div class="paragraph">
<p>一方、JavaScriptにおける非同期処理といえば、コールバックを利用する場合が多いと思います。</p>
</div>
<div class="listingblock">
<div class="title">コールバックを使った非同期処理の一例</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript">getAsync(<span class="string"><span class="delimiter">&quot;</span><span class="content">fileA.txt</span><span class="delimiter">&quot;</span></span>, (error, result) =&gt; { <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="keyword">if</span> (error) { <span class="comment">// 取得失敗時の処理</span>
        <span class="keyword">throw</span> error;
    }
    <span class="comment">// 取得成功の処理</span>
});</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>コールバック関数の引数には(エラーオブジェクト, 結果)が入る</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Node.js等JavaScriptでのコールバック関数の第一引数には <code>Error</code> オブジェクトを渡すというルールを用いるケースがあります。</p>
</div>
<div class="paragraph">
<p>このようにコールバックでの非同期処理もルールが統一されていた場合、コールバック関数の書き方が明確になります。
しかし、これはあくまでコーディングルールであるため、異なる書き方をしても決して間違いではありません。</p>
</div>
<div class="paragraph">
<p>Promiseでは、このような非同期に対するオブジェクトとルールを仕様化して、
統一的なインターフェースで書くようになっており、それ以外の書き方は出来ないようになっています。</p>
</div>
<div class="listingblock">
<div class="title">Promiseを使った非同期処理の一例</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript">const promise = getAsyncPromise(<span class="string"><span class="delimiter">&quot;</span><span class="content">fileA.txt</span><span class="delimiter">&quot;</span></span>); <i class="conum" data-value="1"></i><b>(1)</b>
promise.then((result) =&gt; {
    <span class="comment">// 取得成功の処理</span>
}).<span class="keyword">catch</span>((error) =&gt; {
    <span class="comment">// 取得失敗時の処理</span>
});</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>promiseオブジェクトを返す</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>非同期処理を抽象化したpromiseオブジェクトというものを用意し、
そのpromiseオブジェクトに対して成功時の処理と失敗時の処理の関数を登録するようにして使います。</p>
</div>
<div class="paragraph">
<p>コールバック関数と比べると何が違うのかを簡単に見ると、
非同期処理の書き方がpromiseオブジェクトのインターフェースに沿った書き方に限定されます。</p>
</div>
<div class="paragraph">
<p>つまり、promiseオブジェクトに用意されているメソッド(ここでは <code>then</code> や <code>catch</code>)以外は使えないため、
コールバックのように引数に何を入れるかが自由に決められるわけではなく、一定のやり方に統一されます。</p>
</div>
<div class="paragraph">
<p>この、Promiseという統一されたインターフェースがあることで、
そのインターフェースにおけるさまざまな非同期処理のパターンを形成することができます。</p>
</div>
<div class="paragraph">
<p>つまり、複雑な非同期処理等を上手くパターン化できるというのがPromiseの役割であり、
Promiseを使う理由の一つであるといえるでしょう。</p>
</div>
<div class="paragraph">
<p>それでは、実際にJavaScriptでのPromiseについて学んでいきましょう。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Arrow Function <code>&#8658;</code></div>
<div class="paragraph">
<p>この書籍のサンプルコードはArrow FunctionなどECMAScript 2015で導入された構文を利用します。</p>
</div>
<div class="paragraph">
<p>Arrow Functionは、矢印のような <code>&#8658;</code> （イコールと大なり記号）を使い、匿名関数を定義する構文です。
関数式と定義方法や使い方は同じです。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript"><span class="comment">// 関数式の定義と実行</span>
const <span class="function">fn</span> = <span class="keyword">function</span>(arg) {
    console.log(<span class="string"><span class="delimiter">&quot;</span><span class="content">通常の関数定義, 引数:</span><span class="delimiter">&quot;</span></span> + arg);
};
fn(<span class="string"><span class="delimiter">&quot;</span><span class="content">引数</span><span class="delimiter">&quot;</span></span>);

<span class="comment">// Arrow Functionの定義と実行</span>
const arrowFunction = (arg) =&gt; {
    console.log(<span class="string"><span class="delimiter">&quot;</span><span class="content">Arrow Functionでの関数定義, 引数:</span><span class="delimiter">&quot;</span></span> + arg);
};
arrowFunction(<span class="string"><span class="delimiter">&quot;</span><span class="content">引数</span><span class="delimiter">&quot;</span></span>);</code></pre>
</div>
</div>
<div class="paragraph">
<p>通常の関数式と`&#8658;`という記法を使う以外にも次のような特徴があります。</p>
</div>
<div class="paragraph">
<p>Arrow Functionには次のような特徴があります。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>名前を付けることができない（常に匿名関数）</p>
</li>
<li>
<p><code>this</code> が静的に決定できる</p>
</li>
<li>
<p><code>function</code> キーワードに比べて短く書くことができる</p>
</li>
<li>
<p><code>new</code> できない（コンストラクタ関数ではない）</p>
</li>
<li>
<p><code>arguments</code> 変数を参照できない(Rest Parametersを代わりに利用する)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Arrow Functionを使うことで、コールバック関数を関数式に比べて短く簡潔に書くことができます。
そのため、この書籍ではArrow Functionをメインに利用しています。</p>
</div>
<div class="paragraph">
<p>Arrow Functionの詳細は <a href="https://jsprimer.net">JavaScript Primer</a> を参照してください。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://jsprimer.net/basic/function-declaration/#arrow-function">関数と宣言 · JavaScript Primer #jsprimer</a></p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="promises-overview">1.2. Promise Overview</h3>
<div class="paragraph">
<p><a href="#es-promises">ES Promises</a>の仕様で定義されているAPIはそこまで多くはありません。</p>
</div>
<div class="paragraph">
<p>大きく分けて以下の3種類になります。</p>
</div>
<div class="paragraph">
<p><strong>Constructor</strong></p>
</div>
<div class="paragraph">
<p>Promiseは <code>XMLHttpRequest</code> のように、コンストラクタ関数である <code>Promise</code> からインスタンスとなる
promiseオブジェクトを作成して利用します。</p>
</div>
<div class="paragraph">
<p>promiseオブジェクトを作成するには、<code>Promise</code> コンストラクタを <code>new</code> でインスタンス化します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript">const promise = <span class="keyword">new</span> Promise((resolve, reject) =&gt; {
    <span class="comment">// 非同期の処理</span>
    <span class="comment">// 処理が終わったら、resolve または rejectを呼ぶ</span>
});</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Instance Method</strong></p>
</div>
<div class="paragraph">
<p>newによって生成されたpromiseオブジェクトにはpromiseの値を <strong>resolve</strong>(成功) / <strong>reject</strong>(失敗) した時に呼ばれる
コールバック関数を登録するために <code>promise.then()</code> というインスタンスメソッドがあります。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript">promise.then(onFulfilled, onRejected);</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">resolve(成功)した時</dt>
<dd>
<p><code>onFulfilled</code> が呼ばれる</p>
</dd>
<dt class="hdlist1">reject(失敗)した時</dt>
<dd>
<p><code>onRejected</code>  が呼ばれる</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p><code>onFulfilled</code>、<code>onRejected</code> どちらもオプショナルな引数となっています。</p>
</div>
<div class="paragraph">
<p><code>promise.then</code> では成功時と失敗時の処理を同時に登録することができます。
また、エラー処理だけを書きたい場合には <code>promise.then(undefined, onRejected)</code> と同じ意味である
<code>promise.catch(onRejected)</code> を使うことができます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript">promise.<span class="keyword">catch</span>(onRejected);</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Static Method</strong></p>
</div>
<div class="paragraph">
<p><code>Promise</code> というグローバルオブジェクトには幾つかの静的なメソッドが存在します。</p>
</div>
<div class="paragraph">
<p><code>Promise.all()</code> や <code>Promise.resolve()</code> などが該当し、Promiseを扱う上での補助メソッドが中心となっています。</p>
</div>
<div class="sect3">
<h4 id="_promise_workflow">1.2.1. Promise workflow</h4>
<div class="paragraph">
<p>以下のようなサンプルコードを見てみましょう。</p>
</div>
<div id="promise-workflow.js" class="listingblock executable">
<div class="title">promise-workflow.js</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript"><span class="keyword">function</span> <span class="function">asyncFunction</span>() {
    <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="keyword">return</span> <span class="keyword">new</span> Promise((resolve) =&gt; {
        setTimeout(() =&gt; {
            resolve(<span class="string"><span class="delimiter">&quot;</span><span class="content">Async Hello world</span><span class="delimiter">&quot;</span></span>);
        }, <span class="integer">16</span>);
    });
}
<i class="conum" data-value="2"></i><b>(2)</b>
asyncFunction().then((value) =&gt; {
    console.log(value); <span class="comment">// =&gt; 'Async Hello world'</span>
}).<span class="keyword">catch</span>((error) =&gt; {
    console.error(error);
});</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Promiseコンストラクタを <code>new</code> して、promiseオブジェクトを返します</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>&lt;1&gt;のpromiseオブジェクトに対して <code>.then</code> で値が返ってきた時のコールバックを設定します</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>asyncFunction</code> という関数 は promiseオブジェクトを返していて、
そのpromiseオブジェクトに対して <code>then</code> でresolveした時のコールバックを、
<code>catch</code> でエラーとなった場合のコールバックを設定しています。</p>
</div>
<div class="paragraph">
<p>このpromiseオブジェクトはsetTimeoutで16ms後にresolveされるので、
そのタイミングで <code>then</code> のコールバックが呼ばれ <code>'Async Hello world'</code> と出力されます。</p>
</div>
<div class="paragraph">
<p>この場合 <code>catch</code> のコールバックは呼ばれることはないですが、
<code>setTimeout</code> が存在しない環境などでは、例外が発生し <code>catch</code> で登録したコールバック関数が呼ばれると思います。</p>
</div>
<div class="paragraph">
<p>もちろん、<code>promise.then(onFulfilled, onRejected)</code> というように、
<code>catch</code> を使わずに <code>then</code> を使い、以下のように2つのコールバック関数を設定することでもほぼ同様の動作になります。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript">asyncFunction().then((value) =&gt; {
    console.log(value);
}, (error) =&gt; {
    console.error(error);
});</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="promise-states">1.2.2. Promiseの状態</h4>
<div class="paragraph">
<p>Promiseの処理の流れが少しわかった所で、Promiseの状態について整理したいと思います。</p>
</div>
<div class="paragraph">
<p><code>new Promise</code> でインスタンス化したpromiseオブジェクトには以下の3つの状態が存在します。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Fulfilled</dt>
<dd>
<p>resolve(成功)した時。このとき <code>onFulfilled</code> が呼ばれる</p>
</dd>
<dt class="hdlist1">Rejected</dt>
<dd>
<p>reject(失敗)した時。このとき <code>onRejected</code>  が呼ばれる</p>
</dd>
<dt class="hdlist1">Pending</dt>
<dd>
<p>FulfilledまたはRejectedではない時。つまりpromiseオブジェクトが作成された初期状態等が該当する</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>これらの状態は<a href="#es-promises">ES Promises</a>の仕様で定められている名前です。
この状態をプログラムで直接触る方法は用意されていないため、書く際には余り気にしなくても問題ないですが、
Promiseについて理解するのに役に立ちます。</p>
</div>
<div class="paragraph">
<p>この書籍では、<em>Pending</em>、<em>Fulfilled</em> 、<em>Rejected</em> の状態を用いて解説していきます。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="Ch1_WhatsPromises/img/promise-states.png" alt="promise-states">
</div>
<div class="title">Figure 1. promise states</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p><a href="#es-promises">ES Promisesの仕様</a> では <code>[[PromiseStatus]]</code> という内部定義によって状態が定められています。
<code>[[PromiseStatus]]</code> にアクセスするユーザーAPIは用意されていないため、基本的には知る方法はありません。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>3つの状態を見たところで、すでにこの章で全ての状態が出てきていることが分かります。</p>
</div>
<div class="paragraph">
<p>promiseオブジェクトの状態は、一度<em>Pending</em>から<em>Fulfilled</em>や<em>Rejected</em>になると、
そのpromiseオブジェクトの状態はそれ以降変化することはなくなります。</p>
</div>
<div class="paragraph">
<p>つまり、PromiseはEvent等とは違い、<code>.then</code> で登録した関数が呼ばれるのは1回限りということが明確になっています。</p>
</div>
<div class="paragraph">
<p>また、<em>Fulfilled</em>と<em>Rejected</em>のどちらかの状態であることを<strong>Settled</strong>(不変の)と表現することがあります。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Settled</dt>
<dd>
<p>resolve(成功) または reject(失敗) した時。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p><em>Pending</em>と<em>Settled</em>が対となる関係であると考えると、Promiseの状態の種類/遷移がシンプルであることが分かると思います。</p>
</div>
<div class="paragraph">
<p>このpromiseオブジェクトの状態が変化した時に、一度だけ呼ばれる関数を登録するのが <code>.then</code> といったメソッドとなるわけです。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p><a href="https://speakerdeck.com/kerrick/javascript-promises-thinking-sync-in-an-async-world">JavaScript Promises - Thinking Sync in an Async World // Speaker Deck</a>
というスライドではPromiseの状態遷移について分かりやすく書かれています。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="how-to-write-promise">1.3. Promiseの書き方</h3>
<div class="paragraph">
<p>Promiseの基本的な書き方について解説します。</p>
</div>
<div class="sect3">
<h4 id="_promiseオブジェクトの作成">1.3.1. promiseオブジェクトの作成</h4>
<div class="paragraph">
<p>promiseオブジェクトを作る流れは以下のようになっています。</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>new Promise(fn)</code> の返り値がpromiseオブジェクト</p>
</li>
<li>
<p><code>fn</code> には非同期等の何らかの処理を書く</p>
<div class="ulist">
<ul>
<li>
<p>処理結果が正常なら、<code>resolve(結果の値)</code> を呼ぶ</p>
</li>
<li>
<p>処理結果がエラーなら、<code>reject(Errorオブジェクト)</code> を呼ぶ</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>この流れに沿っているものを実際に書いてみましょう。</p>
</div>
<div class="paragraph">
<p>非同期処理であるXMLHttpRequest(XHR)を使いデータを取得するものをPromiseで書いていきます。</p>
</div>
<div class="sect4">
<h5 id="_xhrのpromiseオブジェクトを作る">XHRのpromiseオブジェクトを作る</h5>
<div class="paragraph">
<p>まずは、XHRをPromiseを使って包んだような <code>fetchURL</code> という関数を作ります。</p>
</div>
<div id="xhr-promise.js" class="listingblock executable">
<div class="title">xhr-promise.js</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript"><span class="keyword">function</span> <span class="function">fetchURL</span>(URL) {
    <span class="keyword">return</span> <span class="keyword">new</span> Promise((resolve, reject) =&gt; {
        const req = <span class="keyword">new</span> XMLHttpRequest();
        req.open(<span class="string"><span class="delimiter">&quot;</span><span class="content">GET</span><span class="delimiter">&quot;</span></span>, URL, <span class="predefined-constant">true</span>);
        req.onload = () =&gt; {
            <span class="keyword">if</span> (<span class="integer">200</span> &lt;= req.status &amp;&amp; req.status &lt; <span class="integer">300</span>) {
                resolve(req.responseText);
            } <span class="keyword">else</span> {
                reject(<span class="keyword">new</span> Error(req.statusText));
            }
        };
        req.onerror = () =&gt; {
            reject(<span class="keyword">new</span> Error(req.statusText));
        };
        req.send();
    });
}

<span class="comment">// 実行例</span>
const URL = <span class="string"><span class="delimiter">&quot;</span><span class="content">https://httpbin.org/get</span><span class="delimiter">&quot;</span></span>;
fetchURL(URL).then(<span class="keyword">function</span> <span class="function">onFulfilled</span>(value){
    console.log(value);
}).<span class="keyword">catch</span>(<span class="keyword">function</span> <span class="function">onRejected</span>(error){
    console.error(error);
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>この <code>fetchURL</code> では、
XHRでの取得結果のステータスコードが200以上300未満の場合は <code>resolve</code> - つまり取得に成功、
それ以外はエラーであるとして <code>reject</code> しています。</p>
</div>
<div class="paragraph">
<p><code>resolve(req.responseText)</code> ではレスポンスの内容を引数に入れています。
resolveの引数に入れる値には特に決まりはありませんが、コールバックと同様に次の処理へ渡したい値を入れるといいでしょう。
(この値は <code>then</code> メソッドで受け取ることができます)</p>
</div>
<div class="paragraph">
<p>Node.jsをやっている人は、コールバックを書く時に <code>callback(error, response)</code> と第一引数にエラーオブジェクトを
入れることがよくあると思いますが、Promiseでは役割がresolve/rejectで分担されているので、
resolveにはresponseの値のみをいれるだけで問題ありません。</p>
</div>
<div class="paragraph">
<p>次に、<code>reject</code> の方を見ていきましょう。</p>
</div>
<div class="paragraph">
<p>XHRで <code>onerror</code> のイベントが呼ばれた場合はもちろんエラーなので <code>reject</code> を呼びます。
ここで <code>reject</code> に渡している値に注目してみてください。</p>
</div>
<div class="paragraph">
<p>エラーの場合は <code>reject(new Error(req.statusText));</code> というように、Errorオブジェクトを作成して渡していることが分かると思います。
<code>reject</code> に渡す値に制限はありませんが、一般的にErrorオブジェクト(またはErrorオブジェクトを継承したもの)を渡すことになっています。</p>
</div>
<div class="paragraph">
<p><code>reject</code> に渡す値は、rejectする理由を書いたErrorオブジェクトとなっています。
今回は、ステータスコードが2xx以外であるならrejectするとしていたため、<code>reject</code> にはstatusTextを入れています。
(この値は <code>then</code> メソッドの第二引数 or <code>catch</code> メソッドで受け取ることができます)</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_promiseオブジェクトに処理を書く">1.3.2. promiseオブジェクトに処理を書く</h4>
<div class="paragraph">
<p>先ほどの作成したpromiseオブジェクトを返す関数を実際に使ってみましょう。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript">fetchURL(<span class="string"><span class="delimiter">&quot;</span><span class="content">https://httpbin.org/get</span><span class="delimiter">&quot;</span></span>); <span class="comment">// =&gt; promiseオブジェクトが返ってくる</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="#promises-overview">Promises Overview</a> でも簡単に紹介したようにpromiseオブジェクトは幾つかインスタンスメソッドを持っており、
これを使いpromiseオブジェクトの状態に応じて一度だけ呼ばれるコールバックとなる関数を登録します。</p>
</div>
<div class="paragraph">
<p>promiseオブジェクトに登録する処理は以下の2種類が主となります。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>promiseオブジェクトが <strong>resolve</strong> された時の処理(onFulfilled)</p>
</li>
<li>
<p>promiseオブジェクトが <strong>reject</strong> された時の処理(onRejected)</p>
</li>
</ul>
</div>
<div id="promise-value-flow" class="imageblock">
<div class="content">
<img src="Ch1_WhatsPromises/img/promise-onFulfilled_onRejected.png" alt="promise-resolve-flow">
</div>
<div class="title">Figure 2. promise value flow</div>
</div>
<div class="paragraph">
<p>まずは、<code>fetchURL</code> で通信が成功して値が取得できた場合の処理を書いてみましょう。</p>
</div>
<div class="paragraph">
<p>この場合の <em>通信が成功した</em> というのは、
resolveされたことにより <em>promiseオブジェクトがFulfilledの状態になった</em> 時ということですね。</p>
</div>
<div class="paragraph">
<p><strong>resolve</strong>された時の処理は、 <a href="#promise.then"><code>.then</code></a> メソッドに呼びたい関数を渡すことで行えます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript">const URL = <span class="string"><span class="delimiter">&quot;</span><span class="content">https://httpbin.org/get</span><span class="delimiter">&quot;</span></span>;
fetchURL(URL).then((value) =&gt; { <i class="conum" data-value="1"></i><b>(1)</b>
    console.log(value);
});</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>分かりやすくするため関数に <code>onFulfilled</code> という名前を付けています</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><a href="#xhr-promise.js">fetchURL関数</a> 内で <code>resolve(req.responseText);</code> によってpromiseオブジェクトが解決されると、
値と共に <code>onFulfilled</code> 関数が呼ばれます。</p>
</div>
<div class="paragraph">
<p>このままでは通信エラーが起きた場合などに何も処理がされないため、
今度は、<code>fetchURL</code> で何らかの問題があってエラーが起きた場合の処理を書いてみましょう。</p>
</div>
<div class="paragraph">
<p>この場合の <em>エラーが起きた</em> というのは、
rejectされたことより <em>promiseオブジェクトがRejectedの状態になった</em> 時ということですね。</p>
</div>
<div class="paragraph">
<p><strong>reject</strong>された時の処理は、<a href="#promise.then"><code>.then</code> の第二引数</a> または <a href="#promise.catch"><code>.catch</code></a> メソッドに呼びたい関数を渡すことで行えます。</p>
</div>
<div class="paragraph">
<p>先ほどのソースにrejectされた場合の処理を追加してみましょう。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript">const URL = <span class="string"><span class="delimiter">&quot;</span><span class="content">https://httpbin.org/status/500</span><span class="delimiter">&quot;</span></span>; <i class="conum" data-value="1"></i><b>(1)</b>
fetchURL(URL).then((value) =&gt; {
    console.log(value);
}).<span class="keyword">catch</span>((error) =&gt; { <i class="conum" data-value="2"></i><b>(2)</b>
    console.error(error);
});</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>サーバはステータスコード500のレスポンスを返す</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>分かりやすくするため関数 <code>onRejected</code> という名前を付けています</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>fetchURL</code> の処理中に何らかの理由で例外が起きた場合、または明示的にrejectされた場合に、
その理由(Errorオブジェクト)と共に <a href="#promise.catch"><code>.catch</code></a> の処理が呼ばれます。</p>
</div>
<div class="paragraph">
<p><a href="#promise.catch"><code>.catch</code></a>は <code>promise.then(undefined, onRejected)</code> のエイリアスであるため、
同様の処理は以下のように書くこともできます。</p>
</div>
<div id="catch-as-alias" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript">fetchURL(URL).then(onFulfilled, onRejected); <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>onFulfilled, onRejected それぞれは先ほどと同じ関数</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>基本的には、<a href="#promise.catch"><code>.catch</code></a>を使いresolveとrejectそれぞれを別々に処理した方がよいと考えられますが、
両者の違いについては <a href="#then-or-catch">then or catch?</a> で紹介します。</p>
</div>
<div class="sect4">
<h5 id="_まとめ">まとめ</h5>
<div class="paragraph">
<p>この章では以下のことについて簡単に紹介しました。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>new Promise</code> を使ったpromiseオブジェクトの作成</p>
</li>
<li>
<p><a href="#promise.then"><code>.then</code></a> や <a href="#promise.catch"><code>.catch</code></a> を使ったpromiseオブジェクトの処理</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Promiseの基本的な書き方について学びました。
他の多くの処理はこれを発展させたり、用意された静的メソッドを利用したものになります。</p>
</div>
<div class="paragraph">
<p>ここでは、同様のことはコールバック関数を渡す形でもできるのに対してPromiseで書くメリットについては触れていませんでした。
次の章では、Promiseのメリットであるエラーハンドリングの仕組みをコールバックベースの実装と比較しながら見ていきたいと思います。</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="chapter2-how-to-write-promise">2. Chapter.2 - Promiseの書き方</h2>
<div class="sectionbody">
<div class="paragraph">
<p>この章では、Promiseのメソッドの使い方、エラーハンドリングについて学びます。</p>
</div>
<div class="sect2">
<h3 id="ch2-promise-resolve">2.1. Promise.resolve</h3>
<div class="paragraph">
<p>一般に <code>new Promise()</code> を使うことでpromiseオブジェクトを生成しますが、
それ以外にもpromiseオブジェクトを生成する方法があります。</p>
</div>
<div class="paragraph">
<p>ここでは、<a href="#Promise.resolve"><code>Promise.resolve</code></a> と <a href="#Promise.reject"><code>Promise.reject</code></a> について学びたいと思います。</p>
</div>
<div class="sect3">
<h4 id="_new_promiseのショートカット">2.1.1. new Promiseのショートカット</h4>
<div class="paragraph">
<p><a href="#Promise.resolve"><code>Promise.resolve(value)</code></a> という静的メソッドは、
<code>new Promise()</code> のショートカットとなるメソッドです。</p>
</div>
<div class="paragraph">
<p>たとえば、 <code>Promise.resolve(42);</code> というのは下記のコードのシンタックスシュガーです。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript"><span class="keyword">new</span> Promise((resolve) =&gt; {
    resolve(<span class="integer">42</span>);
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>結果的にすぐに <code>resolve(42);</code> と解決されて、次のthenの <code>onFulfilled</code> に設定された関数に <code>42</code> という値を渡します。</p>
</div>
<div class="paragraph">
<p><code>Promise.resolve(value);</code> で返ってくる値も同様にpromiseオブジェクトなので、
以下のように続けて <code>.then</code> を使った処理を書くことができます。</p>
</div>
<div class="listingblock executable">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript">Promise.resolve(<span class="integer">42</span>).then((value) =&gt; {
    console.log(value);
});</code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="#Promise.resolve">Promise.resolve</a>は <code>new Promise()</code> のショートカットとして、
promiseオブジェクトの初期化時やテストコードを書く際にも活用できます。</p>
</div>
</div>
<div class="sect3">
<h4 id="_thenable">2.1.2. Thenable</h4>
<div class="paragraph">
<p>もう一つ <code>Promise.resolve</code> の大きな特徴として、<a href="#Thenable">thenable</a>なオブジェクトをpromiseオブジェクトに変換するという機能があります。</p>
</div>
<div class="paragraph">
<p><a href="#es-promises">ES Promises</a>には<a href="#Thenable">Thenable</a>という概念があり、簡単にいえばpromiseっぽいオブジェクトのことを言います。</p>
</div>
<div class="paragraph">
<p><code>.length</code> を持っているが配列ではないものをArray likeというのと同じで、
thenableの場合は <code>.then</code> というメソッドを持ってるオブジェクトを言います。</p>
</div>
<div class="paragraph">
<p>thenableなオブジェクトがもつ <code>then</code> は、Promiseのもつ <code>then</code> と同じような挙動を期待していて、
thenableなオブジェクトがもつ元々の <code>then</code> を上手く利用できるようにしpromiseオブジェクトに変換するという仕組みです。</p>
</div>
<div class="paragraph">
<p>どのようなものがthenableなのかというと、分かりやすい例では
<a href="https://api.jquery.com/jQuery.ajax/">jQuery.ajax()</a>の返り値もthenableです。</p>
</div>
<div class="paragraph">
<p><code>jQuery.ajax()</code> の返り値は <a href="http://api.jquery.com/jQuery.ajax/#jqXHR">jqXHR Object</a> というもので、
このオブジェクトは <code>.then</code> というメソッドを持っているためです。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript"><span class="predefined">$</span>.ajax(<span class="string"><span class="delimiter">&quot;</span><span class="content">https://httpbin.org/get</span><span class="delimiter">&quot;</span></span>);<span class="comment">// =&gt; `.then` をもつオブジェクト</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>このthenableなオブジェクトを <code>Promise.resolve</code> ではpromiseオブジェクトにすることができます。</p>
</div>
<div class="paragraph">
<p>promiseオブジェクトにすることができれば、<code>then</code> や <code>catch</code> といった、
<a href="#es-promises">ES Promises</a>がもつ機能をそのまま利用することができるようになります。</p>
</div>
<div class="listingblock">
<div class="title">thenableをpromiseオブジェクトにする</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript"><span class="comment">// このサンプルコードはjQueryをロードしている場所でないと動きません</span>
const promise = Promise.resolve(<span class="predefined">$</span>.ajax(<span class="string"><span class="delimiter">&quot;</span><span class="content">https://httpbin.org/get</span><span class="delimiter">&quot;</span></span>));<span class="comment">// =&gt; promiseオブジェクト</span>
promise.then((value) =&gt; {
    console.log(value);
});</code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="title">jQueryとthenable</div>
<div class="paragraph">
<p><a href="https://api.jquery.com/jQuery.ajax/">jQuery.ajax()</a>の返り値も <code>.then</code> というメソッドを持った <a href="http://api.jquery.com/jQuery.ajax/#jqXHR">jqXHR Object</a>で、
このオブジェクトは <a href="http://api.jquery.com/category/deferred-object/">Deferred Object</a> のメソッドやプロパティ等を継承しています。</p>
</div>
<div class="paragraph">
<p>しかし、jQuery 2.x以下では、このDeferred Objectは<a href="#promises-aplus">Promises/A+</a>や<a href="#es-promises">ES Promises</a>に準拠したものではありません。
そのため、Deferred Objectをpromiseオブジェクトへ変換できたように見えて、一部欠損する情報がでてしまうという問題があります。</p>
</div>
<div class="paragraph">
<p>この問題はjQueryの <a href="http://api.jquery.com/category/deferred-object/">Deferred Object</a> の <code>then</code> の挙動が違うために発生します。</p>
</div>
<div class="paragraph">
<p>そのため、<code>.then</code> というメソッドを持っていた場合でも、必ずES Promisesとして使えるとは限らないことは知っておくべきでしょう。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="http://www.html5rocks.com/ja/tutorials/es6/promises/#toc-lib-compatibility">JavaScript Promises: There and back again - HTML5 Rocks</a></p>
</li>
<li>
<p><a href="http://domenic.me/2012/10/14/youre-missing-the-point-of-promises/">You&#39;re Missing the Point of Promises</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>なお、jQuery 3.0からは、 <a href="http://api.jquery.com/category/deferred-object/">Deferred Object</a>や <a href="http://api.jquery.com/jQuery.ajax/#jqXHR">jqXHR Object</a>が<a href="#promises-aplus">Promises/A+</a>準拠へと変更されています。
そのため、上記で紹介されている <code>.then</code> の挙動が異なる問題は解消されています。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://blog.jquery.com/2016/06/09/jquery-3-0-final-released/">jQuery 3.0 Final Released! | Official jQuery Blog</a></p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>Promise.resolve</code> は共通の挙動である <code>then</code> だけを利用して、
さまざまなライブラリ間でのpromiseオブジェクトを相互に変換して使える仕組みを持っていることになります。</p>
</div>
<div class="paragraph">
<p>このthenableを変換する機能は、以前は <code>Promise.cast</code> という名前であったことからもその挙動が想像できるかもしれません。</p>
</div>
<div class="paragraph">
<p>ThenableについてはPromiseを使ったライブラリを書くとき等には知っておくべきですが、
通常の利用だとそこまで使う機会がないものかもしれません。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>ThenableとPromise.resolveの具体的な例を交えたものは
第4章の<a href="#resolve-thenable">Promise.resolveとThenable</a>にて詳しく解説しています。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>Promise.resolve</code> を簡単にまとめると、「渡した値でFulfilledされるpromiseオブジェクトを返すメソッド」と考えるのがいいでしょう。</p>
</div>
<div class="paragraph">
<p>また、Promiseの多くの処理は内部的に <code>Promise.resolve</code> のアルゴリズムを使って値をpromiseオブジェクトに変換しています。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="ch2-promise-reject">2.2. Promise.reject</h3>
<div class="paragraph">
<p><a href="#Promise.reject"><code>Promise.reject(error)</code></a>は
<a href="#Promise.resolve"><code>Promise.resolve(value)</code></a> と同じ静的メソッドで <code>new Promise()</code> のショートカットとなるメソッドです。</p>
</div>
<div class="paragraph">
<p>たとえば、 <code>Promise.reject(new Error("エラー"))</code> というのは下記のコードのシンタックスシュガーです。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript"><span class="keyword">new</span> Promise((resolve, reject) =&gt; {
    reject(<span class="keyword">new</span> Error(<span class="string"><span class="delimiter">&quot;</span><span class="content">エラー</span><span class="delimiter">&quot;</span></span>));
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>返り値のpromiseオブジェクトに対して、thenの <code>onRejected</code> に設定された関数にエラーオブジェクトが渡ります。</p>
</div>
<div class="listingblock executable">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript">Promise.reject(<span class="keyword">new</span> Error(<span class="string"><span class="delimiter">&quot;</span><span class="content">BOOM!</span><span class="delimiter">&quot;</span></span>)).<span class="keyword">catch</span>((error) =&gt; {
    console.error(error);
});</code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="#Promise.resolve"><code>Promise.resolve(value)</code></a> との違いは resolveではなくrejectが呼ばれるという点で、
テストコードやデバッグ、一貫性を保つために利用する機会などがあるかもしれません。</p>
</div>
</div>
<div class="sect2">
<h3 id="promise-is-always-async">2.3. コラム: Promiseは常に非同期?</h3>
<div class="paragraph">
<p><a href="#Promise.resolve"><code>Promise.resolve(value)</code></a> 等を使った場合、
promiseオブジェクトがすぐにresolveされるので、<code>.then</code> に登録した関数も同期的に処理が行われるように錯覚してしまいます。</p>
</div>
<div class="paragraph">
<p>しかし、実際には <code>.then</code> で登録した関数が呼ばれるのは、非同期となります。</p>
</div>
<div class="listingblock executable">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript">const promise = <span class="keyword">new</span> Promise((resolve) =&gt; {
    console.log(<span class="string"><span class="delimiter">&quot;</span><span class="content">inner promise</span><span class="delimiter">&quot;</span></span>); <span class="comment">// 1</span>
    resolve(<span class="integer">42</span>);
});
promise.then((value) =&gt; {
    console.log(value); <span class="comment">// 3</span>
});
console.log(<span class="string"><span class="delimiter">&quot;</span><span class="content">outer promise</span><span class="delimiter">&quot;</span></span>); <span class="comment">// 2</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>上記のコードを実行すると以下の順に呼ばれていることが分かります。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>inner promise // 1
outer promise // 2
42            // 3</pre>
</div>
</div>
<div class="paragraph">
<p>JavaScriptは上から実行されていくため、まず最初に <code>&lt;1&gt;</code> が実行されますね。
そして次に <code>resolve(42);</code> が実行され、この <code>promise</code> オブジェクトはこの時点で <code>42</code> という値にFulfilledされます。</p>
</div>
<div class="paragraph">
<p>次に、<code>promise.then</code> で <code>&lt;3&gt;</code> のコールバック関数を登録しますが、ここがこのコラムの焦点です。</p>
</div>
<div class="paragraph">
<p><code>promise.then</code> を行う時点でpromiseオブジェクトの状態が決まっているため、
プログラム的には同期的にコールバック関数に <code>42</code> を渡して呼び出すことはできますね。</p>
</div>
<div class="paragraph">
<p>しかし、Promiseでは <code>promise.then</code> で登録する段階でpromiseの状態が決まっていても、
そこで登録したコールバック関数は非同期で呼び出される仕様になっています。</p>
</div>
<div class="paragraph">
<p>そのため、<code>&lt;2&gt;</code> が先に呼び出されて、最後に <code>&lt;3&gt;</code> のコールバック関数が呼ばれています。</p>
</div>
<div class="paragraph">
<p>なぜ、同期的に呼び出せるのにわざわざ非同期的に呼び出しているでしょうか?</p>
</div>
<div class="sect3">
<h4 id="_同期と非同期の混在の問題">2.3.1. 同期と非同期の混在の問題</h4>
<div class="paragraph">
<p>これはPromise以外でも適用できるため、もう少し一般的な問題として考えてみましょう。</p>
</div>
<div class="paragraph">
<p>この問題はコールバック関数を受け取る関数が、
状況によって同期処理になるのか非同期処理になるのかが変わってしまう問題と同じです。</p>
</div>
<div class="paragraph">
<p>次のような、コールバック関数を受け取り処理する <code>onReady(fn)</code> を見てみましょう。</p>
</div>
<div id="mixed-onready.js" class="listingblock executable">
<div class="title">mixed-onready.js</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript"><span class="keyword">function</span> <span class="function">onReady</span>(fn) {
    const readyState = document.readyState;
    <span class="keyword">if</span> (readyState === <span class="string"><span class="delimiter">&quot;</span><span class="content">interactive</span><span class="delimiter">&quot;</span></span> || readyState === <span class="string"><span class="delimiter">&quot;</span><span class="content">complete</span><span class="delimiter">&quot;</span></span>) {
        fn();
    } <span class="keyword">else</span> {
        window.addEventListener(<span class="string"><span class="delimiter">&quot;</span><span class="content">DOMContentLoaded</span><span class="delimiter">&quot;</span></span>, fn);
    }
}
onReady(() =&gt; {
    console.log(<span class="string"><span class="delimiter">&quot;</span><span class="content">DOM fully loaded and parsed</span><span class="delimiter">&quot;</span></span>);
});
console.log(<span class="string"><span class="delimiter">&quot;</span><span class="content">==Starting==</span><span class="delimiter">&quot;</span></span>);</code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="#mixed-onready.js">mixed-onready.js</a>ではDOMが読み込み済みかどうかで、
コールバック関数が同期的か非同期的に呼び出されるのかが異なっています。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">onReadyを呼ぶ前にDOMの読み込みが完了している</dt>
<dd>
<p>同期的にコールバック関数が呼ばれる</p>
</dd>
<dt class="hdlist1">onReadyを呼ぶ前にDOMの読み込みが完了していない</dt>
<dd>
<p><code>DOMContentLoaded</code> のイベントハンドラとしてコールバック関数を設定する</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>そのため、このコードは配置する場所によって、
コンソールに出てくるメッセージの順番が変わってしまいます。</p>
</div>
<div class="paragraph">
<p>この問題の対処法は、常に非同期で呼び出すように統一することです。</p>
</div>
<div id="async-onready.js" class="listingblock executable">
<div class="title">async-onready.js</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript"><span class="keyword">function</span> <span class="function">onReady</span>(fn) {
    const readyState = document.readyState;
    <span class="keyword">if</span> (readyState === <span class="string"><span class="delimiter">&quot;</span><span class="content">interactive</span><span class="delimiter">&quot;</span></span> || readyState === <span class="string"><span class="delimiter">&quot;</span><span class="content">complete</span><span class="delimiter">&quot;</span></span>) {
        setTimeout(fn, <span class="integer">0</span>);
    } <span class="keyword">else</span> {
        window.addEventListener(<span class="string"><span class="delimiter">&quot;</span><span class="content">DOMContentLoaded</span><span class="delimiter">&quot;</span></span>, fn);
    }
}
onReady(() =&gt; {
    console.log(<span class="string"><span class="delimiter">&quot;</span><span class="content">DOM fully loaded and parsed</span><span class="delimiter">&quot;</span></span>);
});
console.log(<span class="string"><span class="delimiter">&quot;</span><span class="content">==Starting==</span><span class="delimiter">&quot;</span></span>);</code></pre>
</div>
</div>
<div class="paragraph">
<p>この問題については、 <a href="http://effectivejs.com/">Effective JavaScript</a> の
<strong>項目67 非同期コールバックを同期的に呼び出してはいけない</strong> で紹介されています。</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="ulist">
<ul>
<li>
<p>非同期コールバックは（たとえデータが即座に利用できても）決して同期的に使ってはならない。</p>
</li>
<li>
<p>非同期コールバックを同期的に呼び出すと、処理の期待されたシーケンスが乱され、
コードの実行順序に予期しない変動が生じるかもしれない。</p>
</li>
<li>
<p>非同期コールバックを同期的に呼び出すと、スタックオーバーフローや例外処理の間違いが発生するかもしれない。</p>
</li>
<li>
<p>非同期コールバックを次回に実行されるようスケジューリングするには、<code>setTimeout</code> のような非同期APIを使う。</p>
</li>
</ul>
</div>
</blockquote>
<div class="attribution">
&#8212; David Herman<br>
<cite>Effective JavaScript</cite>
</div>
</div>
<div class="paragraph">
<p>先ほどの <code>promise.then</code> も同様のケースであり、この同期と非同期処理の混在の問題が起きないようにするため、
<strong>Promiseは常に非同期</strong> で処理されるということが仕様で定められているわけです。</p>
</div>
<div class="paragraph">
<p>最後に、この <code>onReady</code> をPromiseを使って定義すると以下のようになります。</p>
</div>
<div id="onready-as-promise.js" class="listingblock executable">
<div class="title">onready-as-promise.js</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript"><span class="keyword">function</span> <span class="function">onReadyPromise</span>() {
    <span class="keyword">return</span> <span class="keyword">new</span> Promise((resolve) =&gt; {
        const readyState = document.readyState;
        <span class="keyword">if</span> (readyState === <span class="string"><span class="delimiter">&quot;</span><span class="content">interactive</span><span class="delimiter">&quot;</span></span> || readyState === <span class="string"><span class="delimiter">&quot;</span><span class="content">complete</span><span class="delimiter">&quot;</span></span>) {
            resolve();
        } <span class="keyword">else</span> {
            window.addEventListener(<span class="string"><span class="delimiter">&quot;</span><span class="content">DOMContentLoaded</span><span class="delimiter">&quot;</span></span>, resolve);
        }
    });
}
onReadyPromise().then(() =&gt; {
    console.log(<span class="string"><span class="delimiter">&quot;</span><span class="content">DOM fully loaded and parsed</span><span class="delimiter">&quot;</span></span>);
});
console.log(<span class="string"><span class="delimiter">&quot;</span><span class="content">==Starting==</span><span class="delimiter">&quot;</span></span>);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Promiseは常に非同期で実行されることが保証されているため、
<code>setTimeout</code> のような明示的に非同期処理にするためのコードが不要となることが分かります。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="ch2-promise.then">2.4. Promise#then</h3>
<div class="paragraph">
<p>先ほどの章でPromiseの基本となるインスタンスメソッドである <code>then</code> と <code>catch</code> の使い方を説明しました。</p>
</div>
<div class="paragraph">
<p>その中で <code>.then().catch()</code> とメソッドチェーンで繋げて書いていたことからも分かるように、
Promiseではいくらでもメソッドチェーンを繋げて処理を書いていくことができます。</p>
</div>
<div class="listingblock">
<div class="title">promiseはメソッドチェーンで繋げて書ける</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript">aPromise.then((value) =&gt; {
<span class="comment">// task A</span>
}).then((value) =&gt; {
<span class="comment">// task B</span>
}).<span class="keyword">catch</span>((error) =&gt; {
    console.error(error);
});</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>then</code> で登録するコールバック関数をそれぞれtaskというものにした時に、
taskA &#8594; task B という流れをPromiseのメソッドチェーンを使って書くことができます。</p>
</div>
<div class="paragraph">
<p>Promiseのメソッドチェーンだと長いので、今後は<a href="#promise-chain">promise chain</a>と呼びます。
このpromise chainがPromiseが非同期処理の流れを書きやすい理由の一つといえるかもしれません。</p>
</div>
<div class="paragraph">
<p>このセクションでは、<code>then</code> を使ったpromise chainの挙動と流れについて学んでいきましょう。</p>
</div>
<div class="sect3">
<h4 id="_promise_chain">2.4.1. promise chain</h4>
<div class="paragraph">
<p>第一章の例だと、<a href="#promise-chain">promise chain</a>は
then &#8594; catch というシンプルな例でしたが、このpromise chainをもっとつなげた場合に、
それぞれのpromiseオブジェクトに登録された onFulfilledとonRejectedがどのように呼ばれるかを見ていきましょう。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
promise chain - すなわちメソッドチェーンが短いことはよいことです。
この例では説明のために長いメソッドチェーンを用います。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>次のようなpromise chainを見てみましょう。</p>
</div>
<div id="promise-then-catch-flow.js" class="listingblock executable">
<div class="title">promise-then-catch-flow.js</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript"><span class="keyword">function</span> <span class="function">taskA</span>() {
    console.log(<span class="string"><span class="delimiter">&quot;</span><span class="content">Task A</span><span class="delimiter">&quot;</span></span>);
}
<span class="keyword">function</span> <span class="function">taskB</span>() {
    console.log(<span class="string"><span class="delimiter">&quot;</span><span class="content">Task B</span><span class="delimiter">&quot;</span></span>);
}
<span class="keyword">function</span> <span class="function">onRejected</span>(error) {
    console.log(<span class="string"><span class="delimiter">&quot;</span><span class="content">Catch Error: A or B</span><span class="delimiter">&quot;</span></span>, error);
}
<span class="keyword">function</span> <span class="function">finalTask</span>() {
    console.log(<span class="string"><span class="delimiter">&quot;</span><span class="content">Final Task</span><span class="delimiter">&quot;</span></span>);
}

const promise = Promise.resolve();
promise
    .then(taskA)
    .then(taskB)
    .<span class="keyword">catch</span>(onRejected)
    .then(finalTask);</code></pre>
</div>
</div>
<div class="paragraph">
<p>このようなpromise chainをつなげた場合、
それぞれの処理の流れは以下のように図で表せます。</p>
</div>
<div id="promise-then-catch-flow.png" class="imageblock">
<div class="content">
<img src="Ch2_HowToWrite/img/promise-then-catch-flow.png" alt="promise-then-catch-flow">
</div>
<div class="title">Figure 3. promise-then-catch-flow.jsの図</div>
</div>
<div class="paragraph">
<p><a href="#promise-then-catch-flow.js">上記のコード</a>では <code>then</code> は第二引数(onRejected)を使っていないため、
以下のように読み替えても問題ありません。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>then</code></dt>
<dd>
<p>onFulfilledの処理を登録</p>
</dd>
<dt class="hdlist1"><code>catch</code></dt>
<dd>
<p>onRejectedの処理を登録</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p><a href="#promise-then-catch-flow.png">図</a>の方に注目してもらうと、
<em>Task A</em> と <em>Task B</em> それぞれから <em>onRejected</em> への線が出ていることが分かります。</p>
</div>
<div class="paragraph">
<p>これは、<em>Task A</em> または <em>Task B</em> の処理にて、次のような場合に <em>onRejected</em> が呼ばれるということを示しています。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>例外が発生した時</p>
</li>
<li>
<p>Rejectedなpromiseオブジェクトがreturnされた時</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><a href="#how-to-write-promise">第一章</a>でPromiseの処理は常に <code>try-catch</code> されているようなものなので、
例外が起きた場合もキャッチして、<code>catch</code> で登録された <code>onRejected</code> の処理を呼ぶことは学びましたね。</p>
</div>
<div class="paragraph">
<p>もう一つの <em>Rejectedなpromiseオブジェクトがreturnされた時</em> については、
<code>throw</code> を使わずにpromise chain中に <code>onRejected</code> を呼ぶ方法です。</p>
</div>
<div class="paragraph">
<p>これについては、ここでは必要ない内容なので詳しくは、 第4章の <a href="#not-throw-use-reject">throwしないで、rejectしよう</a> にて解説しています。</p>
</div>
<div class="paragraph">
<p>また、<em>onRejected</em> と <em>Final Task</em> には <code>catch</code> のpromise chainがこれより後ろにありません。
つまり、この処理中に例外が起きた場合はキャッチすることができないことに気をつけましょう。</p>
</div>
<div class="paragraph">
<p>もう少し具体的に、<em>Task A</em> &#8594; <em>onRejected</em> となる例を見てみます。</p>
</div>
<div class="sect4">
<h5 id="_task_aで例外が発生したケース">Task Aで例外が発生したケース</h5>
<div class="paragraph">
<p><em>Task A</em> の処理中に例外が発生した場合、
TaskA &#8594; onRejected &#8594; FinalTask という流れで処理が行われます。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="Ch2_HowToWrite/img/promise-taska-rejected-flow.png" alt="promise taska rejected flow">
</div>
<div class="title">Figure 4. Task Aで例外が発生した時の図</div>
</div>
<div class="paragraph">
<p>コードにしてみると以下のようになります。</p>
</div>
<div id="promise-then-taska-throw.js" class="listingblock executable">
<div class="title">promise-then-taska-throw.js</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript"><span class="keyword">function</span> <span class="function">taskA</span>() {
    console.log(<span class="string"><span class="delimiter">&quot;</span><span class="content">Task A</span><span class="delimiter">&quot;</span></span>);
    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string"><span class="delimiter">&quot;</span><span class="content">throw Error @ Task A</span><span class="delimiter">&quot;</span></span>);
}
<span class="keyword">function</span> <span class="function">taskB</span>() {
    console.log(<span class="string"><span class="delimiter">&quot;</span><span class="content">Task B</span><span class="delimiter">&quot;</span></span>);<span class="comment">// 呼ばれない</span>
}
<span class="keyword">function</span> <span class="function">onRejected</span>(error) {
    console.error(error);<span class="comment">// =&gt; &quot;throw Error @ Task A&quot;</span>
}
<span class="keyword">function</span> <span class="function">finalTask</span>() {
    console.log(<span class="string"><span class="delimiter">&quot;</span><span class="content">Final Task</span><span class="delimiter">&quot;</span></span>);
}

const promise = Promise.resolve();
promise
    .then(taskA)
    .then(taskB)
    .<span class="keyword">catch</span>(onRejected)
    .then(finalTask);</code></pre>
</div>
</div>
<div class="paragraph">
<p>実行してみると、<em>Task B</em> が呼ばれていないことが分かるでしょう。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>例では説明のためにtaskAで <code>throw</code> して例外を発生させています。
しかし、実際に明示的にonRejectedを呼びたい場合は、Rejectedなpromiseオブジェクトを返すべきでしょう。
それぞれの違いについては <a href="#not-throw-use-reject">throwしないで、rejectしよう</a> で解説しています。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_promise_chainでの値渡し">2.4.2. promise chainでの値渡し</h4>
<div class="paragraph">
<p>先ほどの例ではそれぞれのTaskが独立していて、ただ呼ばれているだけでした。</p>
</div>
<div class="paragraph">
<p>このときに、Task AがTask Bへ値を渡したい時はどうすればよいでしょうか?</p>
</div>
<div class="paragraph">
<p>答えはものすごく単純でTask Aの処理で <code>return</code> した値がTask Bが呼ばれるときに引数に設定されます。</p>
</div>
<div class="paragraph">
<p>実際に例を見てみましょう。</p>
</div>
<div id="promise-then-passing-value.js" class="listingblock executable">
<div class="title">promise-then-passing-value.js</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript"><span class="keyword">function</span> <span class="function">doubleUp</span>(value) {
    <span class="keyword">return</span> value * <span class="integer">2</span>;
}
<span class="keyword">function</span> <span class="function">increment</span>(value) {
    <span class="keyword">return</span> value + <span class="integer">1</span>;
}
<span class="keyword">function</span> <span class="function">output</span>(value) {
    console.log(value);<span class="comment">// =&gt; (1 + 1) * 2</span>
}

const promise = Promise.resolve(<span class="integer">1</span>);
promise
    .then(increment)
    .then(doubleUp)
    .then(output)
    .<span class="keyword">catch</span>((error) =&gt; {
        <span class="comment">// promise chain中にエラーが発生した場合に呼ばれる</span>
        console.error(error);
    });</code></pre>
</div>
</div>
<div class="paragraph">
<p>スタートは <code>Promise.resolve(1);</code> で、この処理は以下のような流れでpromise chainが処理されていきます。</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>Promise.resolve(1);</code> から 1 が <code>increment</code> に渡される</p>
</li>
<li>
<p><code>increment</code> では渡された値に+1した値を <code>return</code> している</p>
</li>
<li>
<p>この値(2)が次の <code>doubleUp</code> に渡される</p>
</li>
<li>
<p>最後に <code>output</code> が出力する</p>
</li>
</ol>
</div>
<div class="imageblock">
<div class="content">
<img src="Ch2_HowToWrite/img/promise-then-passing-value.png" alt="promise-then-passing-value">
</div>
<div class="title">Figure 5. promise-then-passing-value.jsの図</div>
</div>
<div class="paragraph">
<p>この <code>return</code> する値は数字や文字列だけではなく、
オブジェクトやpromiseオブジェクトも <code>return</code> することができます。</p>
</div>
<div class="paragraph">
<p>returnした値は <code>Promise.resolve(returnされた値);</code> のように処理されるため、
何をreturnしても最終的には新しいpromiseオブジェクトを返します。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
これについて詳しくは <a href="#then-return-new-promise">thenは常に新しいpromiseオブジェクトを返す</a> にて、
よくある間違いと共に紹介しています。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>つまり、 <code>Promise#then</code> は単にコールバックとなる関数を登録するだけではなく、
受け取った値を変化させて別のpromiseオブジェクトを生成する という機能も持っていることを覚えておくといいでしょう。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="ch2-promise-catch">2.5. Promise#catch</h3>
<div class="paragraph">
<p><a href="#ch2-promise.then">先ほどのPromise#then</a>についてでも <code>Promise#catch</code> はすでに使っていましたね。</p>
</div>
<div class="paragraph">
<p>改めて説明すると<a href="#promise.catch">Promise#catch</a>は <code>promise.then(undefined, onRejected);</code> のエイリアスとなるメソッドです。
つまり、promiseオブジェクトがRejectedとなった時に呼ばれる関数を登録するためのメソッドです。</p>
</div>
<div class="paragraph">
<p>次のコードのように <code>Promise#catch</code> は <code>Promise#then</code> でのエラーハンドリングだけを簡潔に書くためのメソッドです。</p>
</div>
<div class="listingblock">
<div class="title">Promise#catchとPromise#then</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript">Promise.reject(<span class="keyword">new</span> Error(<span class="string"><span class="delimiter">&quot;</span><span class="content">message</span><span class="delimiter">&quot;</span></span>)).<span class="keyword">catch</span>((error) =&gt; {
    <span class="comment">// エラーハンドリング</span>
});
<span class="comment">// Promise#catchは次のPromise#thenと同じ意味</span>
Promise.reject(<span class="keyword">new</span> Error(<span class="string"><span class="delimiter">&quot;</span><span class="content">message</span><span class="delimiter">&quot;</span></span>)).then(<span class="predefined-constant">undefined</span>, (error) =&gt; {
    <span class="comment">// エラーハンドリング</span>
});</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<a href="#promise.then">Promise#then</a>と<a href="#promise.catch">Promise#catch</a>の使い分けについては、
<a href="#then-or-catch">then or catch?</a>で紹介しています。
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_ie8以下での問題">2.5.1. IE8以下での問題</h4>
<div class="paragraph">
<p><span class="image"><a class="image" href="https://ci.testling.com/azu/promise-catch-error"><img src="Ch2_HowToWrite/img/promise-catch-error.png" alt="Build Status"></a></span></p>
</div>
<div class="paragraph">
<p>このバッジは以下のコードが、 <a href="https://github.com/jakearchibald/es6-promise">polyfill</a> を用いた状態でそれぞれのブラウザで正しく実行できているかを示したものです。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>polyfillとはその機能が実装されていないブラウザでも、その機能が使えるようにするライブラリのことです。
この例では <a href="https://github.com/jakearchibald/es6-promise">jakearchibald/es6-promise</a> を利用しています。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="listingblock executable">
<div class="title">Promise#catchの実行結果</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript">const promise = Promise.reject(<span class="keyword">new</span> Error(<span class="string"><span class="delimiter">&quot;</span><span class="content">message</span><span class="delimiter">&quot;</span></span>));
promise.<span class="keyword">catch</span>((error) =&gt; {
    console.error(error);
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>このコードをそれぞれのブラウザで実行させると、IE8以下では実行する段階で <strong>識別子がありません</strong> というSyntax Errorになってしまいます。</p>
</div>
<div class="paragraph">
<p>これはどういうことかというと、<code>catch</code> という単語はECMAScriptにおける <a href="http://mothereff.in/js-properties#catch">予約語</a> であることが関係します。</p>
</div>
<div class="paragraph">
<p>ECMAScript 3では予約語はプロパティの名前に使うことができませんでした。
IE8以下はECMAScript 3の実装であるため、<code>catch</code> というプロパティを使う <code>promise.catch()</code> という書き方が出来ないので、
<strong>識別子がありません</strong>というエラーを起こしてしまう訳です。</p>
</div>
<div class="paragraph">
<p>一方、現在のブラウザが実装済みであるECMAScript 5以降では、
予約語を <a href="http://es5.github.io/#x7.6">IdentifierName</a> 、つまりプロパティ名に利用することが可能となっています。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>ECMAScript 5でも予約語は <a href="http://es5.github.io/#x7.6">Identifier</a> 、つまり変数名、関数名には利用することができません。
<code>for</code> という変数が定義できてしまうと <code>for</code> 文との区別ができなくなってしまいます。
プロパティの場合は <code>object.for</code> と <code>for</code> 文の区別はできるので、少し考えてみると自然な動作ですね。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>このECMAScript 3の予約語の問題を回避する書き方も存在します。</p>
</div>
<div class="paragraph">
<p><a href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Operators/Property_Accessors#Dot_notation">ドット表記法</a>
はプロパティ名が有効な識別子(ECMAScript 3の場合は予約語が使えない)でないといけませんが、
<a href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Operators/Property_Accessors#Bracket_notation">ブラケット表記法</a>
は有効な識別子ではなくても利用できます。</p>
</div>
<div class="paragraph">
<p>つまり、先ほどのコードは以下のように書き換えれば、IE8以下でも実行することができます。(もちろんpolyfillは必要です)</p>
</div>
<div class="listingblock executable">
<div class="title">Promise#catchの識別子エラーの回避</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript">const promise = Promise.reject(<span class="keyword">new</span> Error(<span class="string"><span class="delimiter">&quot;</span><span class="content">message</span><span class="delimiter">&quot;</span></span>));
promise[<span class="string"><span class="delimiter">&quot;</span><span class="content">catch</span><span class="delimiter">&quot;</span></span>]((error) =&gt; {
    console.error(error);
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>もしくは単純に <code>catch</code> を使わずに、<code>then</code> を使うことでも回避できます。</p>
</div>
<div class="listingblock executable">
<div class="title">Promise#catchではなくPromise#thenを使う</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript">const promise = Promise.reject(<span class="keyword">new</span> Error(<span class="string"><span class="delimiter">&quot;</span><span class="content">message</span><span class="delimiter">&quot;</span></span>));
promise.then(<span class="predefined-constant">undefined</span>, (error) =&gt; {
    console.error(error);
});</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>catch</code> という識別子が問題となっているため、ライブラリによっては <code>caught</code> 等の名前が違うだけのメソッドを用意しているケースがあります。</p>
</div>
<div class="paragraph">
<p>また多くの圧縮ツールは <code>promise.catch</code> を <code>promise["catch"]</code> へと置換する処理が組み込まれているため、知らない間に回避できていることも多いかも知れません。</p>
</div>
<div class="paragraph">
<p>サポートブラウザにIE8以下を含める時は、この <code>catch</code> の問題に気をつけるといいでしょう。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="ch2-promise-finally">2.6. Promise#finally</h3>
<div class="paragraph">
<p>ECMAScript 2018からpromise chainの最後に処理を実行する <code>Promise#finally</code> メソッド追加されました。</p>
</div>
<div class="paragraph">
<p><code>Promise#finally</code> メソッドは成功時、失敗時どちらの場合でも呼び出すコールバック関数を登録できます。
<code>try&#8230;&#8203;catch&#8230;&#8203;finally</code> 構文の <code>finally</code> 節と同様の役割をもつメソッドです。</p>
</div>
<div class="paragraph">
<p>次のコードのように、 <code>Promise#finally</code> メソッドで登録したコールバック関数は、promiseオブジェクトが <strong>resolve</strong>(成功) / <strong>reject</strong>(失敗) どちらの場合でも呼ばれます。</p>
</div>
<div class="listingblock executable">
<div class="title">finallyのコード例</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript">Promise.resolve(<span class="string"><span class="delimiter">&quot;</span><span class="content">成功</span><span class="delimiter">&quot;</span></span>).<span class="keyword">finally</span>(() =&gt; {
    console.log(<span class="string"><span class="delimiter">&quot;</span><span class="content">成功時に実行される</span><span class="delimiter">&quot;</span></span>);
});
Promise.reject(<span class="keyword">new</span> Error(<span class="string"><span class="delimiter">&quot;</span><span class="content">失敗</span><span class="delimiter">&quot;</span></span>)).<span class="keyword">finally</span>(() =&gt; {
    console.log(<span class="string"><span class="delimiter">&quot;</span><span class="content">失敗時に実行される</span><span class="delimiter">&quot;</span></span>);
});</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>finally</code> メソッドのコールバック関数は引数を受け取らず、どのような値を返してもpromise chainには影響を与えません。
また、 <code>finally</code> メソッドは新しいpromiseオブジェクトを返し、新しいpromiseオブジェクトは呼び出し元のpromiseオブジェクトの状態をそのまま引き継ぎます。</p>
</div>
<div class="listingblock executable">
<div class="title">finallyとpromise chain</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript"><span class="keyword">function</span> <span class="function">onFinally</span>() {
    <span class="comment">// 成功、失敗どちらでも実行したい処理</span>
}

<span class="comment">// `Promise#finally` は新しいpromiseオブジェクトを返す</span>
Promise.resolve(<span class="integer">42</span>)
    .<span class="keyword">finally</span>(onFinally)
    .then((value) =&gt; {
        <span class="comment">// 呼び出し元のpromiseオブジェクトの状態をそのまま引き継ぐ</span>
        <span class="comment">// 呼び出し元のpromiseオブジェクトは `42` で resolveされている</span>
        console.log(value); <span class="comment">// 42</span>
    });</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>Promise#finally</code> メソッドと同等の表現を <code>Promise#then</code> メソッドで書くと次のように書けます。</p>
</div>
<div class="listingblock">
<div class="title">finallyをthenで表現</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript"><span class="keyword">function</span> <span class="function">onFinally</span>() {
    <span class="comment">// 成功、失敗どちらでも実行したい処理</span>
}

<span class="comment">// Promise#finally(onFinally) と同等の表現</span>
promise.then((result) =&gt; {
    onFinally();
    <span class="keyword">return</span> result;
}, (error) =&gt; {
    onFinally();
    <span class="keyword">return</span> Promise.reject(error);
});</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>Promise#finally</code> メソッドを使うことで、promise chainで必ず実行したい処理を簡単に書けるようになっています。</p>
</div>
<div class="paragraph">
<p>次のコードでは、リソースを取得中かどうかを判定するためのフラグを <code>isLoading</code> という変数で管理しています。
<code>Promise#finally</code> メソッドを使い成功失敗どちらにもかかわらず、取得が終わったら <code>isLoading</code> は <code>false</code> にしています。</p>
</div>
<div class="listingblock executable">
<div class="title">finallyのユースケース</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript"><span class="comment">// リソースを取得中かどうかのフラグ</span>
let isLoading = <span class="predefined-constant">false</span>;
<span class="keyword">function</span> <span class="function">fetchResource</span>(URL) {
    <span class="comment">// リソース取得中フラグをONに</span>
    isLoading = <span class="predefined-constant">true</span>;
    <span class="keyword">return</span> <span class="keyword">new</span> Promise((resolve, reject) =&gt; {
        const req = <span class="keyword">new</span> XMLHttpRequest();
        req.open(<span class="string"><span class="delimiter">&quot;</span><span class="content">GET</span><span class="delimiter">&quot;</span></span>, URL, <span class="predefined-constant">true</span>);
        req.onload = () =&gt; {
            <span class="keyword">if</span> (<span class="integer">200</span> &lt;= req.status &amp;&amp; req.status &lt; <span class="integer">300</span>) {
                resolve(req.responseText);
            } <span class="keyword">else</span> {
                reject(<span class="keyword">new</span> Error(req.statusText));
            }
        };
        req.onerror = () =&gt; {
            reject(<span class="keyword">new</span> Error(req.statusText));
        };
        req.send();
    }).<span class="keyword">finally</span>(() =&gt; {
        <span class="comment">// リソース取得に成功/失敗どちらの場合も取得中フラグをOFFに</span>
        isLoading = <span class="predefined-constant">false</span>;
    });
}

console.log(<span class="string"><span class="delimiter">&quot;</span><span class="content">リソースロード開始</span><span class="delimiter">&quot;</span></span>, isLoading);
fetchResource(<span class="string"><span class="delimiter">&quot;</span><span class="content">https://httpbin.org/get</span><span class="delimiter">&quot;</span></span>).then((value) =&gt; {
    console.log(<span class="string"><span class="delimiter">&quot;</span><span class="content">リソース取得に成功</span><span class="delimiter">&quot;</span></span>, isLoading);
    console.log(value);
}).<span class="keyword">catch</span>((error) =&gt; {
    console.log(<span class="string"><span class="delimiter">&quot;</span><span class="content">リソース取得に失敗</span><span class="delimiter">&quot;</span></span>, isLoading);
    console.error(error);
});
console.log(<span class="string"><span class="delimiter">&quot;</span><span class="content">リソースロード中</span><span class="delimiter">&quot;</span></span>, isLoading);</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>then</code> と <code>catch</code> メソッドでも実現できますが、 <code>Promise#finally</code> メソッドを使うことで <code>isLoading</code> の代入を一箇所にまとめられます。</p>
</div>
</div>
<div class="sect2">
<h3 id="then-return-new-promise">2.7. コラム: thenは常に新しいpromiseオブジェクトを返す</h3>
<div class="paragraph">
<p><code>aPromise.then(&#8230;&#8203;).catch(&#8230;&#8203;)</code> は一見すると、全て最初の <code>aPromise</code> オブジェクトに
メソッドチェーンで処理を書いてるように見えます。</p>
</div>
<div class="paragraph">
<p>しかし、実際には <code>then</code> で新しいpromiseオブジェクト、<code>catch</code> でも別の新しいpromiseオブジェクトを作成して返しています。</p>
</div>
<div class="paragraph">
<p>本当に新しいpromiseオブジェクトを返しているのか確認してみましょう。</p>
</div>
<div class="listingblock executable">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript">const aPromise = <span class="keyword">new</span> Promise((resolve) =&gt; {
    resolve(<span class="integer">100</span>);
});
const thenPromise = aPromise.then((value) =&gt; {
    console.log(value);
});
const catchPromise = thenPromise.<span class="keyword">catch</span>((error) =&gt; {
    console.error(error);
});
console.log(aPromise !== thenPromise); <span class="comment">// =&gt; true</span>
console.log(thenPromise !== catchPromise);<span class="comment">// =&gt; true</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>===</code> 厳密比較演算子によって比較するとそれぞれが別々のオブジェクトなので、
本当に <code>then</code> や <code>catch</code> は別のpromiseオブジェクトを返していることが分かりました。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="Ch2_HowToWrite/img/then_catch.png" alt="Then Catch flow">
</div>
</div>
<div class="paragraph">
<p>この仕組みはPromiseを拡張する時は意識しないと、いつのまにか触ってるpromiseオブジェクトが
別のものであったということが起こりえると思います。</p>
</div>
<div class="paragraph">
<p>また、<code>then</code> は新しいオブジェクトを作って返すということがわかっていれば、
次の <code>then</code> の使い方では意味が異なることに気づくでしょう。</p>
</div>
<div class="listingblock executable">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript"><span class="comment">// 1: それぞれの `then` は同時に呼び出される</span>
const aPromise = <span class="keyword">new</span> Promise((resolve) =&gt; {
    resolve(<span class="integer">100</span>);
});
aPromise.then((value) =&gt; {
    <span class="keyword">return</span> value * <span class="integer">2</span>;
});
aPromise.then((value) =&gt; {
    <span class="keyword">return</span> value * <span class="integer">2</span>;
});
aPromise.then((value) =&gt; {
    console.log(<span class="string"><span class="delimiter">&quot;</span><span class="content">1: </span><span class="delimiter">&quot;</span></span> + value); <span class="comment">// =&gt; 100</span>
});

<span class="comment">// vs</span>

<span class="comment">// 2: `then` はpromise chain通り順番に呼び出される</span>
const bPromise = <span class="keyword">new</span> Promise((resolve) =&gt; {
    resolve(<span class="integer">100</span>);
});
bPromise.then((value) =&gt; {
    <span class="keyword">return</span> value * <span class="integer">2</span>;
}).then((value) =&gt; {
    <span class="keyword">return</span> value * <span class="integer">2</span>;
}).then((value) =&gt; {
    console.log(<span class="string"><span class="delimiter">&quot;</span><span class="content">2: </span><span class="delimiter">&quot;</span></span> + value); <span class="comment">// =&gt; 100 * 2 * 2</span>
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>1のpromiseをメソッドチェーン的に繋げない書き方はあまりすべきではありませんが、
このような書き方をした場合、それぞれの <code>then</code> はほぼ同時に呼ばれ、また <code>value</code> に渡る値も全て同じ <code>100</code> となります。</p>
</div>
<div class="paragraph">
<p>2はメソッドチェーン的につなげて書くことにより、resolve &#8594; then &#8594; then &#8594; then と書いた順番にキチンと実行され、
それぞれの <code>value</code> に渡る値は、一つ前のpromiseオブジェクトで <code>return</code> された値が渡ってくるようになります。</p>
</div>
<div class="paragraph">
<p>1の書き方により発生するアンチパターンとしては以下のようなものが有名です。</p>
</div>
<div class="listingblock">
<div class="title">✘ <code>then</code> の間違った使い方</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript"><span class="keyword">function</span> <span class="function">badAsyncCall</span>() {
    const promise = Promise.resolve();
    promise.then(() =&gt; {
        <span class="comment">// 何かの処理</span>
        <span class="keyword">return</span> newVar;
    });
    <span class="keyword">return</span> promise;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>このように書いてしまうと、<code>promise.then</code> の中で例外が発生するとその例外を取得する方法がなくなり、
また、何かの値を返していてもそれを受け取る方法が無くなってしまいます。</p>
</div>
<div class="paragraph">
<p>これは <code>promise.then</code> によって新たに作られたpromiseオブジェクトを返すようにすることで、
2のようにpromise chainをつなげるようにするべきなので、次のように修正することができます。</p>
</div>
<div class="listingblock">
<div class="title"><code>then</code> で作成したオブジェクトを返す</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript"><span class="keyword">function</span> <span class="function">anAsyncCall</span>() {
    const promise = Promise.resolve();
    <span class="keyword">return</span> promise.then(() =&gt; {
        <span class="comment">// 何かの処理</span>
        <span class="keyword">return</span> newVar;
    });
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>これらのアンチパターンについて、詳しくは
<a href="https://web.archive.org/web/20211219034053/http://taoofcode.net/promise-anti-patterns/">Promise Anti-patterns</a> を参照して下さい。</p>
</div>
<div class="paragraph">
<p>この挙動はPromise全般に当てはまるため、後に説明する<a href="#ch2-promise-all">Promise.all</a>や<a href="#ch2-promise-race">Promise.race</a>も
引数で受け取ったものとは別のpromiseオブジェクトを作って返しています。</p>
</div>
</div>
<div class="sect2">
<h3 id="ch2-promise-and-array">2.8. Promiseと配列</h3>
<div class="paragraph">
<p>ここまでで、promiseオブジェクトが Fulfilled または Rejected となった時の処理は <a href="#promise.then"><code>.then</code></a> と <a href="#promise.catch"><code>.catch</code></a> で登録でき、 <a href="#promise.finally"><code>.finally</code></a> を使うことで Fulfilled と Rejected どちらの場合でも実行される処理を登録できることを学びました。</p>
</div>
<div class="paragraph">
<p>一つのpromiseオブジェクトなら、そのpromiseオブジェクトに対して処理を書けばよいですが、
複数のpromiseオブジェクトが全てFulfilledとなった時の処理を書く場合はどうすればよいでしょうか?</p>
</div>
<div class="paragraph">
<p>たとえば、複数のXHR(非同期処理)が全て終わった後に、何かをしたいという事例を考えてみます。</p>
</div>
<div class="paragraph">
<p>少しイメージしにくいので、
まずは、通常のコールバックスタイルを使って複数のXHRを行う以下のようなコードを見てみます。</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="title">CORSについて</div>
<div class="paragraph">
<p>ブラウザにおけるXHRのリソース取得には、CORS(<a href="https://developer.mozilla.org/ja/docs/Web/HTTP/HTTP_access_control">Cross-Origin Resource Sharing</a>)というセキュリティ上の制約が存在します。</p>
</div>
<div class="paragraph">
<p>このCORSの制約により、ブラウザでは同一ドメインではないリソースを許可なく取得することはできません。そのため、一般的には別サイトのリソースは許可なくXHRでアクセスすることができません。</p>
</div>
<div class="paragraph">
<p>次のサンプルでは <code><a href="https://azu.github.io/promises-book/json/comment.json" class="bare">https://azu.github.io/promises-book/json/comment.json</a></code> という <code>azu.github.io</code> ドメイン以下にあるリソースを取得する例が登場します。</p>
</div>
<div class="paragraph">
<p><code>azu.github.io</code> ドメイン以下のJSONには、別ドメインからの取得が許可する設定がされています。</p>
</div>
<div class="paragraph">
<p>また、 <a href="https://httpbin.org/">httpbin.org</a> というドメインがリソース取得の例として登場します。
こちらも、同一ドメインでなくてもリソースの取得が許可されています。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_コールバックで複数の非同期処理">2.8.1. コールバックで複数の非同期処理</h4>
<div id="multiple-xhr-callback.js" class="listingblock executable">
<div class="title">multiple-xhr-callback.js</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript"><span class="keyword">function</span> <span class="function">fetchURLCallback</span>(URL, callback) {
    const req = <span class="keyword">new</span> XMLHttpRequest();
    req.open(<span class="string"><span class="delimiter">&quot;</span><span class="content">GET</span><span class="delimiter">&quot;</span></span>, URL, <span class="predefined-constant">true</span>);
    req.onload = () =&gt; {
        <span class="keyword">if</span> (<span class="integer">200</span> &lt;= req.status &amp;&amp; req.status &lt; <span class="integer">300</span>) {
            callback(<span class="predefined-constant">null</span>, req.responseText);
        } <span class="keyword">else</span> {
            callback(<span class="keyword">new</span> Error(req.statusText), req.response);
        }
    };
    req.onerror = () =&gt; {
        callback(<span class="keyword">new</span> Error(req.statusText));
    };
    req.send();
}
<span class="comment">// &lt;1&gt; JSONパースを安全に行う</span>
<span class="keyword">function</span> <span class="function">jsonParse</span>(callback, error, value) {
    <span class="keyword">if</span> (error) {
        callback(error, value);
    } <span class="keyword">else</span> {
        <span class="keyword">try</span> {
            const result = JSON.parse(value);
            callback(<span class="predefined-constant">null</span>, result);
        } <span class="keyword">catch</span> (e) {
            callback(e, value);
        }
    }
}
<span class="comment">// &lt;2&gt; XHRを叩いてリクエスト</span>
const request = {
    comment(callback) {
        <span class="keyword">return</span> fetchURLCallback(<span class="string"><span class="delimiter">&quot;</span><span class="content">https://azu.github.io/promises-book/json/comment.json</span><span class="delimiter">&quot;</span></span>, jsonParse.bind(<span class="predefined-constant">null</span>, callback));
    },
    people(callback) {
        <span class="keyword">return</span> fetchURLCallback(<span class="string"><span class="delimiter">&quot;</span><span class="content">https://azu.github.io/promises-book/json/people.json</span><span class="delimiter">&quot;</span></span>, jsonParse.bind(<span class="predefined-constant">null</span>, callback));
    }
};
<span class="comment">// &lt;3&gt; 複数のXHRリクエストを行い、全部終わったらcallbackを呼ぶ</span>
<span class="keyword">function</span> <span class="function">allRequest</span>(requests, callback, results) {
    <span class="keyword">if</span> (requests.length === <span class="integer">0</span>) {
        <span class="keyword">return</span> callback(<span class="predefined-constant">null</span>, results);
    }
    const req = requests.shift();
    req((error, value) =&gt; {
        <span class="keyword">if</span> (error) {
            callback(error, value);
        } <span class="keyword">else</span> {
            results.push(value);
            allRequest(requests, callback, results);
        }
    });
}

<span class="keyword">function</span> <span class="function">main</span>(callback) {
    allRequest([request.comment, request.people], callback, []);
}



<span class="comment">// 実行例</span>
main(<span class="keyword">function</span>(error, results){
    <span class="keyword">if</span>(error){
        console.error(error);
        <span class="keyword">return</span>;
    }
    console.log(results);
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>このコールバックスタイルでは幾つかの要素が出てきます。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>JSON.parse</code> をそのまま使うと例外となるケースがあるためラップした <code>jsonParse</code> 関数を使う</p>
</li>
<li>
<p>複数のXHRをそのまま書くとネストが深くなるため、<code>allRequest</code> というrequest関数を実行するものを利用する</p>
</li>
<li>
<p>コールバック関数には <code>callback(error,value)</code> のように第一引数にエラー、第二引数にレスポンスを渡す。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>jsonParse</code> 関数を使うときに <code>bind</code> を使うことで、部分適用を使って無名関数を減らすようにしています。
(コールバックスタイルでも関数の処理などをちゃんと分離すれば、無名関数の使用も減らせると思います)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript">jsonParse.bind(<span class="predefined-constant">null</span>, callback);
<span class="comment">// は以下のように置き換えるのと殆ど同じ</span>
<span class="keyword">function</span> <span class="function">bindJSONParse</span>(error, value) {
    jsonParse(callback, error, value);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>コールバックスタイルで書いたものを見ると以下のような点が気になります。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>明示的な例外のハンドリングが必要</p>
</li>
<li>
<p>ネストを深くしないために、requestを扱う関数が必要</p>
</li>
<li>
<p>コールバックがたくさんでてくる</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>次は、<code>Promise#then</code> を使って同様のことをしてみたいと思います。</p>
</div>
</div>
<div class="sect3">
<h4 id="_promise_thenのみで複数の非同期処理">2.8.2. Promise#thenのみで複数の非同期処理</h4>
<div class="paragraph">
<p>先に述べておきますが、<code>Promise.all</code> というこのような処理に適切なものがあるため、
ワザと <code>.then</code> の部分をクドく書いています。</p>
</div>
<div class="paragraph">
<p><a href="#promise.then"><code>.then</code></a> を使った場合は、コールバックスタイルと完全に同等というわけではないですが以下のように書けると思います。</p>
</div>
<div id="multiple-xhr.js" class="listingblock executable">
<div class="title">multiple-xhr.js</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript"><span class="keyword">function</span> <span class="function">fetchURL</span>(URL) {
    <span class="keyword">return</span> <span class="keyword">new</span> Promise((resolve, reject) =&gt; {
        const req = <span class="keyword">new</span> XMLHttpRequest();
        req.open(<span class="string"><span class="delimiter">&quot;</span><span class="content">GET</span><span class="delimiter">&quot;</span></span>, URL, <span class="predefined-constant">true</span>);
        req.onload = () =&gt; {
            <span class="keyword">if</span> (<span class="integer">200</span> &lt;= req.status &amp;&amp; req.status &lt; <span class="integer">300</span>) {
                resolve(req.responseText);
            } <span class="keyword">else</span> {
                reject(<span class="keyword">new</span> Error(req.statusText));
            }
        };
        req.onerror = () =&gt; {
            reject(<span class="keyword">new</span> Error(req.statusText));
        };
        req.send();
    });
}
const request = {
    comment() {
        <span class="keyword">return</span> fetchURL(<span class="string"><span class="delimiter">&quot;</span><span class="content">https://azu.github.io/promises-book/json/comment.json</span><span class="delimiter">&quot;</span></span>).then(JSON.parse);
    },
    people() {
        <span class="keyword">return</span> fetchURL(<span class="string"><span class="delimiter">&quot;</span><span class="content">https://azu.github.io/promises-book/json/people.json</span><span class="delimiter">&quot;</span></span>).then(JSON.parse);
    }
};
<span class="keyword">function</span> <span class="function">main</span>() {
    <span class="keyword">function</span> <span class="function">recordValue</span>(results, value) {
        results.push(value);
        <span class="keyword">return</span> results;
    }
    <span class="comment">// [] は記録する初期値を部分適用している</span>
    const pushValue = recordValue.bind(<span class="predefined-constant">null</span>, []);
    <span class="keyword">return</span> request.comment()
        .then(pushValue)
        .then(request.people)
        .then(pushValue);
}



<span class="comment">// 実行例</span>
main().then((value) =&gt; {
    console.log(value);
}).<span class="keyword">catch</span>((error) =&gt; {
    console.error(error);
});</code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="#multiple-xhr-callback.js">コールバックスタイル</a>と比較してみると次のことがわかります。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>JSON.parse</code> をそのまま使っている</p>
</li>
<li>
<p><code>main()</code> はpromiseオブジェクトを返している</p>
</li>
<li>
<p>エラーハンドリングは返ってきたpromiseオブジェクトに対して書いている</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>先ほども述べたように mainの <code>then</code> の部分がクドく感じます。</p>
</div>
<div class="paragraph">
<p>Promiseでは、このような複数の非同期処理をまとめて扱う <code>Promise.all</code> と <code>Promise.race</code> という静的メソッドが用意されています。</p>
</div>
<div class="paragraph">
<p>次のセクションではそれらについて学んでいきましょう。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="ch2-promise-all">2.9. Promise.all</h3>
<div class="paragraph">
<p><a href="#Promise.all"><code>Promise.all</code></a> は promiseオブジェクトの配列を受け取り、
その配列に入っているpromiseオブジェクトが全てresolveされた時に、次の <code>.then</code> を呼び出します。</p>
</div>
<div class="paragraph">
<p>先ほどの複数のXHRの結果をまとめて取得する処理は、 <a href="#Promise.all"><code>Promise.all</code></a> を使うとシンプルに書くことができます。</p>
</div>
<div class="paragraph">
<p>先ほどの例の <code>fetchURL</code> はXHRによる通信を抽象化したpromiseオブジェクトを返しています。
<code>Promise.all</code> に通信を抽象化したpromiseオブジェクトの配列を渡すことで、
全ての通信が完了(FulfilledまたはRejected)した時に、次の <code>.then</code> を呼び出すことができます。</p>
</div>
<div id="promise-all-xhr.js" class="listingblock executable">
<div class="title">promise-all-xhr.js</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript"><span class="keyword">function</span> <span class="function">fetchURL</span>(URL) {
    <span class="keyword">return</span> <span class="keyword">new</span> Promise((resolve, reject) =&gt; {
        const req = <span class="keyword">new</span> XMLHttpRequest();
        req.open(<span class="string"><span class="delimiter">&quot;</span><span class="content">GET</span><span class="delimiter">&quot;</span></span>, URL, <span class="predefined-constant">true</span>);
        req.onload = () =&gt; {
            <span class="keyword">if</span> (<span class="integer">200</span> &lt;= req.status &amp;&amp; req.status &lt; <span class="integer">300</span>) {
                resolve(req.responseText);
            } <span class="keyword">else</span> {
                reject(<span class="keyword">new</span> Error(req.statusText));
            }
        };
        req.onerror = () =&gt; {
            reject(<span class="keyword">new</span> Error(req.statusText));
        };
        req.send();
    });
}
const request = {
    comment() {
        <span class="keyword">return</span> fetchURL(<span class="string"><span class="delimiter">&quot;</span><span class="content">https://azu.github.io/promises-book/json/comment.json</span><span class="delimiter">&quot;</span></span>).then(JSON.parse);
    },
    people() {
        <span class="keyword">return</span> fetchURL(<span class="string"><span class="delimiter">&quot;</span><span class="content">https://azu.github.io/promises-book/json/people.json</span><span class="delimiter">&quot;</span></span>).then(JSON.parse);
    }
};
<span class="keyword">function</span> <span class="function">main</span>() {
    <span class="keyword">return</span> Promise.all([request.comment(), request.people()]);
}



<span class="comment">// 実行例</span>
main().then((value) =&gt; {
    console.log(value);
}).<span class="keyword">catch</span>((error) =&gt; {
    console.error(error);
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>実行方法は <a href="#xhr-promise.js">前回のもの</a> と同じですね。
<a href="#Promise.all"><code>Promise.all</code></a> を使うことで以下のような違いがあることがわかります。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>mainの処理がスッキリしている</p>
</li>
<li>
<p>Promise.all は promiseオブジェクトの配列を扱っている</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript">Promise.all([request.comment(), request.people()]);</code></pre>
</div>
</div>
<div class="paragraph">
<p>というように処理を書いた場合は、<code>request.comment()</code> と <code>request.people()</code> は同時に実行されますが、
それぞれのpromiseの結果(resolve,rejectで渡される値)は、<a href="#Promise.all"><code>Promise.all</code></a>に渡した配列の順番となります。</p>
</div>
<div class="paragraph">
<p>つまり、この場合に次の <code>.then</code> に渡される結果の配列は [comment, people]の順番になることが保証されています。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript">main().then((results) =&gt; {
    console.log(results); <span class="comment">// [comment, people]の順番</span>
});</code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="#Promise.all"><code>Promise.all</code></a> に渡したpromiseオブジェクトが同時に実行されてるのは、
次のようなタイマーを使った例を見てみると分かりやすいです。</p>
</div>
<div id="promise-all-timer.js" class="listingblock executable">
<div class="title">promise-all-timer.js</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript"><span class="comment">// `delay`ミリ秒後にresolveする</span>
<span class="keyword">function</span> <span class="function">timerPromisefy</span>(delay) {
    <span class="keyword">return</span> <span class="keyword">new</span> Promise((resolve) =&gt; {
        setTimeout(() =&gt; {
            resolve(delay);
        }, delay);
    });
}
const startDate = Date.now();
<span class="comment">// 全てがresolveされたら終了</span>
Promise.all([
    timerPromisefy(<span class="integer">1</span>),
    timerPromisefy(<span class="integer">32</span>),
    timerPromisefy(<span class="integer">64</span>),
    timerPromisefy(<span class="integer">128</span>)
]).then((values) =&gt; {
    console.log(Date.now() - startDate + <span class="string"><span class="delimiter">&quot;</span><span class="content">ms</span><span class="delimiter">&quot;</span></span>);<span class="comment">// 約128ms</span>
    console.log(values); <span class="comment">// [1,32,64,128]</span>
});</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>timerPromisefy</code> は引数で指定したミリ秒後に、その指定した値でFulfilledとなる
promiseオブジェクトを返してくれます。</p>
</div>
<div class="paragraph">
<p><code>Promise.all</code> に渡してるのは、それを複数作り配列にしたものですね。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript">const promises = [
    timerPromisefy(<span class="integer">1</span>),
    timerPromisefy(<span class="integer">32</span>),
    timerPromisefy(<span class="integer">64</span>),
    timerPromisefy(<span class="integer">128</span>)
];</code></pre>
</div>
</div>
<div class="paragraph">
<p>この場合は、1, 32, 64, 128 ミリ秒後にそれぞれ <code>resolve</code> されます。</p>
</div>
<div class="paragraph">
<p>つまり、このpromiseオブジェクトの配列がすべてresolveされるには、最低でも128msかかることがわかります。
実際に<a href="#Promise.all"><code>Promise.all</code></a> で処理してみると 約128msかかることがわかります。</p>
</div>
<div class="paragraph">
<p>このことから、<a href="#Promise.all"><code>Promise.all</code></a> が一つづつ順番にやるわけではなく、
渡されたpromiseオブジェクトの配列を並列に実行してるということがわかります。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>仮に逐次的に行われていた場合は、
1ms待機 &#8594; 32ms待機 &#8594; 64ms待機 &#8594; 128ms待機 となるので、
全て完了するまで225ms程度かかる計算になります。</p>
</div>
<div class="paragraph">
<p>実際にPromiseを逐次的に処理したいケースについては第4章の<a href="#promise-sequence">Promiseによる逐次処理</a>を参照して下さい。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="ch2-promise-race">2.10. Promise.race</h3>
<div class="paragraph">
<p><a href="#Promise.all"><code>Promise.all</code></a> と同様に複数のpromiseオブジェクトを扱う<a href="#Promise.race"><code>Promise.race</code></a>を見てみましょう。</p>
</div>
<div class="paragraph">
<p>使い方はPromise.allと同様で、promiseオブジェクトの配列を引数に渡します。</p>
</div>
<div class="paragraph">
<p><code>Promise.all</code> は、渡した全てのpromiseがFulfilled または Rejectedになるまで次の処理を待ちましたが、
<code>Promise.race</code> は、どれか一つでもpromiseがFulfilled または Rejectedになったら次の処理を実行します。</p>
</div>
<div class="paragraph">
<p>Promise.allのときと同じく、タイマーを使った <code>Promise.race</code> の例を見てみましょう。</p>
</div>
<div id="promise-race-timer.js" class="listingblock executable">
<div class="title">promise-race-timer.js</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript"><span class="comment">// `delay`ミリ秒後にresolveする</span>
<span class="keyword">function</span> <span class="function">timerPromisefy</span>(delay) {
    <span class="keyword">return</span> <span class="keyword">new</span> Promise((resolve) =&gt; {
        setTimeout(() =&gt; {
            resolve(delay);
        }, delay);
    });
}
<span class="comment">// 一つでもresolve または reject した時点で終了</span>
Promise.race([
    timerPromisefy(<span class="integer">1</span>),
    timerPromisefy(<span class="integer">32</span>),
    timerPromisefy(<span class="integer">64</span>),
    timerPromisefy(<span class="integer">128</span>)
]).then((value) =&gt; {
    console.log(value); <span class="comment">// =&gt; 1</span>
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>上記のコードだと、1ms後、32ms後、64ms後、128ms後にそれぞれpromiseオブジェクトがFulfilledとなりますが、
一番最初に1msのものがFulfilledとなった時点で、<code>.then</code> が呼ばれます。
また、<code>resolve(1)</code> が呼ばれるため <code>value</code> に渡される値も1となります。</p>
</div>
<div class="paragraph">
<p>最初にFulfilledとなったpromiseオブジェクト以外は、その後呼ばれているのかを見てみましょう。</p>
</div>
<div id="promise-race-other.js" class="listingblock executable">
<div class="title">promise-race-other.js</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript">const winnerPromise = <span class="keyword">new</span> Promise((resolve) =&gt; {
    setTimeout(() =&gt; {
        console.log(<span class="string"><span class="delimiter">&quot;</span><span class="content">this is winner</span><span class="delimiter">&quot;</span></span>);
        resolve(<span class="string"><span class="delimiter">&quot;</span><span class="content">this is winner</span><span class="delimiter">&quot;</span></span>);
    }, <span class="integer">4</span>);
});
const loserPromise = <span class="keyword">new</span> Promise((resolve) =&gt; {
    setTimeout(() =&gt; {
        console.log(<span class="string"><span class="delimiter">&quot;</span><span class="content">this is loser</span><span class="delimiter">&quot;</span></span>);
        resolve(<span class="string"><span class="delimiter">&quot;</span><span class="content">this is loser</span><span class="delimiter">&quot;</span></span>);
    }, <span class="integer">1000</span>);
});

<span class="comment">// 一番最初のものがresolveされた時点で終了</span>
Promise.race([winnerPromise, loserPromise]).then((value) =&gt; {
    console.log(value); <span class="comment">// =&gt; 'this is winner'</span>
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>先ほどのコードに <code>console.log</code> をそれぞれ追加しただけの内容となっています。</p>
</div>
<div class="paragraph">
<p>実行してみると、winner/loser どちらも <code>setTimeout</code> の中身が実行されて <code>console.log</code> がそれぞれ出力されていることがわかります。</p>
</div>
<div class="paragraph">
<p>つまり、<a href="#Promise.race"><code>Promise.race</code></a>では、
一番最初のpromiseオブジェクトがFulfilledとなっても、他のpromiseがキャンセルされるわけでは無いということがわかります。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<a href="#es-promises">ES Promises</a>の仕様には、キャンセルという概念はありません。
必ず、resolve or rejectによる状態の解決が起こることが前提となっています。
つまり、<a href="#promise-states">状態</a>が固定されてしまうかもしれない処理には不向きであるといえます。
ライブラリによってはキャンセルを行う仕組みが用意されている場合があります。
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="then-or-catch">2.11. then or catch?</h3>
<div class="paragraph">
<p><a href="#catch-as-alias">前の章</a>で <a href="#promise.catch"><code>.catch</code></a> は  <code>promise.then(undefined, onRejected)</code> であるということを紹介しました。</p>
</div>
<div class="paragraph">
<p>この書籍では基本的には、<a href="#promise.catch"><code>.catch</code></a>を使い <a href="#promise.then"><code>.then</code></a> とは分けてエラーハンドリングを書くようにしています。</p>
</div>
<div class="paragraph">
<p>ここでは、<code>.then</code> でまとめて指定した場合と、どのような違いがでるかについて学んでいきましょう。</p>
</div>
<div class="sect3">
<h4 id="_エラー処理ができないonrejected">2.11.1. エラー処理ができないonRejected</h4>
<div class="paragraph">
<p>次のようなコードを見ていきます。</p>
</div>
<div id="then-throw-error.js" class="listingblock executable">
<div class="title">then-throw-error.js</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript"><span class="keyword">function</span> <span class="function">throwError</span>(value) { <span class="comment">// 例外を投げる</span>
    <span class="keyword">throw</span> <span class="keyword">new</span> Error(value);
}
<span class="comment">// &lt;1&gt; onRejectedが呼ばれることはない</span>
<span class="keyword">function</span> <span class="function">badMain</span>(onRejected) {
    <span class="keyword">return</span> Promise.resolve(<span class="integer">42</span>).then(throwError, onRejected);
}
<span class="comment">// &lt;2&gt; onRejectedが例外発生時に呼ばれる</span>
<span class="keyword">function</span> <span class="function">goodMain</span>(onRejected) {
    <span class="keyword">return</span> Promise.resolve(<span class="integer">42</span>).then(throwError).<span class="keyword">catch</span>(onRejected);
}



<span class="comment">// 実行例</span>
badMain(<span class="keyword">function</span>(){
    console.log(<span class="string"><span class="delimiter">&quot;</span><span class="content">BAD</span><span class="delimiter">&quot;</span></span>);
});
goodMain(<span class="keyword">function</span>(){
    console.log(<span class="string"><span class="delimiter">&quot;</span><span class="content">GOOD</span><span class="delimiter">&quot;</span></span>);
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>このコード例では、(必ずしも悪いわけではないですが)良くないパターンの <code>badMain</code> と
ちゃんとエラーハンドリングが行える <code>goodMain</code> があります。</p>
</div>
<div class="paragraph">
<p><code>badMain</code> がなぜ良くないかというと、<code>.then</code> の第二引数にはエラー処理を書くことができますが、
そのエラー処理は第一引数の <code>onFulfilled</code> で指定した関数内で起きたエラーをキャッチすることはできません。</p>
</div>
<div class="paragraph">
<p>つまり、この場合、 <code>throwError</code> でエラーがおきても、<code>onRejected</code> に指定した関数は呼ばれることなく、
どこでエラーが発生したのかわからなくなってしまいます。</p>
</div>
<div class="paragraph">
<p>それに対して、 <code>goodMain</code> は <code>throwError</code> &#8594; <code>onRejected</code> となるように書かれています。
この場合は <code>throwError</code> でエラーが発生しても、次のchainである <code>.catch</code> が呼ばれるため、エラーハンドリングを行うことができます。</p>
</div>
<div class="paragraph">
<p><code>.then</code> のonRejectedが扱う処理は、その(またはそれ以前の)promiseオブジェクトに対してであって、
<code>.then</code> に書かれたonFulfilledは対象ではないためこのような違いが生まれます。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>.then</code> や <code>.catch</code> はその場で<strong>新しい</strong>promiseオブジェクトを作って返します。
Promiseではchainする度に異なるpromiseオブジェクトに対して処理を書くようになっています。</p>
</div>
</td>
</tr>
</table>
</div>
<div id="then-catch-flow" class="imageblock">
<div class="content">
<img src="Ch2_HowToWrite/img/then_catch.png" alt="Then Catch flow">
</div>
<div class="title">Figure 6. Then Catch flow</div>
</div>
<div class="paragraph">
<p>この場合の <code>then</code> は <code>Promise.resolve(42)</code> に対する処理となり、
<code>onFulfilled</code> で例外が発生しても、同じ <code>then</code> で指定された <code>onRejected</code> はキャッチすることはありません。</p>
</div>
<div class="paragraph">
<p>この <code>then</code> で発生した例外をキャッチできるのは、次のchainで書かれた <code>catch</code> となります。</p>
</div>
<div class="paragraph">
<p>もちろん <code>.catch</code> は <code>.then</code> のエイリアスなので、下記のように <code>.then</code> を使っても問題はありませんが、
<code>.catch</code> を使ったほうが意図が明確で分かりやすいでしょう。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript">Promise.resolve(<span class="integer">42</span>).then(throwError).then(<span class="predefined-constant">null</span>, onRejected);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_まとめ_2">2.11.2. まとめ</h4>
<div class="paragraph">
<p>ここでは次のようなことについて学びました。</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>promise.then(onFulfilled, onRejected)</code> において</p>
<div class="ulist">
<ul>
<li>
<p><code>onFulfilled</code> で例外がおきても、この <code>onRejected</code> はキャッチできない</p>
</li>
</ul>
</div>
</li>
<li>
<p><code>promise.then(onFulfilled).catch(onRejected)</code> とした場合</p>
<div class="ulist">
<ul>
<li>
<p><code>then</code> で発生した例外を <code>.catch</code> でキャッチできる</p>
</li>
</ul>
</div>
</li>
<li>
<p><a href="#promise.then"><code>.then</code></a>と<a href="#promise.catch"><code>.catch</code></a>に本質的な意味の違いはない</p>
<div class="ulist">
<ul>
<li>
<p>使い分けると意図が明確になる</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p><code>badMain</code> のような書き方をすると、意図とは異なりエラーハンドリングができないケースが存在することは覚えておきましょう。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="chapter3-promise-testing">3. Chapter.3 - Promiseのテスト</h2>
<div class="sectionbody">
<div class="paragraph">
<p>この章ではPromiseのテストの書き方について学んで行きます。</p>
</div>
<div class="sect2">
<h3 id="basic-tests">3.1. 基本的なテスト</h3>
<div class="paragraph">
<p><a href="#es-promises">ES Promises</a>のメソッド等についてひととおり学ぶことができたため、
実際にPromiseを使った処理を書いていくことはできると思います。</p>
</div>
<div class="paragraph">
<p>そうした時に、次にどうすればいいのか悩むのがPromiseのテストの書き方です。</p>
</div>
<div class="paragraph">
<p>ここではまず、 <a href="https://mochajs.org/">Mocha</a>を使った基本的なPromiseのテストの書き方について学んでいきましょう。</p>
</div>
<div class="paragraph">
<p>また、この章でのテストコードはNode.js環境で実行することを前提としているため、
各自Node.js環境を用意してください。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
この書籍中に出てくるサンプルコードはそれぞれテストも書かれています。
テストコードは <a href="https://github.com/azu/promises-book">azu/promises-book</a> から参照できます。
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_mochaとは">3.1.1. Mochaとは</h4>
<div class="paragraph">
<p>Mochaの公式サイト: <a href="https://mochajs.org/">https://mochajs.org/</a></p>
</div>
<div class="paragraph">
<p>ここでは、 Mocha自体については詳しく解説しませんが、
MochaはNode.js製のテストフレームワークツールです。</p>
</div>
<div class="paragraph">
<p>MochaはBDD,TDD,exportsのどれかのスタイルを選択でき、テストに使うアサーションメソッドも任意のライブラリと組み合わせて利用します。
つまり、Mocha自体はテスト実行時の枠だけを提供しており、他は利用者が選択するというものになっています。</p>
</div>
<div class="paragraph">
<p>Mochaを選択した理由は、以下のとおりです。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>著名なテストフレームワークであること</p>
</li>
<li>
<p>Node.jsとブラウザ どちらのテストもサポートしている</p>
</li>
<li>
<p>"Promiseのテスト"をサポートしている</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>最後の <em>"Promiseのテスト"をサポートしている</em> とはどういうことなのかについては後ほど解説します。</p>
</div>
<div class="paragraph">
<p>この章ではMochaを利用するため、npmを使いMochaをインストールしておく必要があります。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="console">$ npm install -g mocha</code></pre>
</div>
</div>
<div class="paragraph">
<p>また、アサーション自体はNode.jsに同梱されている <code>assert</code> モジュールを使用するので別途インストールは必要ありません。</p>
</div>
<div class="paragraph">
<p>まずはコールバックスタイルの非同期処理をテストしてみましょう。</p>
</div>
</div>
<div class="sect3">
<h4 id="_コールバックスタイルのテスト">3.1.2. コールバックスタイルのテスト</h4>
<div class="paragraph">
<p>コールバックスタイルの非同期処理をテストする場合、Mochaでは以下のように書くことができます。</p>
</div>
<div class="listingblock">
<div class="title">basic-test.js</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript">const assert = require(<span class="string"><span class="delimiter">&quot;</span><span class="content">assert</span><span class="delimiter">&quot;</span></span>);
it(<span class="string"><span class="delimiter">&quot;</span><span class="content">should use `done` for test</span><span class="delimiter">&quot;</span></span>, (done) =&gt; {
    setTimeout(() =&gt; {
        assert(<span class="predefined-constant">true</span>);
        done();
    }, <span class="integer">0</span>);
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>このテストを <code>basic-test.js</code> というファイル名で作成し、
先ほどインストールしたMochaでコマンドラインからテストを実行することができます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="sh">$ mocha basic-test.js</code></pre>
</div>
</div>
<div class="paragraph">
<p>Mochaは <code>it</code> の仮引数に <code>done</code> のように指定してあげると、
<code>done()</code> が呼ばれるまでテストの終了を待つことで非同期のテストをサポートしています。</p>
</div>
<div class="paragraph">
<p>Mochaでの非同期テストは以下のような流れで実行されます。</p>
</div>
<div id="callback-style-test" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript">it(<span class="string"><span class="delimiter">&quot;</span><span class="content">should use `done` for test</span><span class="delimiter">&quot;</span></span>, (done) =&gt; {
    <i class="conum" data-value="1"></i><b>(1)</b>
    setTimeout(() =&gt; {
        assert(<span class="predefined-constant">true</span>);
        done();<i class="conum" data-value="2"></i><b>(2)</b>
    }, <span class="integer">0</span>);
});</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>コールバックを使う非同期処理</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>done</code> を呼ぶことでテストが終了する</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>よく見かける形の書き方ですね。</p>
</div>
</div>
<div class="sect3">
<h4 id="done-promise-test">3.1.3. <code>done</code> を使ったPromiseのテスト</h4>
<div class="paragraph">
<p>次に、同じく <code>done</code> を使ったPromiseのテストを書いてみましょう。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript">it(<span class="string"><span class="delimiter">&quot;</span><span class="content">should use `done` for test?</span><span class="delimiter">&quot;</span></span>, (done) =&gt; {
    const promise = Promise.resolve(<span class="integer">42</span>);<i class="conum" data-value="1"></i><b>(1)</b>
    promise.then((value) =&gt; {
        assert(value === <span class="integer">42</span>);
        done();<i class="conum" data-value="2"></i><b>(2)</b>
    });
});</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>Fulfilled</code> となるpromiseオブジェクトを作成</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>done</code> を呼ぶことでテストの終了を宣言</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><a href="#Promise.resolve"><code>Promise.resolve</code></a> はpromiseオブジェクトを返しますが、
そのpromiseオブジェクトはFulfilledの状態になります。
その結果として <code>.then</code> で登録したコールバック関数が呼び出されます。</p>
</div>
<div class="paragraph">
<p><a href="#promise-is-always-async">コラム: Promiseは常に非同期?</a> でも出てきたように、
promiseオブジェクトは常に非同期で処理されるため、テストも非同期に対応した書き方が必要となります。</p>
</div>
<div class="paragraph">
<p>しかし、先ほどのテストコードでは <code>assert</code> が失敗した場合に問題が発生します。</p>
</div>
<div id="promise-assert-fail" class="listingblock">
<div class="title">意図しない結果となるPromiseのテスト</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript">it(<span class="string"><span class="delimiter">&quot;</span><span class="content">should use `done` for test?</span><span class="delimiter">&quot;</span></span>, (done) =&gt; {
    const promise = Promise.resolve();
    promise.then((value) =&gt; {
        assert(<span class="predefined-constant">false</span>);<span class="comment">// =&gt; throw AssertionError</span>
        done();
    });
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>このテストは <code>assert</code> が失敗しているため、「テストは失敗する」と思うかもしれませんが、
実際にはテストが終わることがなくタイムアウトします。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="Ch3_Testing/img/promise-test-timeout.png" alt="promise test timeout">
</div>
<div class="title">Figure 7. テストが終わることがないためタイムアウトするまでそこで止まる</div>
</div>
<div class="paragraph">
<p><code>assert</code> が失敗した場合は通常はエラーをthrowし、
テストフレームワークがそれをキャッチすることで、テストが失敗したと判断します。</p>
</div>
<div class="paragraph">
<p>しかし、Promiseの場合は <code>.then</code> の中で行われた処理でエラーが発生しても、
Promiseがそれをキャッチしてしまい、テストフレームワークまでエラーが届きません。</p>
</div>
<div class="paragraph">
<p><a href="#promise-assert-fail">意図しない結果となるPromiseのテスト</a>を改善して、
<code>assert</code> が失敗した場合にちゃんとテストが失敗となるようにしてみましょう。</p>
</div>
<div id="promise-assert-fail-fixed" class="listingblock">
<div class="title">意図通りにテストが失敗する例</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript">it(<span class="string"><span class="delimiter">&quot;</span><span class="content">should use `done` for test?</span><span class="delimiter">&quot;</span></span>, (done) =&gt; {
    const promise = Promise.resolve();
    promise.then((value) =&gt; {
        assert(<span class="predefined-constant">false</span>);
    }).then(done, done);
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>ちゃんとテストが失敗する例では、必ず <code>done</code> が呼ばれるようにするため、
最後に <code>.then(done, done);</code> を追加しています。</p>
</div>
<div class="paragraph">
<p><code>assert</code> がパスした場合は単純に <code>done()</code> が呼ばれ、<code>assert</code> が失敗した場合は <code>done(error)</code> が呼ばれます。</p>
</div>
<div class="paragraph">
<p>これでようやく<a href="#callback-style-test">コールバックスタイルのテスト</a>と同等のPromiseのテストを書くことができました。</p>
</div>
<div class="paragraph">
<p>しかし、<code>assert</code> が失敗した時のために <code>.then(done, done);</code> というものを付ける必要があります。
Promiseのテストを書くときにつけ忘れてしまうと終わらないテストができ上がってしまう場合があることに気をつけましょう。</p>
</div>
<div class="paragraph">
<p>次に、最初にmochaを使う理由に上げた"Promisesのテスト"のサポートがどのような機能であるか学んでいきましょう。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="mocha-promise">3.2. MochaのPromiseサポート</h3>
<div class="paragraph">
<p>Mochaがサポートしてる"Promiseのテスト"とは何かについて学んでいきましょう。</p>
</div>
<div class="paragraph">
<p>公式サイトの <a href="https://mochajs.org/#asynchronous-code">Asynchronous code</a>にもその概要が書かれています。</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Alternately, instead of using the done() callback, you can return a promise. This is useful if the APIs you are testing return promises instead of taking callbacks:</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>Promiseのテストの場合はコールバックとして <code>done()</code> を呼ぶ代わりに、promiseオブジェクトをreturnすることができると書いてあります。</p>
</div>
<div class="paragraph">
<p>では、実際にどのように書くかの例を見ていきたいと思います。</p>
</div>
<div id="mocha-promise-test.js" class="listingblock">
<div class="title">mocha-promise-test.js</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript">const assert = require(<span class="string"><span class="delimiter">&quot;</span><span class="content">assert</span><span class="delimiter">&quot;</span></span>);
describe(<span class="string"><span class="delimiter">&quot;</span><span class="content">Promise Test</span><span class="delimiter">&quot;</span></span>, () =&gt; {
    it(<span class="string"><span class="delimiter">&quot;</span><span class="content">should return a promise object</span><span class="delimiter">&quot;</span></span>, () =&gt; {
        const promise = Promise.resolve(<span class="integer">42</span>);
        <span class="keyword">return</span> promise.then((value) =&gt; {
            assert(value === <span class="integer">42</span>);
        });
    });
});</code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="#promise-assert-fail-fixed">先ほどの <code>done</code> を使った例</a>をMochaのPromiseテストの形式に変更しました。</p>
</div>
<div class="paragraph">
<p>変更点としては以下の2つとなっています。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>done</code> そのものを取り除いた</p>
</li>
<li>
<p>promiseオブジェクトを返すようにした</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>この書き方をした場合、<code>assert</code> が失敗した場合はもちろんテストが失敗します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript">it(<span class="string"><span class="delimiter">&quot;</span><span class="content">should be fail</span><span class="delimiter">&quot;</span></span>, () =&gt; {
    <span class="keyword">return</span> Promise.resolve().then(() =&gt; {
        assert(<span class="predefined-constant">false</span>);<span class="comment">// =&gt; テストが失敗する</span>
    });
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>これにより <code>.then(done, done);</code> というような本質的にはテストとは関係ない記述を省くことができるようになりました。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p><a href="http://efcl.info/2014/0314/res3708/">MochaがPromisesのテストをサポートしました | Web scratch</a> という記事でも
MochaのPromiseサポートについて書かれています。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_意図しないテスト結果">3.2.1. 意図しないテスト結果</h4>
<div class="paragraph">
<p>MochaがPromiseのテストをサポートしているため、この書き方でよいと思われるかもしれません。
しかし、この書き方にも意図しない結果になる例外が存在します。</p>
</div>
<div class="paragraph">
<p>たとえば、以下はある条件だとRejectedなpromiseオブジェクトを返す <code>mayBeRejected()</code> のテストコードです。</p>
</div>
<div id="mocha-rejected-promise-test" class="listingblock">
<div class="title">エラーオブジェクトをテストしたい</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript"><span class="keyword">function</span> <span class="function">mayBeRejected</span>() { <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="keyword">return</span> Promise.reject(<span class="keyword">new</span> Error(<span class="string"><span class="delimiter">&quot;</span><span class="content">woo</span><span class="delimiter">&quot;</span></span>));
}
it(<span class="string"><span class="delimiter">&quot;</span><span class="content">is bad pattern</span><span class="delimiter">&quot;</span></span>, () =&gt; {
    <span class="keyword">return</span> mayBeRejected().<span class="keyword">catch</span>((error) =&gt; {
        assert(error.message === <span class="string"><span class="delimiter">&quot;</span><span class="content">woo</span><span class="delimiter">&quot;</span></span>);
    });
});</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>この関数が返すpromiseオブジェクトをテストしたい</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>このテストの目的とは以下のようになっています。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>mayBeRejected()</code> が返すpromiseオブジェクトがFulfilledとなった場合</dt>
<dd>
<p>テストを失敗させる</p>
</dd>
<dt class="hdlist1"><code>mayBeRejected()</code> が返すpromiseオブジェクトがRejectedとなった場合</dt>
<dd>
<p><code>assert</code> でErrorオブジェクトをチェックする</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>上記のテストコードでは、Rejectedとなって <code>onRejected</code> に登録された関数が呼ばれるためテストはパスしますね。</p>
</div>
<div class="paragraph">
<p>このテストで問題になるのは <code>mayBeRejected()</code> で返されたpromiseオブジェクトが
<strong>Fulfilledとなった場合</strong>に、必ずテストがパスしてしまうという問題が発生します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript"><span class="keyword">function</span> <span class="function">mayBeRejected</span>() { <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="keyword">return</span> Promise.resolve();
}
it(<span class="string"><span class="delimiter">&quot;</span><span class="content">is bad pattern</span><span class="delimiter">&quot;</span></span>, () =&gt; {
    <span class="keyword">return</span> mayBeRejected().<span class="keyword">catch</span>((error) =&gt; {
        assert(error.message === <span class="string"><span class="delimiter">&quot;</span><span class="content">woo</span><span class="delimiter">&quot;</span></span>);
    });
});</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>返されるpromiseオブジェクトはFulfilledとなる</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>この場合、<code>catch</code> で登録した <code>onRejected</code> の関数はそもそも呼ばれないため、
<code>assert</code> がひとつも呼ばれることなくテストが必ずパスしてしまいます。</p>
</div>
<div class="paragraph">
<p>これを解消しようとして、<code>.catch</code> の前に <code>.then</code> を入れて、
<code>.then</code> が呼ばれたらテストを失敗にしたいと考えるかもしれません。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript"><span class="keyword">function</span> <span class="function">failTest</span>() { <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string"><span class="delimiter">&quot;</span><span class="content">Expected promise to be rejected but it was fulfilled</span><span class="delimiter">&quot;</span></span>);
}
<span class="keyword">function</span> <span class="function">mayBeRejected</span>() {
    <span class="keyword">return</span> Promise.resolve();
}
it(<span class="string"><span class="delimiter">&quot;</span><span class="content">should bad pattern</span><span class="delimiter">&quot;</span></span>, () =&gt; {
    <span class="keyword">return</span> mayBeRejected().then(failTest).<span class="keyword">catch</span>((error) =&gt; {
        assert(error.message === <span class="string"><span class="delimiter">&quot;</span><span class="content">woo</span><span class="delimiter">&quot;</span></span>);
    });
});</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>throwすることでテストを失敗にしたい</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>しかし、この書き方だと<a href="#then-or-catch">then or catch?</a>で紹介したように、
<code>failTest</code> で投げられたエラーが <code>catch</code> されてしまいます。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="Ch2_HowToWrite/img/then_catch.png" alt="Then Catch flow">
</div>
<div class="title">Figure 8. Then Catch flow</div>
</div>
<div class="paragraph">
<p><code>then</code> &#8594; <code>catch</code> となり、<code>catch</code> に渡ってくるErrorオブジェクトは <code>AssertionError</code> となり、
意図したものとは違うものが渡ってきてしまいます。</p>
</div>
<div class="paragraph">
<p>つまり、onRejectedになること<strong>だけ</strong>を期待して書かれたテストは、onFulfilledの状態になってしまうと
常にテストがパスしてしまうという問題を持っていることが分かります。</p>
</div>
</div>
<div class="sect3">
<h4 id="_両状態を明示して意図しないテストを改善">3.2.2. 両状態を明示して意図しないテストを改善</h4>
<div class="paragraph">
<p><a href="#mocha-rejected-promise-test">上記のエラーオブジェクトのテスト</a>を書く場合、
どのようにすれば意図せず通ってしまうテストを無くすことができるでしょうか?</p>
</div>
<div class="paragraph">
<p>一番単純な方法としては、以下のようにそれぞれの状態の場合にどうなるのかをテストコードに書く方法です。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Fulfilledとなった場合</dt>
<dd>
<p>意図したとおりテストが失敗する</p>
</dd>
<dt class="hdlist1">Rejectedとなった場合</dt>
<dd>
<p><code>assert</code> でテストを行える</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>つまり、Fulfilled、Rejected 両方の状態について、テストがどうなってほしいかを明示する必要があるわけです。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript"><span class="keyword">function</span> <span class="function">mayBeRejected</span>() {
    <span class="keyword">return</span> Promise.resolve();
}
it(<span class="string"><span class="delimiter">&quot;</span><span class="content">catch -&gt; then</span><span class="delimiter">&quot;</span></span>, () =&gt; {
    <span class="comment">// Fulfilledとなった場合はテストは失敗する</span>
    <span class="keyword">return</span> mayBeRejected().then(failTest, (error) =&gt; {
        assert(error.message === <span class="string"><span class="delimiter">&quot;</span><span class="content">woo</span><span class="delimiter">&quot;</span></span>);
    });
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>このように書くことで、Fulfilledとなった場合は失敗するテストコードを書くことができます。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="Ch3_Testing/img/promise-test.png" alt="Promise onRejected test">
</div>
<div class="title">Figure 9. Promise onRejected test</div>
</div>
<div class="paragraph">
<p><a href="#then-or-catch">then or catch?</a>のときは、エラーの見逃しを避けるため、
<code>.then(onFulfilled, onRejected)</code> の第二引数ではなく、<code>then</code> &#8594; <code>catch</code> と分けることを推奨していました。</p>
</div>
<div class="paragraph">
<p>しかし、テストの場合はPromiseの強力なエラーハンドリングが逆にテストの邪魔をしてしまいます。
そのため <code>.then(failTest, onRejected)</code> と書くことで、どちらの状態になるのかを明示してテストを書くことができました。</p>
</div>
</div>
<div class="sect3">
<h4 id="_まとめ_3">3.2.3. まとめ</h4>
<div class="paragraph">
<p>MochaのPromiseサポートについてと意図しない挙動となる場合について紹介しました。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>通常のコードは <code>then</code> &#8594; <code>catch</code> と分けた方がよい</p>
<div class="ulist">
<ul>
<li>
<p>エラーハンドリングのため。<a href="#then-or-catch">then or catch?</a>を参照</p>
</li>
</ul>
</div>
</li>
<li>
<p>テストコードは <code>then</code> にまとめた方がよい</p>
<div class="ulist">
<ul>
<li>
<p>アサーションエラーがテストフレームワークに届くようにするため。</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>.then(onFulfilled, onRejected)</code> を使うことで、
promiseオブジェクトがFulfilled、Rejectedどちらの状態になるかを明示してテストする必要があります。</p>
</div>
<div class="paragraph">
<p>しかし、Rejectedのテストであることを明示するために、以下のように書くのはあまり直感的ではないと思います。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript">promise.then(failTest, (error) =&gt; {
    <span class="comment">// assertでerrorをテストする</span>
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>次は、Promiseのテストを手助けするヘルパー関数を定義して、
もう少し分かりやすいテストを書くにはどうするべきかについて見ていきましょう。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="controllable-tests">3.3. 意図したテストを書くには</h3>
<div class="paragraph">
<p>ここでいう意図したテストとは以下のような定義で進めます。</p>
</div>
<div class="paragraph">
<p>あるpromiseオブジェクトをテスト対象として</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Fulfilledされることを期待したテストを書いた時</p>
<div class="ulist">
<ul>
<li>
<p>Rejectedとなった場合は<strong>Fail</strong></p>
</li>
<li>
<p>assertionの結果が一致しなかった場合は<strong>Fail</strong></p>
</li>
</ul>
</div>
</li>
<li>
<p>Rejectedされることを期待したテストを書いた時</p>
<div class="ulist">
<ul>
<li>
<p>Fulfilledとなった場合は<strong>Fail</strong></p>
</li>
<li>
<p>assertionの結果が一致しなかった場合は<strong>Fail</strong></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>上記のケース(Fail)に該当しなければテストがパスするということですね。</p>
</div>
<div class="paragraph">
<p>つまり、ひとつのテストケースにおいて以下のことを書く必要があります。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Fulfilled or Rejected どちらを期待するか</p>
</li>
<li>
<p>assertionで渡された値のチェック</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>先ほどの <code>.then</code> を使ったコードはRejectedを期待したテストとなっていますね。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript">promise.then(failTest, (error) =&gt; {
    <span class="comment">// assertでerrorをテストする</span>
    assert(error <span class="keyword">instanceof</span> Error);
});</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_どちらの状態になるかを明示する">3.3.1. どちらの状態になるかを明示する</h4>
<div class="paragraph">
<p>意図したテストにするためには、<a href="#promise-states">promiseの状態</a>が
Fulfilled or Rejected どちらの状態になって欲しいかを明示する必要があります。</p>
</div>
<div class="paragraph">
<p>しかし、<code>.then</code> だと引数は省略可能なので、テストが落ちる条件を入れ忘れる可能性もあります。</p>
</div>
<div class="paragraph">
<p>そこで、promiseオブジェクトに期待する状態を明示できるヘルパー関数を定義してみましょう。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>ライブラリ化したものが <a href="https://github.com/azu/promise-test-helper">azu/promise-test-helper</a> にありますが、
今回はその場で簡単に定義して進めます。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>まずは、先ほどの <code>.then</code> の例を元にonRejectedを期待してテストできる
<code>shouldRejected</code> というヘルパー関数を作ってみたいと思います。</p>
</div>
<div id="shouldRejected-test.js" class="listingblock">
<div class="title">shouldRejected-test.js</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript">const assert = require(<span class="string"><span class="delimiter">&quot;</span><span class="content">assert</span><span class="delimiter">&quot;</span></span>);
<span class="keyword">function</span> <span class="function">shouldRejected</span>(promise) {
    <span class="keyword">return</span> {
        <span class="key"><span class="delimiter">&quot;</span><span class="content">catch</span><span class="delimiter">&quot;</span></span>: <span class="keyword">function</span>(fn) {
            <span class="keyword">return</span> promise.then(() =&gt; {
                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string"><span class="delimiter">&quot;</span><span class="content">Expected promise to be rejected but it was fulfilled</span><span class="delimiter">&quot;</span></span>);
            }, (reason) =&gt; {
                fn.call(promise, reason);
            }
            );
        }
    };
}
it(<span class="string"><span class="delimiter">&quot;</span><span class="content">should be rejected</span><span class="delimiter">&quot;</span></span>, () =&gt; {
    const promise = Promise.reject(<span class="keyword">new</span> Error(<span class="string"><span class="delimiter">&quot;</span><span class="content">human error</span><span class="delimiter">&quot;</span></span>));
    <span class="keyword">return</span> shouldRejected(promise).<span class="keyword">catch</span>((error) =&gt; {
        assert(error.message === <span class="string"><span class="delimiter">&quot;</span><span class="content">human error</span><span class="delimiter">&quot;</span></span>);
    });
});</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>shouldRejected</code> にpromiseオブジェクトを渡すと、<code>catch</code> というメソッドをもつオブジェクトを返します。</p>
</div>
<div class="paragraph">
<p>この <code>catch</code> にはonRejectedで書くものと全く同じ使い方ができるので、
<code>catch</code> の中にassertionによるテストを書けるようになっています。</p>
</div>
<div class="paragraph">
<p><code>shouldRejected</code> で囲む以外は、通常のpromiseの処理と似た感じになるので以下のようになります。</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>shouldRejected</code> にテスト対象のpromiseオブジェクトを渡す</p>
</li>
<li>
<p>返ってきたオブジェクトの <code>catch</code> メソッドでonRejectedの処理を書く</p>
</li>
<li>
<p>onRejectedにassertionによるテストを書く</p>
</li>
</ol>
</div>
<div class="paragraph">
<p><code>shouldRejected</code> を使った場合、Fulfilledが呼ばれるとエラーをthrowしてテストが失敗するようになっています。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript">promise.then(failTest, (error) =&gt; {
    assert(error.message === <span class="string"><span class="delimiter">&quot;</span><span class="content">human error</span><span class="delimiter">&quot;</span></span>);
});
<span class="comment">// == ほぼ同様の意味</span>
shouldRejected(promise).<span class="keyword">catch</span>((error) =&gt; {
    assert(error.message === <span class="string"><span class="delimiter">&quot;</span><span class="content">human error</span><span class="delimiter">&quot;</span></span>);
});</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>shouldRejected</code> のようなヘルパー関数を使うことで、テストコードが少し直感的になりましたね。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="Ch3_Testing/img/promise-test.png" alt="Promise onRejected test">
</div>
<div class="title">Figure 10. Promise onRejected test</div>
</div>
<div class="paragraph">
<p>同様に、promiseオブジェクトがFulfilledになることを期待する <code>shouldFulfilled</code> も書いてみましょう。</p>
</div>
<div id="shouldFulfilled-test.js" class="listingblock">
<div class="title">shouldFulfilled-test.js</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript">const assert = require(<span class="string"><span class="delimiter">&quot;</span><span class="content">assert</span><span class="delimiter">&quot;</span></span>);
<span class="keyword">function</span> <span class="function">shouldFulfilled</span>(promise) {
    <span class="keyword">return</span> {
        <span class="key"><span class="delimiter">&quot;</span><span class="content">then</span><span class="delimiter">&quot;</span></span>: <span class="keyword">function</span>(fn) {
            <span class="keyword">return</span> promise.then((value) =&gt; {
                fn.call(promise, value);
            }, (reason) =&gt; {
                <span class="keyword">throw</span> reason;
            }
            );
        }
    };
}
it(<span class="string"><span class="delimiter">&quot;</span><span class="content">should be fulfilled</span><span class="delimiter">&quot;</span></span>, () =&gt; {
    const promise = Promise.resolve(<span class="string"><span class="delimiter">&quot;</span><span class="content">value</span><span class="delimiter">&quot;</span></span>);
    <span class="keyword">return</span> shouldFulfilled(promise).then((value) =&gt; {
        assert(value === <span class="string"><span class="delimiter">&quot;</span><span class="content">value</span><span class="delimiter">&quot;</span></span>);
    });
});</code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="#shouldRejected-test.js">shouldRejected-test.js</a>と基本は同じで、返すオブジェクトの <code>catch</code> が <code>then</code> になって中身が逆転しただけですね。</p>
</div>
</div>
<div class="sect3">
<h4 id="_まとめ_4">3.3.2. まとめ</h4>
<div class="paragraph">
<p>Promiseで意図したテストを書くためにはどうするか、またそれを補助するヘルパー関数について学びました。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>今回書いた <code>shouldFulfilled</code> と <code>shouldRejected</code> はライブラリとして利用できるようになっています。</p>
</div>
<div class="paragraph">
<p><a href="https://github.com/azu/promise-test-helper">azu/promise-test-helper</a> からダウンロードすることができます。</p>
</div>
<div class="paragraph">
<p>また、Node.js 10.0.0から <code>assert.rejects</code> と <code>assert.doesNotReject</code> というよく似た趣旨のassertionが提供されています。
詳細は、 <a href="https://nodejs.org/api/assert.html">Node.jsのAPIドキュメント</a>を参照してください。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>また、今回のヘルパー関数は<a href="#mocha-promise">MochaのPromiseサポート</a>を前提とした書き方なので、
<a href="#done-promise-test"><code>done</code> を使ったテスト</a>では利用しにくいと思います。</p>
</div>
<div class="paragraph">
<p>テストフレームワークのPromiseサポートを使うか、<code>done</code> のようにコールバックスタイルのテストを使うかは、
人それぞれのスタイルの問題であるためそこまではっきりした優劣はないと思います。</p>
</div>
<div class="paragraph">
<p>たとえば、 <a href="http://coffeescript.org/">CoffeeScript</a>でテストを書いたりすると、
CoffeeScriptには暗黙のreturnがあるので、<code>done</code> を使ったほうが分かりやすいかもしれません。</p>
</div>
<div class="paragraph">
<p>Promiseのテストは普通に非同期関数のテスト以上に落とし穴があるため、
どのスタイルを取るかは自由ですが、一貫性を持った書き方をすることが大切だといえます。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="chapter4-advanced-promise">4. Chapter.4 - Advanced</h2>
<div class="sectionbody">
<div class="paragraph">
<p>この章では、これまでに学んだことの応用や発展した内容について学んでいきます。</p>
</div>
<div class="sect2">
<h3 id="promise-library">4.1. Promiseのライブラリ</h3>
<div class="paragraph">
<p>このセクションでは、ブラウザが実装しているPromiseではなく、サードパーティにより作られた
Promise互換のライブラリについて紹介していきたいと思います。</p>
</div>
<div class="sect3">
<h4 id="_なぜライブラリが必要か">4.1.1. なぜライブラリが必要か?</h4>
<div class="paragraph">
<p>なぜライブラリが必要か?という疑問に関する多くの答えとしては、
その実行環境で「<a href="#es-promises">ES Promises</a>が実装されていないから」というのがまず出てくるでしょう。</p>
</div>
<div class="iframe-wrapper" style="width: 100%; height: 350px; overflow: auto; -webkit-overflow-scrolling: touch;">
<iframe src="https://caniuse.com/promises/embed/agents=desktop" width="100%" height="350px"></iframe>
</div>
<div class="paragraph">
<p>Promiseのライブラリを探すときに、一つ目印になる言葉として<a href="#promises-aplus">Promises/A+互換</a>があります。</p>
</div>
<div class="paragraph">
<p><a href="#promises-aplus">Promises/A+</a>というのは<a href="#es-promises">ES Promises</a>の前身となったもので、
Promiseの <code>then</code> について取り決めたコミュニティベースの仕様です。</p>
</div>
<div class="paragraph">
<p>Promises/A+互換と書かれていた場合は <code>then</code> についての動作は互換性があり、
多くの場合はそれに加えて <code>Promise.all</code> や <code>catch</code> 等と同様の機能が実装されています。</p>
</div>
<div class="paragraph">
<p>しかし、Promises/A+は <code>Promise#then</code> についてのみの仕様となっているため、
他の機能は実装されていても名前が異なる場合があります。</p>
</div>
<div class="paragraph">
<p>また、<code>then</code> というメソッドに互換性があるということは、<a href="#Thenable">Thenable</a>であるということなので、
<a href="#Promise.resolve">Promise.resolve</a>を使い、ESのPromiseで定められたpromiseオブジェクトに変換することができます。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>ECMAScriptのPromiseで定められたpromiseオブジェクトというのは、
<code>catch</code> というメソッドが使えたり、<code>Promise.all</code> で扱う際に問題が起こらないということです。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_polyfillとライブラリ">4.1.2. Polyfillとライブラリ</h4>
<div class="paragraph">
<p>ここでは、大きくわけて2種類のライブラリを紹介したいと思います。</p>
</div>
<div class="paragraph">
<p>一つはPolyfillと呼ばれる種類のライブラリで、
もう一つは、<a href="#promises-aplus">Promises/A+互換</a>に加えて、独自の拡張をもったライブラリです。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Promiseのライブラリは星の数ほどあるので、ここで紹介するのは極々一部です。
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="promise-polyfill">Polyfill</h5>
<div class="paragraph">
<p>Polyfillライブラリは読み込むことで、IEといったPromiseが実装されていないブラウザ等でも、
Promiseと同等の機能を同じメソッド名で提供してくれるライブラリのことです。</p>
</div>
<div class="paragraph">
<p>つまり、Polyfillを読みこめばこの書籍で紹介しているコードは、
Promiseがサポートされてない環境でも実行できるようになります。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="https://github.com/zloirock/core-js">zloirock/core-js</a></dt>
<dd>
<p>ECMAScriptやウェブ標準で定義されている仕様を実装したPolyfillライブラリです。
多種多様な機能のPolyfillが含まれており、その一つとしてPromiseのPolyfillが実装されています。
<a href="https://babeljs.io/">Babel</a>のプリセットにも組み込まれています。</p>
</dd>
<dt class="hdlist1"><a href="https://github.com/jakearchibald/es6-promise">jakearchibald/es6-promise</a></dt>
<dd>
<p>ES6(ES2015) Promisesと互換性を持ったPolyfillライブラリです。
<a href="https://github.com/tildeio/rsvp.js">RSVP.js</a> という Promises/A+互換ライブラリがベースとなっており、
これのサブセットとしてES6 PromisesのAPIだけが実装されているライブラリです。</p>
</dd>
<dt class="hdlist1"><a href="https://github.com/taylorhakes/promise-polyfill">taylorhakes/promise-polyfill</a></dt>
<dd>
<p>ES Promisesのpolyfillとなることを目的としたライブラリです。
実行環境にネイティブのPromiseがある場合はそちらを優先し、上書きしないようにしています。</p>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="_promise拡張ライブラリ">Promise拡張ライブラリ</h5>
<div class="paragraph">
<p>Promiseを仕様どおりに実装したものに加えて独自のメソッド等を提供してくれるライブラリです。</p>
</div>
<div class="paragraph">
<p>Promise拡張ライブラリは本当に沢山ありますが、以下の2つの著名なライブラリを紹介します。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="https://github.com/kriskowal/q">kriskowal/q</a></dt>
<dd>
<p><code>Q</code> と呼ばれるPromisesやDeferredsを実装したライブラリです。
2009年から開発されており、Node.js向けのファイルIOのAPIを提供する <a href="https://github.com/kriskowal/q-io">Q-IO</a> 等、
多くの状況で使える機能が用意されているライブラリです。</p>
</dd>
<dt class="hdlist1"><a href="https://github.com/petkaantonov/bluebird">petkaantonov/bluebird</a></dt>
<dd>
<p>Promise互換に加えて、キャンセルできるPromiseや進行度を取得できるPromise、エラーハンドリングの拡張検出等、
多くの拡張を持っており、またパフォーマンスにも気を配った実装がされているライブラリです。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Q と Bluebird どちらのライブラリもブラウザでも動作する他、APIリファレンスが充実しているのも特徴的です。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/kriskowal/q/wiki/API-Reference">API Reference · kriskowal/q Wiki</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>QのドキュメントにはjQueryがもつDeferredの仕組みとどのように違うのか、移行する場合の対応メソッドについても
<a href="https://github.com/kriskowal/q/wiki/Coming-from-jQuery">Coming from jQuery</a> にまとめられています。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/petkaantonov/bluebird/blob/master/API.md">bluebird/API.md at master · petkaantonov/bluebird</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>BluebirdではPromiseを使った豊富な機能に加えて、エラーが起きた時の対処法や
<a href="https://github.com/petkaantonov/bluebird/wiki/Promise-anti-patterns">Promiseのアンチパターン</a> について書かれています。</p>
</div>
<div class="paragraph">
<p>どちらのドキュメントも優れているため、このライブラリを使ってない場合でも読んでおくと参考になることが多いと思います。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_まとめ_5">4.1.3. まとめ</h4>
<div class="paragraph">
<p>このセクションではPromiseのライブラリとしてPolyfillと拡張ライブラリを紹介しました。</p>
</div>
<div class="paragraph">
<p>Promiseのライブラリは多種多様であるため、どれを使用するかは好みの問題といえるでしょう。</p>
</div>
<div class="paragraph">
<p>しかし、PromiseはPromises/A+ または ES Promisesという共通のインターフェースを持っているため、
そのライブラリで書かれているコードや独自の拡張などは、他のライブラリを利用している時でも参考になるケースは多いでしょう。</p>
</div>
<div class="paragraph">
<p>そのようなPromiseの共通の概念を学び、応用できるようになるのがこの書籍の目的の一つです。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="resolve-thenable">4.2. Promise.resolveとThenable</h3>
<div class="paragraph">
<p><a href="#ch2-promise-resolve">第二章のPromise.resolve</a>にて、<code>Promise.resolve</code> の大きな特徴の一つとしてthenableなオブジェクトを変換する機能について紹介しました。</p>
</div>
<div class="paragraph">
<p>このセクションでは、thenableなオブジェクトからpromiseオブジェクトに変換してどのように利用するかについて学びたいと思います。</p>
</div>
<div class="sect3">
<h4 id="_web_notificationsをthenableにする">4.2.1. Web Notificationsをthenableにする</h4>
<div class="paragraph">
<p><a href="https://developer.mozilla.org/ja/docs/Web/API/notification">Web Notifications</a>という
デスクトップ通知を行うAPIを例に考えてみます。</p>
</div>
<div class="paragraph">
<p>Web Notifications APIについて詳しくは以下を参照して下さい。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://developer.mozilla.org/ja/docs/WebAPI/Using_Web_Notifications">Web Notifications の使用 - WebAPI | MDN</a></p>
</li>
<li>
<p><a href="https://caniuse.com/notifications">Can I use Web Notifications</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Web Notifications APIについて簡単に解説すると、以下のように <code>new Notification</code> をすることで通知メッセージが表示できます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript"><span class="keyword">new</span> Notification(<span class="string"><span class="delimiter">&quot;</span><span class="content">Hi!</span><span class="delimiter">&quot;</span></span>);</code></pre>
</div>
</div>
<div class="paragraph">
<p>しかし、通知を行うためには、<code>new Notification</code> をする前にユーザーに許可を取る必要があります。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="Ch4_AdvancedPromises/img/notification-dialog.png" alt="Notificationの許可ダイアログ">
</div>
<div class="title">Figure 11. Notificationの許可ダイアログ</div>
</div>
<div class="paragraph">
<p>この許可ダイアログで選択した結果は、<code>Notification.permission</code> に入りますが、
値は許可("granted")か不許可("denied")の2種類です。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Notificationのダイアログの選択肢は、
Firefoxだと許可、不許可に加えて <em>永続</em> か <em>セッション限り</em> の組み合わせがありますが、値自体は同じです。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>許可ダイアログは <code>Notification.requestPermission()</code> を実行すると表示され、
ユーザーが選択した結果がコールバック関数の <code>status</code> に渡されます。</p>
</div>
<div class="paragraph">
<p>コールバック関数を受け付けることから分かるように、この許可、不許可は非同期的に行われます。</p>
</div>
<div class="listingblock executable">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript">Notification.requestPermission((status) =&gt; {
    <span class="comment">// statusに&quot;granted&quot; or &quot;denied&quot;が入る</span>
    console.log(status);
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>通知を行うまでの流れをまとめると以下のようになります。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>ユーザーに通知の許可を受け付ける非同期処理がある</p>
</li>
<li>
<p>許可がある場合は <code>new Notification</code> で通知を表示できる</p>
<div class="ulist">
<ul>
<li>
<p>すでに許可済みのケース</p>
</li>
<li>
<p>その場で許可を貰うケース</p>
</li>
</ul>
</div>
</li>
<li>
<p>許可がない場合は何もしない</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>いくつかのパターンが出ますが、最終的には許可か不許可になるので、以下の2パターンにまとめることができます。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">許可時("granted")</dt>
<dd>
<p><code>new Notification</code> で通知を作成</p>
</dd>
<dt class="hdlist1">不許可時("denied")</dt>
<dd>
<p>何もしない</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>この2パターンはどこかで見たことがありますね。
そう、PromiseのFulfilled または Rejected となった時の動作で書くことが出来そうな気がします。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">resolve(成功)した時 == 許可時("granted")</dt>
<dd>
<p><code>onFulfilled</code> が呼ばれる</p>
</dd>
<dt class="hdlist1">reject(失敗)した時 == 不許可時("denied")</dt>
<dd>
<p><code>onRejected</code>  が呼ばれる</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Promiseで書けそうな目処が見えた所で、まずはコールバックスタイルで書いてみましょう。</p>
</div>
</div>
<div class="sect3">
<h4 id="_web_notification_ラッパー">4.2.2. Web Notification ラッパー</h4>
<div class="paragraph">
<p>まずは先ほどのWeb Notification APIのラッパー関数をコールバックスタイルで書くと次のように書くことができます。</p>
</div>
<div id="notification-callback.js" class="listingblock executable">
<div class="title">notification-callback.js</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript"><span class="keyword">function</span> <span class="function">notifyMessage</span>(message, options, callback) {
    <span class="keyword">if</span> (<span class="keyword">typeof</span> Notification === <span class="string"><span class="delimiter">&quot;</span><span class="content">undefined</span><span class="delimiter">&quot;</span></span>) {
        callback(<span class="keyword">new</span> Error(<span class="string"><span class="delimiter">&quot;</span><span class="content">doesn't support Notification API</span><span class="delimiter">&quot;</span></span>));
        <span class="keyword">return</span>;
    }
    <span class="keyword">if</span> (Notification.permission === <span class="string"><span class="delimiter">&quot;</span><span class="content">granted</span><span class="delimiter">&quot;</span></span>) {
        const notification = <span class="keyword">new</span> Notification(message, options);
        callback(<span class="predefined-constant">null</span>, notification);
    } <span class="keyword">else</span> {
        Notification.requestPermission((status) =&gt; {
            <span class="keyword">if</span> (Notification.permission !== status) {
                Notification.permission = status;
            }
            <span class="keyword">if</span> (status === <span class="string"><span class="delimiter">&quot;</span><span class="content">granted</span><span class="delimiter">&quot;</span></span>) {
                const notification = <span class="keyword">new</span> Notification(message, options);
                callback(<span class="predefined-constant">null</span>, notification);
            } <span class="keyword">else</span> {
                callback(<span class="keyword">new</span> Error(<span class="string"><span class="delimiter">&quot;</span><span class="content">user denied</span><span class="delimiter">&quot;</span></span>));
            }
        });
    }
}

<span class="comment">// 実行例</span>
<span class="comment">// 第二引数は `Notification` に渡すオプションオブジェクト</span>
notifyMessage(<span class="string"><span class="delimiter">&quot;</span><span class="content">Hi!</span><span class="delimiter">&quot;</span></span>, {}, <span class="keyword">function</span> (error, notification) {
    <span class="keyword">if</span>(error){
        console.error(error);
        <span class="keyword">return</span>;
    }
    console.log(notification);<span class="comment">// 通知のオブジェクト</span>
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>コールバックスタイルでは、許可がない場合は <code>error</code> に値が入り、
許可がある場合は通知が行われて <code>notification</code> に値が入ってくるという感じにしました。</p>
</div>
<div class="listingblock">
<div class="title">コールバック関数はエラーとnotificationオブジェクトを受け取る</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript"><span class="keyword">function</span> <span class="function">callback</span>(error, notification) {

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>次に、このコールバックスタイルの関数をPromiseとして使える関数を書いてみたいと思います。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p><a href="https://notifications.spec.whatwg.org/">Notifications API</a>の最新仕様では、
コールバック関数を渡さなかった場合にpromiseオブジェクトを返すようになっています。
そのため、ここから先の話は最新の仕様ではもっとシンプルに書ける可能性があります。</p>
</div>
<div class="paragraph">
<p>しかし、古いNotification APIの仕様では、コールバック関数のみしか扱う方法がありませんでした。
ここではコールバック関数のみしか扱えないNotification APIを前提にしています。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_web_notification_as_promise">4.2.3. Web Notification as Promise</h4>
<div class="paragraph">
<p>先ほどのコールバックスタイルの <code>notifyMessage</code> とは別に、
promiseオブジェクトを返す <code>notifyMessageAsPromise</code> を定義してみます。</p>
</div>
<div id="notification-as-promise.js" class="listingblock executable">
<div class="title">notification-as-promise.js</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript"><span class="keyword">function</span> <span class="function">notifyMessage</span>(message, options, callback) {
    <span class="keyword">if</span> (<span class="keyword">typeof</span> Notification === <span class="string"><span class="delimiter">&quot;</span><span class="content">undefined</span><span class="delimiter">&quot;</span></span>) {
        callback(<span class="keyword">new</span> Error(<span class="string"><span class="delimiter">&quot;</span><span class="content">doesn't support Notification API</span><span class="delimiter">&quot;</span></span>));
        <span class="keyword">return</span>;
    }
    <span class="keyword">if</span> (Notification.permission === <span class="string"><span class="delimiter">&quot;</span><span class="content">granted</span><span class="delimiter">&quot;</span></span>) {
        const notification = <span class="keyword">new</span> Notification(message, options);
        callback(<span class="predefined-constant">null</span>, notification);
    } <span class="keyword">else</span> {
        Notification.requestPermission((status) =&gt; {
            <span class="keyword">if</span> (Notification.permission !== status) {
                Notification.permission = status;
            }
            <span class="keyword">if</span> (status === <span class="string"><span class="delimiter">&quot;</span><span class="content">granted</span><span class="delimiter">&quot;</span></span>) {
                const notification = <span class="keyword">new</span> Notification(message, options);
                callback(<span class="predefined-constant">null</span>, notification);
            } <span class="keyword">else</span> {
                callback(<span class="keyword">new</span> Error(<span class="string"><span class="delimiter">&quot;</span><span class="content">user denied</span><span class="delimiter">&quot;</span></span>));
            }
        });
    }
}
<span class="keyword">function</span> <span class="function">notifyMessageAsPromise</span>(message, options) {
    <span class="keyword">return</span> <span class="keyword">new</span> Promise((resolve, reject) =&gt; {
        notifyMessage(message, options, (error, notification) =&gt; {
            <span class="keyword">if</span> (error) {
                reject(error);
            } <span class="keyword">else</span> {
                resolve(notification);
            }
        });
    });
}

<span class="comment">// 実行例</span>
notifyMessageAsPromise(<span class="string"><span class="delimiter">&quot;</span><span class="content">Hi!</span><span class="delimiter">&quot;</span></span>).then(<span class="keyword">function</span> (notification) {
    console.log(notification);<span class="comment">// 通知のオブジェクト</span>
}).<span class="keyword">catch</span>((error) =&gt; {
    console.error(error);
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>上記の実行例では、許可がある場合 <code>"Hi!"</code> という通知が表示されます。</p>
</div>
<div class="paragraph">
<p>許可されている場合は <code>.then</code> が呼ばれ、
不許可となった場合は <code>.catch</code> が呼ばれます。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>ブラウザはWeb Notifications APIの状態をサイトごとに許可状態を記憶できるため、
実際には以下の4つのパターンが存在します。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">すでに許可されている</dt>
<dd>
<p><code>.then</code> が呼ばれる</p>
</dd>
<dt class="hdlist1">許可ダイアログがでて許可された</dt>
<dd>
<p><code>.then</code> が呼ばれる</p>
</dd>
<dt class="hdlist1">すでに不許可となっている</dt>
<dd>
<p><code>.catch</code> が呼ばれる</p>
</dd>
<dt class="hdlist1">許可ダイアログが出て不許可となった</dt>
<dd>
<p><code>.catch</code> が呼ばれる</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>つまり、Web Notifications APIをそのまま扱うと、4つのパターンについて書かないといけませんが、
それを2パターンにできるラッパーを書くと扱いやすくなります。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>上記の<a href="#notification-as-promise.js">notification-as-promise.js</a>は、とても便利そうですが実際に使うときには
<strong>Promiseをサポートしてない環境では使えない</strong>という問題があります。</p>
</div>
<div class="paragraph">
<p><a href="#notification-as-promise.js">notification-as-promise.js</a>のようなPromiseスタイルで使えるライブラリを作る場合、
ライブラリ作成者には以下の選択肢があると思います。</p>
</div>
<div id="promise-library-choice" class="dlist">
<dl>
<dt class="hdlist1">Promiseが使える環境を前提とする</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>利用者に <code>Promise</code> があることを保証してもらう</p>
</li>
<li>
<p>Promiseをサポートしてない環境では動かないことにする</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">ライブラリ自体に <code>Promise</code> の実装を入れてしまう</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>ライブラリ自体にPromiseの実装を取り込む</p>
</li>
<li>
<p>例) <a href="https://github.com/mozilla/localForage">localForage</a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">コールバックでも <code>Promise</code> でも使えるようにする</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>利用者がどちらを使うかを選択できるようにする</p>
</li>
<li>
<p>Thenableを返せるようにする</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
<div class="paragraph">
<p><a href="#notification-as-promise.js">notification-as-promise.js</a>は <code>Promise</code> があることを前提としたような書き方です。</p>
</div>
<div class="paragraph">
<p>本題に戻り<a href="#Thenable">Thenable</a>はここでいう<strong>コールバックでも <code>Promise</code> でも使えるようにする</strong>ということを
実現するのに役立つ概念です。</p>
</div>
</div>
<div class="sect3">
<h4 id="_web_notifications_as_thenable">4.2.4. Web Notifications As Thenable</h4>
<div class="paragraph">
<p><a href="#Thenable">thenable</a>というのは <code>.then</code> というメソッドを持ってるオブジェクトのことを言いましたね。
次は<a href="#notification-callback.js">notification-callback.js</a>に <code>thenable</code> を返すメソッドを追加してみましょう。</p>
</div>
<div id="notification-thenable.js" class="listingblock executable">
<div class="title">notification-thenable.js</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript"><span class="keyword">function</span> <span class="function">notifyMessage</span>(message, options, callback) {
    <span class="keyword">if</span> (<span class="keyword">typeof</span> Notification === <span class="string"><span class="delimiter">&quot;</span><span class="content">undefined</span><span class="delimiter">&quot;</span></span>) {
        callback(<span class="keyword">new</span> Error(<span class="string"><span class="delimiter">&quot;</span><span class="content">doesn't support Notification API</span><span class="delimiter">&quot;</span></span>));
        <span class="keyword">return</span>;
    }
    <span class="keyword">if</span> (Notification.permission === <span class="string"><span class="delimiter">&quot;</span><span class="content">granted</span><span class="delimiter">&quot;</span></span>) {
        const notification = <span class="keyword">new</span> Notification(message, options);
        callback(<span class="predefined-constant">null</span>, notification);
    } <span class="keyword">else</span> {
        Notification.requestPermission((status) =&gt; {
            <span class="keyword">if</span> (Notification.permission !== status) {
                Notification.permission = status;
            }
            <span class="keyword">if</span> (status === <span class="string"><span class="delimiter">&quot;</span><span class="content">granted</span><span class="delimiter">&quot;</span></span>) {
                const notification = <span class="keyword">new</span> Notification(message, options);
                callback(<span class="predefined-constant">null</span>, notification);
            } <span class="keyword">else</span> {
                callback(<span class="keyword">new</span> Error(<span class="string"><span class="delimiter">&quot;</span><span class="content">user denied</span><span class="delimiter">&quot;</span></span>));
            }
        });
    }
}
<span class="comment">// `thenable` を返す</span>
<span class="keyword">function</span> <span class="function">notifyMessageAsThenable</span>(message, options) {
    <span class="keyword">return</span> {
        <span class="key"><span class="delimiter">&quot;</span><span class="content">then</span><span class="delimiter">&quot;</span></span>: <span class="keyword">function</span>(resolve, reject) {
            notifyMessage(message, options, (error, notification) =&gt; {
                <span class="keyword">if</span> (error) {
                    reject(error);
                } <span class="keyword">else</span> {
                    resolve(notification);
                }
            });
        }
    };
}
<span class="comment">// 実行例</span>
Promise.resolve(notifyMessageAsThenable(<span class="string"><span class="delimiter">&quot;</span><span class="content">message</span><span class="delimiter">&quot;</span></span>)).then(<span class="keyword">function</span> (notification) {
    console.log(notification);<span class="comment">// 通知のオブジェクト</span>
}).<span class="keyword">catch</span>((error) =&gt; {
    console.error(error);
});</code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="#notification-thenable.js">notification-thenable.js</a> には <code>notifyMessageAsThenable</code> というそのままのメソッドを追加してみました。
返すオブジェクトには <code>then</code> というメソッドがあります。</p>
</div>
<div class="paragraph">
<p><code>then</code> メソッドの仮引数には <code>new Promise(function (resolve, reject){})</code> と同じように、
解決した時に呼ぶ <code>resolve</code> と、棄却した時に呼ぶ <code>reject</code> が渡ります。</p>
</div>
<div class="paragraph">
<p><code>then</code> メソッドがやっている中身は<a href="#notification-as-promise.js">notification-as-promise.js</a>の <code>notifyMessageAsPromise</code> と同じですね。</p>
</div>
<div class="paragraph">
<p>この <code>thenable</code> を <code>Promise.resolve(thenable)</code> を使いpromiseオブジェクトにしてから、
Promiseとして利用していることが分かりますね。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript">Promise.resolve(notifyMessageAsThenable(<span class="string"><span class="delimiter">&quot;</span><span class="content">message</span><span class="delimiter">&quot;</span></span>)).then((notification) =&gt; {
    console.log(notification);<span class="comment">// 通知のオブジェクト</span>
}).<span class="keyword">catch</span>((error) =&gt; {
    console.error(error);
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>Thenableを使った<a href="#notification-thenable.js">notification-thenable.js</a>とPromiseに依存した<a href="#notification-as-promise.js">notification-as-promise.js</a>は、
非常に似た使い方ができることがわかります。</p>
</div>
<div class="paragraph">
<p><a href="#notification-thenable.js">notification-thenable.js</a>には<a href="#notification-as-promise.js">notification-as-promise.js</a>と比べた時に、次のような違いがあります。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>ライブラリ側に <code>Promise</code> 実装そのものはでてこない</p>
<div class="ulist">
<ul>
<li>
<p>利用者が <code>Promise.resolve(thenable)</code> を使い <code>Promise</code> の実装を与える</p>
</li>
</ul>
</div>
</li>
<li>
<p>Promiseとして使う時に <code>Promise.resolve(thenable)</code> と一枚挟む必要がある</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><a href="#Thenable">Thenable</a>オブジェクトを利用することで、
既存のコールバックスタイルとPromiseスタイルの中間的な実装をすることができました。</p>
</div>
</div>
<div class="sect3">
<h4 id="_まとめ_6">4.2.5. まとめ</h4>
<div class="paragraph">
<p>このセクションではThenableとは何かやThenableを <code>Promise.resolve(thenable)</code> を使って、
promiseオブジェクトとして利用する方法について学びました。</p>
</div>
<div class="paragraph">
<p>Callback&#8201;&#8212;&#8201;Thenable&#8201;&#8212;&#8201;Promise</p>
</div>
<div class="paragraph">
<p>Thenableスタイルは、コールバックスタイルとPromiseスタイルの中間的な表現で、
ライブラリが公開するAPIとしては中途半端なためあまり見かけることがないと思います。</p>
</div>
<div class="paragraph">
<p>Thenable自体は <code>Promise</code> という機能に依存してはいませんが、Promise以外からの利用方法は特にないため、
間接的にはPromiseに依存しています。</p>
</div>
<div class="paragraph">
<p>また、使うためには利用者が <code>Promise.resolve(thenable)</code> について理解している必要があるため、
ライブラリの公開APIとしては難しい部分があります。
Thenable自体は公開APIより、内部的に使われてるケースが多いでしょう。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>非同期処理を行うライブラリを書く際には、まずはコールバックスタイルの関数を書いて公開APIとすることをオススメします。</p>
</div>
<div class="paragraph">
<p>Node.jsのCore moduleがこの方法をとっているように、ライブラリが提供するのは基本となるコールバックスタイル関数としたほうが、
利用者がPromiseやGenerator等の好きな方法で実装ができるためです。</p>
</div>
<div class="paragraph">
<p>最初からPromiseで利用することを目的としたライブラリや、その機能がPromiseに依存している場合は、
promiseオブジェクトを返す関数を公開APIとしても問題ないと思います。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="_thenableの使われているところ">Thenableの使われているところ</h5>
<div class="paragraph">
<p>では、どのような場面でThenableは使われてるのでしょうか?</p>
</div>
<div class="paragraph">
<p>恐らく、一番多く使われている所は<a href="#promise-library">Promiseのライブラリ</a>間での相互変換でしょう。</p>
</div>
<div class="paragraph">
<p>たとえば、 QライブラリのPromiseのインスタンスであるQ promiseオブジェクトは、
<a href="#es-promises">ES Promises</a>のpromiseオブジェクトが持っていないメソッドを持っています。
Q promiseオブジェクトには <code>promise.finally(callback)</code> や <code>promise.nodeify(callback)</code> などのメソッドが用意されてます。</p>
</div>
<div class="paragraph">
<p>ES PromisesのpromiseオブジェクトをQ promiseオブジェクトに変換するときに使われるのが、
まさにこのThenableです。</p>
</div>
<div class="listingblock">
<div class="title">thenableを使ってQ promiseオブジェクトにする</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript">const Q = require(<span class="string"><span class="delimiter">&quot;</span><span class="content">Q</span><span class="delimiter">&quot;</span></span>);
<span class="comment">// このpromiseオブジェクトはESのもの</span>
const promise = <span class="keyword">new</span> Promise((resolve) =&gt; {
    resolve(<span class="integer">1</span>);
});
<span class="comment">// Q promiseオブジェクトに変換する</span>
Q(promise).then((value) =&gt; {
    console.log(value);
}).<span class="keyword">finally</span>(() =&gt; { <i class="conum" data-value="1"></i><b>(1)</b>
    console.log(<span class="string"><span class="delimiter">&quot;</span><span class="content">finally</span><span class="delimiter">&quot;</span></span>);
});</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Q promiseオブジェクトとなったため <code>finally</code> が利用できる</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>最初に作成したpromiseオブジェクトは <code>then</code> というメソッドを持っているので、もちろんThenableです。
<code>Q(thenable)</code> とすることでThenableなオブジェクトをQ promiseオブジェクトへと変換することができます。</p>
</div>
<div class="paragraph">
<p>これは、<code>Promise.resolve(thenable)</code> と同じ仕組みといえるので、もちろん逆も可能です。</p>
</div>
<div class="paragraph">
<p>このように、Promiseライブラリはそれぞれ独自に拡張したpromiseオブジェクトを持っていますが、
Thenableという共通の概念を使うことでライブラリ間(もちろんネイティブPromiseも含めて)で相互にpromiseオブジェクトを変換することができます。</p>
</div>
<div class="paragraph">
<p>このようにThenableが使われる所の多くはライブラリ内部の実装であるため、あまり目にする機会はないかもしれません。
しかしこのThenableはPromiseでも大事な概念であるため知っておくとよいでしょう。</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="not-throw-use-reject">4.3. throwしないで、rejectしよう</h3>
<div class="paragraph">
<p>Promiseコンストラクタや、<code>then</code> で実行される関数は基本的に、
<code>try&#8230;&#8203;catch</code> で囲まれてるような状態なので、その中で <code>throw</code> してもプログラムは終了しません。</p>
</div>
<div class="paragraph">
<p>Promiseの中で <code>throw</code> による例外が発生した場合は自動的に <code>try&#8230;&#8203;catch</code> され、そのpromiseオブジェクトはRejectedとなります。</p>
</div>
<div class="listingblock executable">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript">const promise = <span class="keyword">new</span> Promise((resolve, reject) =&gt; {
    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string"><span class="delimiter">&quot;</span><span class="content">message</span><span class="delimiter">&quot;</span></span>);
});
promise.<span class="keyword">catch</span>((error) =&gt; {
    console.error(error);<span class="comment">// =&gt; &quot;message&quot;</span>
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>このように書いても動作的には問題ありませんが、<a href="#promise-states">promiseオブジェクトの状態</a>をRejectedにしたい場合は
<code>reject</code> という与えられた関数を呼び出すのが一般的です。</p>
</div>
<div class="paragraph">
<p>先ほどのコードは以下のように書くことができます。</p>
</div>
<div class="listingblock executable">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript">const promise = <span class="keyword">new</span> Promise((resolve, reject) =&gt; {
    reject(<span class="keyword">new</span> Error(<span class="string"><span class="delimiter">&quot;</span><span class="content">message</span><span class="delimiter">&quot;</span></span>));
});
promise.<span class="keyword">catch</span>((error) =&gt; {
    console.error(error);<span class="comment">// =&gt; &quot;message&quot;</span>
});</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>throw</code> が <code>reject</code> に変わったと考えれば、<code>reject</code> にはErrorオブジェクトを渡すべきであるということが分かりやすいかもしれません。</p>
</div>
<div class="sect3">
<h4 id="_なぜrejectした方がいいのか">4.3.1. なぜrejectした方がいいのか</h4>
<div class="paragraph">
<p>そもそも、promiseオブジェクトの状態をRejectedにしたい場合に、
なぜ <code>throw</code> ではなく <code>reject</code> した方がいいのでしょうか?</p>
</div>
<div class="paragraph">
<p>ひとつは <code>throw</code> が意図したものか、それとも本当に<strong>例外</strong>なのか区別が難しくなってしまうことにあります。</p>
</div>
<div class="paragraph">
<p>たとえば、Chrome等の開発者ツールには例外が発生した時に、
デバッガーが自動でbreakする機能が用意されています。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="Ch4_AdvancedPromises/img/chrome_on_caught_exception.png" alt="Pause On Caught Exceptions">
</div>
<div class="title">Figure 12. Pause On Caught Exceptions</div>
</div>
<div class="paragraph">
<p>この機能を有効にしていた場合、以下のように <code>throw</code> するとbreakしてしまいます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript">const promise = <span class="keyword">new</span> Promise((resolve, reject) =&gt; {
    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string"><span class="delimiter">&quot;</span><span class="content">message</span><span class="delimiter">&quot;</span></span>);
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>本来デバッグとは関係ない場所でbreakしてしまうため、
Promiseの中で <code>throw</code> している箇所があると、この機能が殆ど使い物にならなくなってしまうでしょう。</p>
</div>
</div>
<div class="sect3">
<h4 id="_thenでもrejectする">4.3.2. thenでもrejectする</h4>
<div class="paragraph">
<p>Promiseコンストラクタの中では <code>reject</code> という関数そのものがあるので、
<code>throw</code> を使わないでpromiseオブジェクトをRejectedにするのは簡単でした。</p>
</div>
<div class="paragraph">
<p>では、次のような <code>then</code> の中でrejectしたい場合はどうすればいいでしょうか?</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript">const promise = Promise.resolve();
promise.then((value) =&gt; {
    setTimeout(() =&gt; {
        <span class="comment">// 一定時間経って終わらなかったらrejectしたい - 2</span>
    }, <span class="integer">1000</span>);
    <span class="comment">// 時間がかかる処理 - 1</span>
    somethingHardWork();
}).<span class="keyword">catch</span>((error) =&gt; {
    <span class="comment">// タイムアウトエラー - 3</span>
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>いわゆるタイムアウト処理ですが、<code>then</code> の中で <code>reject</code> を呼びたいと思った場合に、
コールバック関数に渡ってくるのは一つ前のpromiseオブジェクトの返した値だけなので困ってしまいます。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Promiseを使ったタイムアウト処理の実装については <a href="#race-delay-timeout">Promise.raceとdelayによるXHRのキャンセル</a> にて詳しく解説しています。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>ここで少し <code>then</code> の挙動について思い出してみましょう。</p>
</div>
<div class="paragraph">
<p><code>then</code> に登録するコールバック関数では値を <code>return</code> することができます。
このときreturnした値が、次の <code>then</code> や <code>catch</code> のコールバックに渡されます。</p>
</div>
<div class="paragraph">
<p>また、returnするものはプリミティブな値に限らずオブジェクト、そしてpromiseオブジェクトも返すことができます。</p>
</div>
<div class="paragraph">
<p>このとき、returnしたものがpromiseオブジェクトである場合、そのpromiseオブジェクトの状態によって、
次の <code>then</code> に登録されたonFulfilledとonRejectedのうち、どちらが呼ばれるかを決めることができます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript">const promise = Promise.resolve();
promise.then(() =&gt; {
    const retPromise = <span class="keyword">new</span> Promise((resolve, reject) =&gt; {
        <span class="comment">// resolve or reject で onFulfilled or onRejected どちらを呼ぶか決まる</span>
    });
    <span class="keyword">return</span> retPromise;<i class="conum" data-value="1"></i><b>(1)</b>
}).then(onFulfilled, onRejected);</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>次に呼び出されるthenのコールバックはpromiseオブジェクトの状態によって決定される</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>つまり、この <code>retPromise</code> がRejectedになった場合は、<code>onRejected</code> が呼び出されるので、
<code>throw</code> を使わなくても <code>then</code> の中でrejectすることができます。</p>
</div>
<div class="listingblock executable">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript">const onRejected = console.error.bind(console);
const promise = Promise.resolve();
promise.then(() =&gt; {
    const retPromise = <span class="keyword">new</span> Promise((resolve, reject) =&gt; {
        reject(<span class="keyword">new</span> Error(<span class="string"><span class="delimiter">&quot;</span><span class="content">this promise is rejected</span><span class="delimiter">&quot;</span></span>));
    });
    <span class="keyword">return</span> retPromise;
}).<span class="keyword">catch</span>(onRejected);</code></pre>
</div>
</div>
<div class="paragraph">
<p>これは、<a href="#Promise.reject">Promise.reject</a> を使うことでもっと簡潔に書くことができます。</p>
</div>
<div class="listingblock executable">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript">const onRejected = console.error.bind(console);
const promise = Promise.resolve();
promise.then(() =&gt; {
    <span class="keyword">return</span> Promise.reject(<span class="keyword">new</span> Error(<span class="string"><span class="delimiter">&quot;</span><span class="content">this promise is rejected</span><span class="delimiter">&quot;</span></span>));
}).<span class="keyword">catch</span>(onRejected);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_まとめ_7">4.3.3. まとめ</h4>
<div class="paragraph">
<p>このセクションでは、以下のことについて学びました。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>throw</code> ではなくて <code>reject</code> した方が安全</p>
</li>
<li>
<p><code>then</code> の中でも <code>reject</code> する方法</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>中々使いどころが多くはないかもしれませんが、安易に <code>throw</code> してしまうよりはいいことが多いので、
覚えておくといいでしょう。</p>
</div>
<div class="paragraph">
<p>これを利用した具体的な例としては、
<a href="#race-delay-timeout">Promise.raceとdelayによるXHRのキャンセル</a> で解説しています。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="deferred-and-promise">4.4. DeferredとPromise</h3>
<div class="paragraph">
<p>このセクションではDeferredとPromiseの関係について簡潔に学んでいきます。</p>
</div>
<div class="sect3">
<h4 id="_deferredとは何か">4.4.1. Deferredとは何か</h4>
<div class="paragraph">
<p>Deferredという単語はPromiseと同じコンテキストで聞いたことがあるかもしれません。
有名な所だと <a href="http://api.jquery.com/category/deferred-object/">jQuery.Deferred</a> や <a href="http://cho45.stfuawsc.com/jsdeferred/">JSDeferred</a> 等があげられるでしょう。</p>
</div>
<div class="paragraph">
<p>DeferredはPromiseと違い、共通の仕様があるわけではなく、各ライブラリがそのような目的の実装をそう呼んでいます。</p>
</div>
<div class="paragraph">
<p>今回は <a href="http://api.jquery.com/category/deferred-object/">jQuery.Deferred</a> のようなDeferredの実装を中心にして話を進めます。</p>
</div>
</div>
<div class="sect3">
<h4 id="_deferredとpromiseの関係">4.4.2. DeferredとPromiseの関係</h4>
<div class="paragraph">
<p>DeferredとPromiseの関係を簡単に書くと以下のようになります。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Deferred は Promiseを持っている</p>
</li>
<li>
<p>Deferred は Promiseの状態を操作する特権的なメソッドを持っている</p>
</li>
</ul>
</div>
<div class="imageblock">
<div class="content">
<img src="Ch4_AdvancedPromises/img/deferred-and-promise.png" alt="DeferredとPromise">
</div>
<div class="title">Figure 13. DeferredとPromise</div>
</div>
<div class="paragraph">
<p>この図を見ると分かりますが、DeferredとPromiseは比べるような関係ではなく、
DeferredがPromiseを内蔵しているような関係になっていることが分かります。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
jQuery.Deferredの構造を簡略化したものです。Promiseを使わないDeferredの実装もあります。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>図だけだと分かりにくいので、実際にPromiseを使ってDeferredクラスを実装してみましょう。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>ECMAScript 2015ではクラスを定義する <code>class</code> 構文が導入されています。
<code>class</code> 構文を使ったクラス定義については、次のページを参照してください。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Classes">クラス - JavaScript | MDN</a></p>
</li>
<li>
<p><a href="https://jsprimer.net/basic/class/">クラス · JavaScript Primer #jsprimer</a></p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_deferred_top_on_promise">4.4.3. Deferred top on Promise</h4>
<div class="paragraph">
<p>Promiseの上にDeferredクラスを実装した例です。</p>
</div>
<div id="deferred.js" class="listingblock">
<div class="title">deferred.js</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript"><span class="reserved">class</span> Deferred {
    constructor() {
        <span class="local-variable">this</span>.promise = <span class="keyword">new</span> Promise((resolve, reject) =&gt; {
            <span class="comment">// Arrow Functionを利用しているため、`this`がDeferredのインスタンスを参照する</span>
            <span class="local-variable">this</span>._resolve = resolve;
            <span class="local-variable">this</span>._reject = reject;
        });
    }

    <span class="comment">// Deferred#resolveメソッドは、`value`でPromiseインスタンスをresolveする</span>
    resolve(value) {
        <span class="local-variable">this</span>._resolve(value);
    }

    <span class="comment">// Deferred#rejectメソッドは、`reason`でPromiseインスタンスをrejectする</span>
    reject(reason) {
        <span class="local-variable">this</span>._reject(reason);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>以前Promiseを使って実装した<a href="#xhr-promise.js"><code>fetchURL</code></a>をこのDeferredで実装しなおしてみます。</p>
</div>
<div id="xhr-deferred.js" class="listingblock executable">
<div class="title">xhr-deferred.js</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript"><span class="reserved">class</span> Deferred {
    constructor() {
        <span class="local-variable">this</span>.promise = <span class="keyword">new</span> Promise((resolve, reject) =&gt; {
            <span class="comment">// Arrow Functionを利用しているため、`this`がDeferredのインスタンスを参照する</span>
            <span class="local-variable">this</span>._resolve = resolve;
            <span class="local-variable">this</span>._reject = reject;
        });
    }

    <span class="comment">// Deferred#resolveメソッドは、`value`でPromiseインスタンスをresolveする</span>
    resolve(value) {
        <span class="local-variable">this</span>._resolve(value);
    }

    <span class="comment">// Deferred#rejectメソッドは、`reason`でPromiseインスタンスをrejectする</span>
    reject(reason) {
        <span class="local-variable">this</span>._reject(reason);
    }
}
<span class="keyword">function</span> <span class="function">fetchURL</span>(URL) {
    const deferred = <span class="keyword">new</span> Deferred();
    const req = <span class="keyword">new</span> XMLHttpRequest();
    req.open(<span class="string"><span class="delimiter">&quot;</span><span class="content">GET</span><span class="delimiter">&quot;</span></span>, URL, <span class="predefined-constant">true</span>);
    req.onload = () =&gt; {
        <span class="keyword">if</span> (<span class="integer">200</span> &lt;= req.status &amp;&amp; req.status &lt; <span class="integer">300</span>) {
            deferred.resolve(req.responseText);
        } <span class="keyword">else</span> {
            deferred.reject(<span class="keyword">new</span> Error(req.statusText));
        }
    };
    req.onerror = () =&gt; {
        deferred.reject(<span class="keyword">new</span> Error(req.statusText));
    };
    req.send();
    <span class="keyword">return</span> deferred.promise;
}

<span class="comment">// 実行例</span>
const URL = <span class="string"><span class="delimiter">&quot;</span><span class="content">https://httpbin.org/get</span><span class="delimiter">&quot;</span></span>;
fetchURL(URL).then(<span class="keyword">function</span> <span class="function">onFulfilled</span>(value){
    console.log(value);
}).<span class="keyword">catch</span>(console.error.bind(console));</code></pre>
</div>
</div>
<div class="paragraph">
<p>Promiseの状態を操作する特権的なメソッドというのは、
promiseオブジェクトの状態をresolve、rejectすることができるメソッドで、
通常のPromiseだとコンストラクタで渡した関数の中でしか操作することができません。</p>
</div>
<div class="paragraph">
<p>通常のPromiseで実装したものと見比べていきたいと思います。</p>
</div>
<div class="listingblock executable">
<div class="title">xhr-promise.js</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript"><span class="keyword">function</span> <span class="function">fetchURL</span>(URL) {
    <span class="keyword">return</span> <span class="keyword">new</span> Promise((resolve, reject) =&gt; {
        const req = <span class="keyword">new</span> XMLHttpRequest();
        req.open(<span class="string"><span class="delimiter">&quot;</span><span class="content">GET</span><span class="delimiter">&quot;</span></span>, URL, <span class="predefined-constant">true</span>);
        req.onload = () =&gt; {
            <span class="keyword">if</span> (<span class="integer">200</span> &lt;= req.status &amp;&amp; req.status &lt; <span class="integer">300</span>) {
                resolve(req.responseText);
            } <span class="keyword">else</span> {
                reject(<span class="keyword">new</span> Error(req.statusText));
            }
        };
        req.onerror = () =&gt; {
            reject(<span class="keyword">new</span> Error(req.statusText));
        };
        req.send();
    });
}

<span class="comment">// 実行例</span>
const URL = <span class="string"><span class="delimiter">&quot;</span><span class="content">https://httpbin.org/get</span><span class="delimiter">&quot;</span></span>;
fetchURL(URL).then(<span class="keyword">function</span> <span class="function">onFulfilled</span>(value){
    console.log(value);
}).<span class="keyword">catch</span>(console.error.bind(console));</code></pre>
</div>
</div>
<div class="paragraph">
<p>2つの <code>fetchURL</code> を見比べて見ると以下のような違いがあることが分かります。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Deferred の場合は全体がPromiseで囲まれていない</p>
<div class="ulist">
<ul>
<li>
<p>関数で囲んでないため、1段ネストが減っている</p>
</li>
<li>
<p>Promiseコンストラクタの中で処理が行われていないため、自動的に例外をキャッチしない</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>逆に以下の部分は同じことをやっています。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>全体的な処理の流れ</p>
<div class="ulist">
<ul>
<li>
<p><code>resolve</code>、<code>reject</code> を呼ぶタイミング</p>
</li>
</ul>
</div>
</li>
<li>
<p>関数はpromiseオブジェクトを返す</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>このDeferredはPromiseを持っているため、大きな流れは同じですが、
Deferredには特権的なメソッドを持っていることや自分で流れを制御する裁量が大きいことが分かります。</p>
</div>
<div class="paragraph">
<p>たとえば、Promiseの場合はコンストラクタの中に処理を書くことが通例なので、
<code>resolve</code>、<code>reject</code> を呼ぶタイミングが大体みて分かります。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript"><span class="keyword">new</span> Promise((resolve, reject) =&gt; {
    <span class="comment">// この中に解決する処理を書く</span>
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>一方Deferredの場合は、関数的なまとまりはないのでdeferredオブジェクトを作ったところから、
任意のタイミングで <code>resolve</code>、<code>reject</code> を呼ぶ感じになります。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript">const deferred = <span class="keyword">new</span> Deferred();

<span class="comment">// どこかのタイミングでdeferred.resolve or deferred.rejectを呼ぶ</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>このように小さな<strong>Deferred</strong>の実装ですが<strong>Promise</strong>との違いが出ていることが分かります。</p>
</div>
<div class="paragraph">
<p>これは、Promiseが値を抽象化したオブジェクトなのに対して、
Deferredはまだ処理が終わってないという状態や操作を抽象化したオブジェクトである違いがでているのかもしれません。</p>
</div>
<div class="paragraph">
<p>言い換えると、
Promiseはこの値は将来的に正常な値(Fulfilled)か異常な値(Rejected)が入るというものを予約したオブジェクトなのに対して、
Deferredはまだ処理が終わってないということを表すオブジェクトで、
処理が終わった時の結果を取得する機構(Promise)に加えて処理を進める機構をもったものといえるかもしれません。</p>
</div>
<div class="paragraph">
<p>より詳しくDeferredについて知りたい人は以下を参照するといいでしょう。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="http://blog.mediumequalsmessage.com/promise-deferred-objects-in-javascript-pt1-theory-and-semantics">Promise &amp; Deferred objects in JavaScript Pt.1: Theory and Semantics.</a></p>
</li>
<li>
<p><a href="http://skitazaki.appspot.com/translation/twisted-intro-ja/index.html">Twisted 入門 — Twisted Intro</a></p>
</li>
<li>
<p><a href="https://github.com/petkaantonov/bluebird/wiki/Promise-anti-patterns#the-deferred-anti-pattern">Promise anti patterns · petkaantonov/bluebird Wiki</a></p>
</li>
<li>
<p><a href="https://github.com/kriskowal/q/wiki/Coming-from-jQuery">Coming from jQuery · kriskowal/q Wiki</a></p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>DeferredはPythonの <a href="https://twistedmatrix.com/trac/">Twisted</a> というフレームワークが最初に定義した概念です。
JavaScriptへは <a href="http://mochi.github.io/mochikit/doc/html/MochiKit/Async.html">MochiKit.Async</a> 、 <a href="http://dojotoolkit.org/reference-guide/1.9/dojo/Deferred.html">dojo/Deferred</a> 等のライブラリがその概念を持ってきたと言われています。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="race-delay-timeout">4.5. Promise.raceとdelayによるXHRのキャンセル</h3>
<div class="paragraph">
<p>このセクションでは<a href="#ch2-promise-race">2章</a>で紹介した<a href="#Promise.race"><code>Promise.race</code></a>のユースケースとして、
Promise.raceを使ったタイムアウトの実装を学んでいきます。</p>
</div>
<div class="paragraph">
<p>もちろんXHRは <a href="https://developer.mozilla.org/ja/docs/XMLHttpRequest/Synchronous_and_Asynchronous_Requests">timeout</a> プロパティを持っているので、
これを利用すると簡単にできますが、複数のXHRを束ねたタイムアウトや他の機能でも応用が効くため、
分かりやすい非同期処理であるXHRにおけるタイムアウトによるキャンセルを例にしています。</p>
</div>
<div class="sect3">
<h4 id="_promiseで一定時間待つ">4.5.1. Promiseで一定時間待つ</h4>
<div class="paragraph">
<p>まずはタイムアウトをPromiseでどう実現するかを見ていきたいと思います。</p>
</div>
<div class="paragraph">
<p>タイムアウトというのは一定時間経ったら何かするという処理なので、<code>setTimeout</code> を使えばいいことが分かりますね。</p>
</div>
<div class="paragraph">
<p>まずは単純に <code>setTimeout</code> をPromiseでラップした関数を作ってみましょう。</p>
</div>
<div id="delayPromise.js" class="listingblock">
<div class="title">delayPromise.js</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript"><span class="keyword">function</span> <span class="function">delayPromise</span>(ms) {
    <span class="keyword">return</span> <span class="keyword">new</span> Promise((resolve) =&gt; {
        setTimeout(resolve, ms);
    });
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>delayPromise(ms)</code> は引数で指定したミリ秒後にonFulfilledを呼ぶpromiseオブジェクトを返すので、
通常の <code>setTimeout</code> を直接使ったものと比較すると以下のように書けるだけの違いです。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript">setTimeout(() =&gt; {
    alert(<span class="string"><span class="delimiter">&quot;</span><span class="content">100ms 経ったよ!</span><span class="delimiter">&quot;</span></span>);
}, <span class="integer">100</span>);
<span class="comment">// == ほぼ同様の動作</span>
delayPromise(<span class="integer">100</span>).then(() =&gt; {
    alert(<span class="string"><span class="delimiter">&quot;</span><span class="content">100ms 経ったよ!</span><span class="delimiter">&quot;</span></span>);
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>ここでは<strong>promiseオブジェクト</strong>であるということが重要になってくるので覚えておいて下さい。</p>
</div>
</div>
<div class="sect3">
<h4 id="_promise_raceでタイムアウト">4.5.2. Promise.raceでタイムアウト</h4>
<div class="paragraph">
<p><code>Promise.race</code> について簡単に振り返ると、
以下のようにどれか一つでもpromiseオブジェクトが解決状態になったら次の処理を実行する静的メソッドでした。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript">const winnerPromise = <span class="keyword">new</span> Promise((resolve) =&gt; {
    setTimeout(() =&gt; {
        console.log(<span class="string"><span class="delimiter">&quot;</span><span class="content">this is winner</span><span class="delimiter">&quot;</span></span>);
        resolve(<span class="string"><span class="delimiter">&quot;</span><span class="content">this is winner</span><span class="delimiter">&quot;</span></span>);
    }, <span class="integer">4</span>);
});
const loserPromise = <span class="keyword">new</span> Promise((resolve) =&gt; {
    setTimeout(() =&gt; {
        console.log(<span class="string"><span class="delimiter">&quot;</span><span class="content">this is loser</span><span class="delimiter">&quot;</span></span>);
        resolve(<span class="string"><span class="delimiter">&quot;</span><span class="content">this is loser</span><span class="delimiter">&quot;</span></span>);
    }, <span class="integer">1000</span>);
});

<span class="comment">// 一番最初のものがresolveされた時点で終了</span>
Promise.race([winnerPromise, loserPromise]).then((value) =&gt; {
    console.log(value); <span class="comment">// =&gt; 'this is winner'</span>
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>先ほどの<a href="#delayPromise.js">delayPromise</a>と別のpromiseオブジェクトを、
<code>Promise.race</code> によって競争させることで簡単にタイムアウトが実装できます。</p>
</div>
<div id="simple-timeout-promise.js" class="listingblock">
<div class="title">simple-timeout-promise.js</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript"><span class="keyword">function</span> <span class="function">delayPromise</span>(ms) {
    <span class="keyword">return</span> <span class="keyword">new</span> Promise((resolve) =&gt; {
        setTimeout(resolve, ms);
    });
}
<span class="keyword">function</span> <span class="function">timeoutPromise</span>(promise, ms) {
    const timeout = delayPromise(ms).then(() =&gt; {
        <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string"><span class="delimiter">&quot;</span><span class="content">Operation timed out after </span><span class="delimiter">&quot;</span></span> + ms + <span class="string"><span class="delimiter">&quot;</span><span class="content"> ms</span><span class="delimiter">&quot;</span></span>);
    });
    <span class="keyword">return</span> Promise.race([promise, timeout]);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>timeoutPromise(比較対象のpromise, ms)</code> はタイムアウト処理を入れたい
promiseオブジェクトとタイムアウトの時間を受け取り、<code>Promise.race</code> により競争させたpromiseオブジェクトを返します。</p>
</div>
<div class="paragraph">
<p><code>timeoutPromise</code> を使うことで以下のようにタイムアウト処理を書くことができるようになります。</p>
</div>
<div class="listingblock executable">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript"><span class="keyword">function</span> <span class="function">delayPromise</span>(ms) {
    <span class="keyword">return</span> <span class="keyword">new</span> Promise((resolve) =&gt; {
        setTimeout(resolve, ms);
    });
}
<span class="keyword">function</span> <span class="function">timeoutPromise</span>(promise, ms) {
    const timeout = delayPromise(ms).then(() =&gt; {
        <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string"><span class="delimiter">&quot;</span><span class="content">Operation timed out after </span><span class="delimiter">&quot;</span></span> + ms + <span class="string"><span class="delimiter">&quot;</span><span class="content"> ms</span><span class="delimiter">&quot;</span></span>);
    });
    <span class="keyword">return</span> Promise.race([promise, timeout]);
}

<span class="comment">// 実行例</span>
<span class="keyword">var</span> taskPromise = <span class="keyword">new</span> Promise(<span class="keyword">function</span>(resolve){
    <span class="comment">// 何らかの処理</span>
    <span class="keyword">var</span> delay = Math.random() * <span class="integer">2000</span>;
    setTimeout(<span class="keyword">function</span>(){
        resolve(delay + <span class="string"><span class="delimiter">&quot;</span><span class="content">ms</span><span class="delimiter">&quot;</span></span>);
    }, delay);
});
timeoutPromise(taskPromise, <span class="integer">1000</span>).then(<span class="keyword">function</span>(value){
    console.log(<span class="string"><span class="delimiter">&quot;</span><span class="content">taskPromiseが時間内に終わった : </span><span class="delimiter">&quot;</span></span> + value);
}).<span class="keyword">catch</span>((error) =&gt; {
    console.log(<span class="string"><span class="delimiter">&quot;</span><span class="content">タイムアウトになってしまった</span><span class="delimiter">&quot;</span></span>, error);
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>タイムアウトになった場合はエラーが呼ばれるようにできましたが、
このままでは<em>通常のエラー</em>と<em>タイムアウトのエラー</em>の区別がつかなくなってしまいます。</p>
</div>
<div class="paragraph">
<p>この <code>Error</code> オブジェクトの区別をしやすくするため、
<code>Error</code> オブジェクトのサブクラスとして <code>TimeoutError</code> を定義したいと思います。</p>
</div>
</div>
<div class="sect3">
<h4 id="_カスタムerrorオブジェクト">4.5.3. カスタムErrorオブジェクト</h4>
<div class="paragraph">
<p><code>Error</code> オブジェクトはECMAScriptのビルトインオブジェクトです。</p>
</div>
<div class="paragraph">
<p>ECMAScript5では完璧に <code>Error</code> を継承したものを作ることは不可能ですが(スタックトレース周り等)、
今回は通常のErrorとは区別を付けたいという目的なので、それを満たせる <code>TimeoutError</code> オブジェクトを作成します。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>ECMAScript 2015から <code>class</code> 構文を使うことで内部的にも正確に継承を行うことができます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript"><span class="reserved">class</span> MyError <span class="reserved">extends</span> Error {
    <span class="comment">// Errorを継承したオブジェクト</span>
}</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>error instanceof TimeoutError</code> というように利用できる <code>TimeoutError</code> を定義すると
以下のようになります。</p>
</div>
<div id="TimeoutError.js" class="listingblock">
<div class="title">TimeoutError.js</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript"><span class="keyword">function</span> <span class="function">copyOwnFrom</span>(target, source) {
    Object.getOwnPropertyNames(source).forEach((propName) =&gt; {
        Object.defineProperty(target, propName,
            Object.getOwnPropertyDescriptor(source, propName));
    });
    <span class="keyword">return</span> target;
}
<span class="keyword">function</span> <span class="function">TimeoutError</span>() {
    const superInstance = Error.apply(<span class="predefined-constant">null</span>, <span class="local-variable">arguments</span>);
    copyOwnFrom(<span class="local-variable">this</span>, superInstance);
}
TimeoutError.prototype = Object.create(Error.prototype);
TimeoutError.prototype.constructor = TimeoutError;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>TimeoutError</code> というコンストラクタ関数を定義して、このコンストラクタにErrorをprototype継承させています。</p>
</div>
<div class="paragraph">
<p>使い方は通常の <code>Error</code> オブジェクトと同じで以下のように <code>throw</code> するなどして利用できます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript">const promise = <span class="keyword">new</span> Promise(() =&gt; {
    <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutError(<span class="string"><span class="delimiter">&quot;</span><span class="content">timeout</span><span class="delimiter">&quot;</span></span>);
});

promise.<span class="keyword">catch</span>((error) =&gt; {
    console.log(error <span class="keyword">instanceof</span> TimeoutError);<span class="comment">// true</span>
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>この <code>TimeoutError</code> を使えば、タイムアウトによるErrorオブジェクトなのか、他の原因のErrorオブジェクトなのかが容易に判定できるようになります。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>今回紹介したビルトインオブジェクトを継承したオブジェクトの作成方法については
<a href="http://speakingjs.com/es5/ch28.html">Chapter 28. Subclassing Built-ins</a> で詳しく紹介されています。
また、 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error">Error - JavaScript | MDN</a> にもErrorオブジェクトについて書かれています。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_タイムアウトによるxhrのキャンセル">4.5.4. タイムアウトによるXHRのキャンセル</h4>
<div class="paragraph">
<p>ここまでくれば、どのようにPromiseを使ったXHRのキャンセルを実装するか見えてくるかもしれません。</p>
</div>
<div class="paragraph">
<p>XHRのキャンセル自体は <code>XMLHttpRequest</code> オブジェクトの <code>abort()</code> メソッドを呼ぶだけなので難しくないですね。</p>
</div>
<div class="paragraph">
<p><code>abort()</code> メソッドを外から呼べるようにするために、今までのセクションにもでてきた<a href="#xhr-promise.js"><code>fetchURL</code></a>を少し拡張して、
XHRを包んだpromiseオブジェクトと共にそのXHRを中止するメソッドをもつオブジェクトを返すようにしています。</p>
</div>
<div id="delay-race-cancel.js" class="listingblock">
<div class="title">delay-race-cancel.js</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript"><span class="keyword">function</span> <span class="function">cancelableXHR</span>(URL) {
    const req = <span class="keyword">new</span> XMLHttpRequest();
    const promise = <span class="keyword">new</span> Promise((resolve, reject) =&gt; {
        req.open(<span class="string"><span class="delimiter">&quot;</span><span class="content">GET</span><span class="delimiter">&quot;</span></span>, URL, <span class="predefined-constant">true</span>);
        req.onload = () =&gt; {
            <span class="keyword">if</span> (<span class="integer">200</span> &lt;= req.status &amp;&amp; req.status &lt; <span class="integer">300</span>) {
                resolve(req.responseText);
            } <span class="keyword">else</span> {
                reject(<span class="keyword">new</span> Error(req.statusText));
            }
        };
        req.onerror = () =&gt; {
            reject(<span class="keyword">new</span> Error(req.statusText));
        };
        req.<span class="function">onabort</span> = <span class="keyword">function</span>() {
            reject(<span class="keyword">new</span> Error(<span class="string"><span class="delimiter">&quot;</span><span class="content">this request is aborted</span><span class="delimiter">&quot;</span></span>));
        };
        req.send();
    });
    const <span class="function">abort</span> = <span class="keyword">function</span>() {
        <span class="comment">// 既にrequestが止まってなければabortする</span>
        <span class="comment">// https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest</span>
        <span class="keyword">if</span> (req.readyState !== XMLHttpRequest.UNSENT) {
            req.abort();
        }
    };
    <span class="keyword">return</span> {
        <span class="key">promise</span>: promise,
        <span class="key">abort</span>: abort
    };
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>これで必要な要素は揃ったので後は、Promiseを使った処理のフローに並べていくだけです。
大まかな流れとしては以下のようになります。</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>cancelableXHR</code> を使いXHRのpromiseオブジェクトと中止を呼び出すメソッドを取得する</p>
</li>
<li>
<p><code>timeoutPromise</code> を使いXHRのpromiseとタイムアウト用のpromiseを <code>Promise.race</code> で競争させる</p>
<div class="ulist">
<ul>
<li>
<p>XHRが時間内に取得できた場合</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>通常のpromiseと同様に <code>then</code> で中身を取得する</p>
</li>
</ol>
</div>
</li>
<li>
<p>タイムアウトとなった場合は</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p><code>throw new TimeoutError</code> されるので <code>catch</code> する</p>
</li>
<li>
<p>catchしたエラーオブジェクトが <code>TimeoutError</code> のものだったら <code>abort</code> を呼び出してXHRをキャンセルする</p>
</li>
</ol>
</div>
</li>
</ul>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>これらの要素を全てまとめると次のように書けます。</p>
</div>
<div id="delay-race-cancel-play.js" class="listingblock executable">
<div class="title">delay-race-cancel-play.js</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript"><span class="keyword">function</span> <span class="function">copyOwnFrom</span>(target, source) {
    Object.getOwnPropertyNames(source).forEach((propName) =&gt; {
        Object.defineProperty(target, propName,
            Object.getOwnPropertyDescriptor(source, propName));
    });
    <span class="keyword">return</span> target;
}
<span class="keyword">function</span> <span class="function">TimeoutError</span>() {
    const superInstance = Error.apply(<span class="predefined-constant">null</span>, <span class="local-variable">arguments</span>);
    copyOwnFrom(<span class="local-variable">this</span>, superInstance);
}
TimeoutError.prototype = Object.create(Error.prototype);
TimeoutError.prototype.constructor = TimeoutError;
<span class="keyword">function</span> <span class="function">delayPromise</span>(ms) {
    <span class="keyword">return</span> <span class="keyword">new</span> Promise((resolve) =&gt; {
        setTimeout(resolve, ms);
    });
}
<span class="keyword">function</span> <span class="function">timeoutPromise</span>(promise, ms) {
    const timeout = delayPromise(ms).then(() =&gt; {
        <span class="keyword">return</span> Promise.reject(<span class="keyword">new</span> TimeoutError(<span class="string"><span class="delimiter">&quot;</span><span class="content">Operation timed out after </span><span class="delimiter">&quot;</span></span> + ms + <span class="string"><span class="delimiter">&quot;</span><span class="content"> ms</span><span class="delimiter">&quot;</span></span>));
    });
    <span class="keyword">return</span> Promise.race([promise, timeout]);
}

<span class="keyword">function</span> <span class="function">cancelableXHR</span>(URL) {
    const req = <span class="keyword">new</span> XMLHttpRequest();
    const promise = <span class="keyword">new</span> Promise((resolve, reject) =&gt; {
        req.open(<span class="string"><span class="delimiter">&quot;</span><span class="content">GET</span><span class="delimiter">&quot;</span></span>, URL, <span class="predefined-constant">true</span>);
        req.onload = () =&gt; {
            <span class="keyword">if</span> (<span class="integer">200</span> &lt;= req.status &amp;&amp; req.status &lt; <span class="integer">300</span>) {
                resolve(req.responseText);
            } <span class="keyword">else</span> {
                reject(<span class="keyword">new</span> Error(req.statusText));
            }
        };
        req.onerror = () =&gt; {
            reject(<span class="keyword">new</span> Error(req.statusText));
        };
        req.<span class="function">onabort</span> = <span class="keyword">function</span>() {
            reject(<span class="keyword">new</span> Error(<span class="string"><span class="delimiter">&quot;</span><span class="content">this request is aborted</span><span class="delimiter">&quot;</span></span>));
        };
        req.send();
    });
    const <span class="function">abort</span> = <span class="keyword">function</span>() {
        <span class="comment">// 既にrequestが止まってなければabortする</span>
        <span class="comment">// https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest</span>
        <span class="keyword">if</span> (req.readyState !== XMLHttpRequest.UNSENT) {
            req.abort();
        }
    };
    <span class="keyword">return</span> {
        <span class="key">promise</span>: promise,
        <span class="key">abort</span>: abort
    };
}
const object = cancelableXHR(<span class="string"><span class="delimiter">&quot;</span><span class="content">https://httpbin.org/get</span><span class="delimiter">&quot;</span></span>);
<span class="comment">// main</span>
timeoutPromise(object.promise, <span class="integer">1000</span>)
    .then((contents) =&gt; {
        console.log(<span class="string"><span class="delimiter">&quot;</span><span class="content">Contents</span><span class="delimiter">&quot;</span></span>, contents);
    }).
    <span class="keyword">catch</span>((error) =&gt; {
        <span class="keyword">if</span> (error <span class="keyword">instanceof</span> TimeoutError) {
            object.abort();
            console.error(error);
            <span class="keyword">return</span>;
        }
        console.log(<span class="string"><span class="delimiter">&quot;</span><span class="content">XHR Error :</span><span class="delimiter">&quot;</span></span>, error);
    });</code></pre>
</div>
</div>
<div class="paragraph">
<p>これで、一定時間後に解決されるpromiseオブジェクトを使ったタイムアウト処理が実現できました。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
通常の開発の場合は繰り返し使えるように、それぞれファイルに分割して定義しておくといいですね。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_promiseと操作メソッド">4.5.5. promiseと操作メソッド</h4>
<div class="paragraph">
<p>先ほどの<a href="#delay-race-cancel.js"><code>cancelableXHR</code></a>はpromiseオブジェクトと操作のメソッドが
一緒になったオブジェクトを返すようにしていたため少し分かりにくかったかもしれません。</p>
</div>
<div class="paragraph">
<p>一つの関数は一つの値(promiseオブジェクト)を返すほうが見通しがいいと思いますが、
<code>cancelableXHR</code> の中で生成した <code>req</code> は外から参照できないので、特定のメソッド(先ほどのケースは <code>abort</code>)からは触れるようにする必要があります。</p>
</div>
<div class="paragraph">
<p>返すpromiseオブジェクト自体を拡張して <code>abort</code> できるようにするという手段もあると思いますが、
promiseオブジェクトは値を抽象化したオブジェクトであるため、何でも操作用のメソッドをつけていくと複雑になってしまうかもしれません。</p>
</div>
<div class="paragraph">
<p>一つの関数で全てやろうとしてるのがそもそも良くないので、
以下のように関数に分離していくというのが妥当な気がします。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>XHRを行うpromiseオブジェクトを返す</p>
</li>
<li>
<p>promiseオブジェクトを渡したら該当するXHRを止める</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>これらの処理をまとめたモジュールを作れば今後の拡張がしやすいですし、
一つの関数がやることも小さくて済むので見通しも良くなると思います。</p>
</div>
<div class="paragraph">
<p>モジュールの作り方は色々作法(AMD,CommonJS,ES module etc..)があるので
ここでは、先ほどの <code>cancelableXHR</code> をNode.jsのモジュールとして作りなおしてみます。</p>
</div>
<div id="cancelableXHR.js" class="listingblock">
<div class="title">cancelableXHR.js</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript"><span class="string"><span class="delimiter">&quot;</span><span class="content">use strict</span><span class="delimiter">&quot;</span></span>;
const requestMap = {};
<span class="keyword">function</span> <span class="function">createXHRPromise</span>(URL) {
    const req = <span class="keyword">new</span> XMLHttpRequest();
    const promise = <span class="keyword">new</span> Promise((resolve, reject) =&gt; {
        req.open(<span class="string"><span class="delimiter">&quot;</span><span class="content">GET</span><span class="delimiter">&quot;</span></span>, URL, <span class="predefined-constant">true</span>);
        req.<span class="function">onreadystatechange</span> = <span class="keyword">function</span>() {
            <span class="keyword">if</span> (req.readyState === XMLHttpRequest.DONE) {
                <span class="keyword">delete</span> requestMap[URL];
            }
        };
        req.onload = () =&gt; {
            <span class="keyword">if</span> (<span class="integer">200</span> &lt;= req.status &amp;&amp; req.status &lt; <span class="integer">300</span>) {
                resolve(req.responseText);
            } <span class="keyword">else</span> {
                reject(<span class="keyword">new</span> Error(req.statusText));
            }
        };
        req.onerror = () =&gt; {
            reject(<span class="keyword">new</span> Error(req.statusText));
        };
        req.onabort = () =&gt; {
            reject(<span class="keyword">new</span> Error(<span class="string"><span class="delimiter">&quot;</span><span class="content">abort this req</span><span class="delimiter">&quot;</span></span>));
        };
        req.send();
    });
    requestMap[URL] = {
        <span class="key">promise</span>: promise,
        <span class="key">request</span>: req
    };
    <span class="keyword">return</span> promise;
}

<span class="keyword">function</span> <span class="function">abortPromise</span>(promise) {
    <span class="keyword">if</span> (<span class="keyword">typeof</span> promise === <span class="string"><span class="delimiter">&quot;</span><span class="content">undefined</span><span class="delimiter">&quot;</span></span>) {
        <span class="keyword">return</span>;
    }
    let request;
    Object.keys(requestMap).some((URL) =&gt; {
        <span class="keyword">if</span> (requestMap[URL].promise === promise) {
            request = requestMap[URL].request;
            <span class="keyword">return</span> <span class="predefined-constant">true</span>;
        }
    });
    <span class="keyword">if</span> (request != <span class="predefined-constant">null</span> &amp;&amp; request.readyState !== XMLHttpRequest.UNSENT) {
        request.abort();
    }
}
module.exports.createXHRPromise = createXHRPromise;
module.exports.abortPromise = abortPromise;</code></pre>
</div>
</div>
<div class="paragraph">
<p>使い方もシンプルに <code>createXHRPromise</code> でXHRのpromiseオブジェクトを作成して、
そのXHRを <code>abort</code> したい場合は <code>abortPromise(promise)</code> にpromiseオブジェクトを渡すという感じで利用できるようになります。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript">const cancelableXHR = require(<span class="string"><span class="delimiter">&quot;</span><span class="content">./cancelableXHR</span><span class="delimiter">&quot;</span></span>);

const xhrPromise = cancelableXHR.createXHRPromise(<span class="string"><span class="delimiter">&quot;</span><span class="content">https://httpbin.org/get</span><span class="delimiter">&quot;</span></span>);<i class="conum" data-value="1"></i><b>(1)</b>
xhrPromise.<span class="keyword">catch</span>((error) =&gt; {
    <span class="comment">// abort されたエラーが呼ばれる</span>
});
cancelableXHR.abortPromise(xhrPromise); <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>XHRをラップしたpromiseオブジェクトを作成</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>1で作成したpromiseオブジェクトのリクエストをキャンセル</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_まとめ_8">4.5.6. まとめ</h4>
<div class="paragraph">
<p>ここでは以下のことについて学びました。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>一定時間後に解決されるdelayPromise</p>
</li>
<li>
<p>delayPromiseとPromise.raceを使ったタイムアウトの実装</p>
</li>
<li>
<p>XHRのpromiseのリクエストのキャンセル</p>
</li>
<li>
<p>モジュール化によるpromiseオブジェクトと操作の分離</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Promiseは処理のフローを制御する力に優れているため、
それを最大限活かすためには一つの関数でやり過ぎないで処理を小さく分けること等、
今までのJavaScriptで言われているようなことをより意識していいのかもしれません。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Fetch APIでのキャンセル</div>
<div class="paragraph">
<p>XHRの現代的なバージョンである <a href="https://developer.mozilla.org/ja/docs/Web/API/Fetch_API">Fetch API</a> では、 <a href="https://developer.mozilla.org/en-US/docs/Web/API/AbortController">AbortController</a> というAPIによってリクエストをキャンセルを実現できます。</p>
</div>
<div class="paragraph">
<p>Fetch APIでは、次のようにリクエストをキャンセルできます。</p>
</div>
<div class="listingblock executable">
<div class="title">AbortControllerでのFetchのキャンセル</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript"><span class="comment">// AbortControllerのインスタンスの作成</span>
const controller = <span class="keyword">new</span> AbortController();
<span class="comment">// キャンセルを通知するための signal を取得する</span>
const signal = controller.signal;
<span class="comment">// signal をfetchメソッドの第二引数に渡す</span>
fetch(<span class="string"><span class="delimiter">&quot;</span><span class="content">https://httpbin.org/get</span><span class="delimiter">&quot;</span></span>, { signal })
.then((result) =&gt; {
    <span class="comment">// 結果の正常処理</span>
    console.log(result);
})
.<span class="keyword">catch</span>((error) =&gt; {
    <span class="keyword">if</span> (error.name == <span class="string"><span class="delimiter">&quot;</span><span class="content">AbortError</span><span class="delimiter">&quot;</span></span>) {
        <span class="comment">// 中断の場合の処理</span>
        console.error(<span class="string"><span class="delimiter">&quot;</span><span class="content">Fetchが中断されました</span><span class="delimiter">&quot;</span></span>, error);
        <span class="keyword">return</span>;
    }
    <span class="comment">// 中断以外のエラー</span>
    console.error(err);
});
<span class="comment">// Fetchをキャンセルする</span>
controller.abort();</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>AbortController</code>という今回実装したものと似たような操作メソッドをもつオブジェクトを利用することがわかります。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="promise-done">4.6. Promise.prototype.done とは何か?</h3>
<div class="paragraph">
<p>既存のPromise実装ライブラリを利用したことがある人は、
<code>then</code> の代わりに使う <code>done</code> というメソッドを見たことがあるかもしれません。</p>
</div>
<div class="paragraph">
<p>それらのライブラリでは <code>Promise.prototype.done</code> というような実装が存在し、
使い方は <code>then</code> と同じですが、promiseオブジェクトを返さないようになっています。</p>
</div>
<div class="paragraph">
<p><code>Promise.prototype.done</code> は、<a href="#es-promises">ES Promises</a>や<a href="#promises-aplus">Promises/A+</a>の仕様には
存在していない記述ですが、多くのライブラリが実装しています。</p>
</div>
<div class="paragraph">
<p>このセクションでは、<code>Promise.prototype.done</code> とは何か?
またなぜこのようなメソッドが多くのライブラリで実装されているかについて学んでいきましょう。</p>
</div>
<div class="sect3">
<h4 id="_doneを使ったコード例">4.6.1. doneを使ったコード例</h4>
<div class="paragraph">
<p>実際にdoneを使ったコードを見てみると <code>done</code> の挙動が分かりやすいと思います。</p>
</div>
<div id="promise-done-example.js" class="listingblock executable">
<div class="title">promise-done-example.js</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript"><span class="keyword">if</span> (<span class="keyword">typeof</span> Promise.prototype.done === <span class="string"><span class="delimiter">&quot;</span><span class="content">undefined</span><span class="delimiter">&quot;</span></span>) {
    Promise.prototype.<span class="function">done</span> = <span class="keyword">function</span>(onFulfilled, onRejected) {
        <span class="local-variable">this</span>.then(onFulfilled, onRejected).<span class="keyword">catch</span>((error) =&gt; {
            setTimeout(() =&gt; {
                <span class="keyword">throw</span> error;
            }, <span class="integer">0</span>);
        });
    };
}
const promise = Promise.resolve();
promise.done(() =&gt; {
    JSON.parse(<span class="string"><span class="delimiter">&quot;</span><span class="content">this is not json</span><span class="delimiter">&quot;</span></span>);
    <span class="comment">// =&gt; SyntaxError: JSON.parse</span>
});
<span class="comment">// =&gt; ブラウザの開発ツールのコンソールを開いてみましょう</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>最初に述べたように、<code>Promise.prototype.done</code> は仕様としては存在しないため、
利用する際は実装されているライブラリを使うか自分で実装する必要があります。</p>
</div>
<div class="paragraph">
<p>実装については後で解説しますが、まずは <code>then</code> を使った場合と <code>done</code> を使ったものを比較してみます。</p>
</div>
<div class="listingblock executable">
<div class="title">thenを使った場合</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript">const promise = Promise.resolve();
promise.then(() =&gt; {
    JSON.parse(<span class="string"><span class="delimiter">&quot;</span><span class="content">this is not json</span><span class="delimiter">&quot;</span></span>);
}).<span class="keyword">catch</span>((error) =&gt; {
    console.error(error);<span class="comment">// =&gt; &quot;SyntaxError: JSON.parse&quot;</span>
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>比べて見ると以下のような違いがあることが分かります。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>done</code> はpromiseオブジェクトを返さない</p>
<div class="ulist">
<ul>
<li>
<p>つまり、doneの後に <code>catch</code> 等のメソッドチェーンはできない</p>
</li>
</ul>
</div>
</li>
<li>
<p><code>done</code> の中で発生したエラーはそのまま外に例外として投げられる</p>
<div class="ulist">
<ul>
<li>
<p>つまり、Promiseによるエラーハンドリングが行われない</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>done</code> はpromiseオブジェクトを返していないので、
Promise chainの最後におくメソッドというのは分かると思います。</p>
</div>
<div class="paragraph">
<p>また、Promiseには強力なエラーハンドリング機能があると紹介していましたが、
<code>done</code> の中ではそのエラーハンドリングをワザと突き抜けて例外を出すようになっています。</p>
</div>
<div class="paragraph">
<p>なぜこのようなPromiseの機能とは相反するメソッドが、多くのライブラリで実装されているかについては
次のようなPromiseの失敗例を見ていくと分かるかもしれません。</p>
</div>
</div>
<div class="sect3">
<h4 id="_沈黙したエラー">4.6.2. 沈黙したエラー</h4>
<div class="paragraph">
<p>Promiseには強力なエラーハンドリング機能がありますが、
(デバッグツールが上手く働かない場合に)
この機能がヒューマンエラーをより複雑なものにしてしまう一面があります。</p>
</div>
<div class="paragraph">
<p>これは、<a href="#then-or-catch">then or catch?</a>でも同様の内容が出てきたことを覚えているかもしれません。</p>
</div>
<div class="paragraph">
<p>次のような、promiseオブジェクトを返す関数を考えてみましょう。</p>
</div>
<div id="json-promise.js" class="listingblock">
<div class="title">json-promise.js</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript"><span class="keyword">function</span> <span class="function">JSONPromise</span>(value) {
    <span class="keyword">return</span> <span class="keyword">new</span> Promise((resolve) =&gt; {
        resolve(JSON.parse(value));
    });
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>渡された値を <code>JSON.parse</code> してpromiseオブジェクトを返す関数ですね。</p>
</div>
<div class="paragraph">
<p>以下のように使うことができ、<code>JSON.parse</code> はパースに失敗すると例外を投げるので、
それを <code>catch</code> することができます。</p>
</div>
<div class="listingblock executable">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript"><span class="keyword">function</span> <span class="function">JSONPromise</span>(value) {
    <span class="keyword">return</span> <span class="keyword">new</span> Promise((resolve) =&gt; {
        resolve(JSON.parse(value));
    });
}

<span class="comment">// 実行例</span>
<span class="keyword">var</span> string = <span class="string"><span class="delimiter">&quot;</span><span class="content">jsonではない文字列</span><span class="delimiter">&quot;</span></span>;
JSONPromise(string).then(<span class="keyword">function</span> (object) {
    console.log(object);
}).<span class="keyword">catch</span>((error) =&gt; {
    <span class="comment">// =&gt; JSON.parseで例外が発生した時</span>
    console.error(error);
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>ちゃんと <code>catch</code> していれば何も問題がないのですが、その処理を忘れてしまうというミスを
した時にどこでエラーが発生してるのかわからなくなるというヒューマンエラーを助長させる面があります。</p>
</div>
<div class="listingblock">
<div class="title">catchによるエラーハンドリングを忘れてしまった場合</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript">const string = <span class="string"><span class="delimiter">&quot;</span><span class="content">jsonではない文字列</span><span class="delimiter">&quot;</span></span>;
JSONPromise(string).then((object) =&gt; {
    console.log(object);
}); <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>例外が投げられても何も処理されない</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>JSON.parse</code> のような分かりやすい例の場合はまだよいですが、
メソッドをtypoしたことによるSyntax Errorなどはより深刻な問題となりやすいです。</p>
</div>
<div class="listingblock">
<div class="title">typoによるエラー</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript">const string = <span class="string"><span class="delimiter">&quot;</span><span class="content">{}</span><span class="delimiter">&quot;</span></span>;
JSONPromise(string).then((object) =&gt; {
    conosle.log(object);<i class="conum" data-value="1"></i><b>(1)</b>
});</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>conosle というtypoがある</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>この場合は、<code>console</code> を <code>conosle</code> とtypoしているため、以下のようなエラーが発生するはずです。</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>ReferenceError: conosle is not defined</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>しかし、Promiseではtry-catchされるため、エラーが握りつぶされてしまうという現象が起きてしまいます。
毎回、正しく <code>catch</code> の処理を書くことができる場合は何も問題ありませんが、
Promiseの実装によってはこのようなミスが検知しにくくなるケースがあることを知っておくべきでしょう。</p>
</div>
<div class="paragraph">
<p>このようなエラーの握りつぶしは<em>unhandled rejection</em>と言われることがあります。
"Rejectedされた時の処理がない"というそのままの意味ですね。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>このunhandled rejectionが検知しにくい問題はPromiseの実装と実行環境に依存します。</p>
</div>
<div class="paragraph">
<p>たとえば、 <a href="https://github.com/petkaantonov/bluebird">Bluebird</a> では、
明らかに人間のミスにみえるReferenceErrorの場合などをコンソールにエラーとして表示してくれます。</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>"Possibly unhandled ReferenceError. conosle is not defined</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>また、このunhandled rejectionに関する仕組みが <a href="https://github.com/tc39/ecma262/releases/tag/es2016-draft-20151201">ECMAScript 2016</a> で仕様に追加されています。そのためネイティブPromiseでは、この仕様を活用したGC-based unhandled rejection trackingというものが搭載されているケースが増えています。</p>
</div>
<div class="paragraph">
<p>これはpromiseオブジェクトがガーベッジコレクションによって回収されるときに、
それがunhandled rejectionであるなら、エラー表示をするという仕組みがベースになっています。</p>
</div>
<div class="paragraph">
<p><a href="https://twitter.com/domenic/status/461154989856264192">Firefox</a> や <a href="https://code.google.com/p/v8/issues/detail?id=3093">Chrome</a> のネイティブPromiseでは一部実装されています。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_doneの実装">4.6.3. doneの実装</h4>
<div class="paragraph">
<p>Promiseにおける <code>done</code> は先程のエラーの握りつぶしを避けるにはどうするかという方法論として、
そもそもエラーハンドリングをしなければいい という豪快な解決方法を提供するメソッドです。</p>
</div>
<div class="paragraph">
<p><code>done</code> はPromiseの上に実装することができるので、
<code>Promise.prototype.done</code> というPromiseのprototype拡張として実装してみましょう。</p>
</div>
<div id="promise-prototype-done.js" class="listingblock">
<div class="title">promise-prototype-done.js</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript"><span class="string"><span class="delimiter">&quot;</span><span class="content">use strict</span><span class="delimiter">&quot;</span></span>;
<span class="keyword">if</span> (<span class="keyword">typeof</span> Promise.prototype.done === <span class="string"><span class="delimiter">&quot;</span><span class="content">undefined</span><span class="delimiter">&quot;</span></span>) {
    Promise.prototype.<span class="function">done</span> = <span class="keyword">function</span>(onFulfilled, onRejected) {
        <span class="local-variable">this</span>.then(onFulfilled, onRejected).<span class="keyword">catch</span>((error) =&gt; {
            setTimeout(() =&gt; {
                <span class="keyword">throw</span> error;
            }, <span class="integer">0</span>);
        });
    };
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>どのようにPromiseの外へ例外を投げているかというと、
setTimeoutの中でthrowをすることで、外へそのまま例外を投げられることを利用しています。</p>
</div>
<div class="listingblock">
<div class="title">setTimeoutのコールバック内での例外</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript"><span class="keyword">try</span> {
    setTimeout(() =&gt; {
        <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string"><span class="delimiter">&quot;</span><span class="content">error</span><span class="delimiter">&quot;</span></span>);<i class="conum" data-value="1"></i><b>(1)</b>
    }, <span class="integer">0</span>);
} <span class="keyword">catch</span> (error) {
    console.error(error);
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>この例外はキャッチされない</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>なぜ非同期の <code>callback</code> 内での例外をキャッチ出来ないのかは以下が参考になります。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="http://techblog.yahoo.co.jp/programming/javascript_error/">JavaScriptと非同期のエラー処理 - Yahoo! JAPAN Tech Blog</a></p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><a href="#promise-prototype-done.js"><code>Promise.prototype.done</code></a> をよく見てみると、何も <code>return</code> していないことも分かると思います。
つまり、<code>done</code> は「ここでPromise chainは終了して、例外が起きた場合はそのままpromiseの外へ投げ直す」という処理になっています。</p>
</div>
<div class="paragraph">
<p>現在では多くの実行環境で、<em>unhandled rejection</em>を検知してコンソールに警告を表示するため、<code>done</code> が必要な場合は少なくなっています。
また今回の<a href="#promise-prototype-done.js"><code>Promise.prototype.done</code></a>のように、<code>done</code> は既存のPromiseの上に実装することができるため、
<a href="#es-promises">ES Promises</a>の仕様そのものには入らなかったといえるかもしれません。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
今回の <code>Promise.prototype.done</code> の実装は <a href="https://www.promisejs.org/">promisejs.org</a> を参考にしています。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_まとめ_9">4.6.4. まとめ</h4>
<div class="paragraph">
<p>このセクションでは、 <a href="https://github.com/kriskowal/q/wiki/API-Reference#promisedoneonfulfilled-onrejected-onprogress">Q</a> や <a href="https://github.com/petkaantonov/bluebird">Bluebird</a> や <a href="https://github.com/cscott/prfun#promisedone&#8212;&#8203;undefined">prfun</a> 等
多くのPromiseライブラリで実装されている <code>done</code> の基礎的な実装と、<code>then</code> とはどのような違いがあるかについて学びました。</p>
</div>
<div class="paragraph">
<p><code>done</code> には次の2つの側面があることがわかりました。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>done</code> の中で起きたエラーは外へ例外として投げ直す</p>
</li>
<li>
<p>Promise chain を終了するという宣言</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><a href="#then-or-catch">then or catch?</a> と同様にPromiseにより沈黙してしまったエラーについては、
デバッグツールやライブラリの改善で問題となるケースは少なくなっています。</p>
</div>
<div class="paragraph">
<p>また、<code>done</code> は値を返さないことでそれ以上Promise chainを繋げることができなくなるため、
そのような統一感を持たせるという用途で <code>done</code> を使うこともできます。</p>
</div>
<div class="paragraph">
<p><a href="#es-promises">ES Promises</a> では根本に用意されてる機能はあまり多くありません。
そのため、自ら拡張したり、拡張したライブラリ等を利用するケースが多いと思います。</p>
</div>
<div class="paragraph">
<p>そのときでも何でもやり過ぎると、せっかく非同期処理をPromiseでまとめても複雑化してしまう場合があるため、
統一感を持たせるというのは抽象的なオブジェクトであるPromiseにおいては大事な部分といえるかもしれません。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p><a href="http://blog.getify.com/promises-part-4/">Promises: The Extension Problem (part 4) | getiblog</a> では、
Promiseの拡張を書く手法について書かれています。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Promise.prototype</code> を拡張する方法</p>
</li>
<li>
<p>Wrapper/Delegate を使った抽象レイヤーを作る方法</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>また、Delegateを利用した方法については、 <a href="http://speakingjs.com/es5/ch28.html">Chapter 28. Subclassing Built-ins</a> にて
詳しく解説されています。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="promise-and-method-chain">4.7. Promiseとメソッドチェーン</h3>
<div class="paragraph">
<p>Promiseは <code>then</code> や <code>catch</code> 等のメソッドを繋げて書いていきます。
これはDOMやjQuery等でよくみられるメソッドチェーンとよく似ています。</p>
</div>
<div class="paragraph">
<p>一般的なメソッドチェーンは <code>this</code> を返すことで、メソッドを繋げて書けるようになっています。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>メソッドチェーンの作り方については <a href="http://taiju.hatenablog.com/entry/20100307/1267962826">メソッドチェーンの作り方 - あと味</a> などを参照するといいでしょう。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>一方、Promiseは<a href="#then-return-new-promise">毎回新しいpromiseオブジェクトを返す</a>ようになっていますが、
一般的なメソッドチェーンと見た目は全く同じです。</p>
</div>
<div class="paragraph">
<p>このセクションでは、一般的なメソッドチェーンで書かれたものを
インターフェースはそのままで内部的にはPromiseで処理されるようにする方法について学んでいきたいと思います。</p>
</div>
<div class="sect3">
<h4 id="_fsのメソッドチェーン">4.7.1. fsのメソッドチェーン</h4>
<div class="paragraph">
<p>以下のような <a href="http://nodejs.org/api/fs.html">Node.jsのfs</a>モジュールを例にしてみたいと思います。</p>
</div>
<div class="paragraph">
<p>また、今回の例は見た目のわかりやすさを重視しているため、
現実的にはあまり有用なケースとはいえないかもしれません。</p>
</div>
<div id="fs-method-chain.js" class="listingblock">
<div class="title">fs-method-chain.js</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript"><span class="string"><span class="delimiter">&quot;</span><span class="content">use strict</span><span class="delimiter">&quot;</span></span>;
const fs = require(<span class="string"><span class="delimiter">&quot;</span><span class="content">fs</span><span class="delimiter">&quot;</span></span>);
<span class="keyword">function</span> <span class="function">File</span>() {
    <span class="local-variable">this</span>.lastValue = <span class="predefined-constant">null</span>;
}
<span class="comment">// Static method for File.prototype.read</span>
File.<span class="function">read</span> = <span class="keyword">function</span> <span class="function">FileRead</span>(filePath) {
    const file = <span class="keyword">new</span> File();
    <span class="keyword">return</span> file.read(filePath);
};
File.prototype.<span class="function">read</span> = <span class="keyword">function</span>(filePath) {
    <span class="local-variable">this</span>.lastValue = fs.readFileSync(filePath, <span class="string"><span class="delimiter">&quot;</span><span class="content">utf-8</span><span class="delimiter">&quot;</span></span>);
    <span class="keyword">return</span> <span class="local-variable">this</span>;
};
File.prototype.<span class="function">transform</span> = <span class="keyword">function</span>(fn) {
    <span class="local-variable">this</span>.lastValue = fn.call(<span class="local-variable">this</span>, <span class="local-variable">this</span>.lastValue);
    <span class="keyword">return</span> <span class="local-variable">this</span>;
};
File.prototype.<span class="function">write</span> = <span class="keyword">function</span>(filePath) {
    <span class="local-variable">this</span>.lastValue = fs.writeFileSync(filePath, <span class="local-variable">this</span>.lastValue);
    <span class="keyword">return</span> <span class="local-variable">this</span>;
};
module.exports = File;</code></pre>
</div>
</div>
<div class="paragraph">
<p>このモジュールは以下のようにread &#8594; transform &#8594; writeという流れを
メソッドチェーンで表現することができます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript">const File = require(<span class="string"><span class="delimiter">&quot;</span><span class="content">./fs-method-chain</span><span class="delimiter">&quot;</span></span>);
const inputFilePath = <span class="string"><span class="delimiter">&quot;</span><span class="content">input.txt</span><span class="delimiter">&quot;</span></span>;
const outputFilePath = <span class="string"><span class="delimiter">&quot;</span><span class="content">output.txt</span><span class="delimiter">&quot;</span></span>;
File.read(inputFilePath)
    .transform((content) =&gt; {
        <span class="keyword">return</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">&gt;&gt;</span><span class="delimiter">&quot;</span></span> + content;
    })
    .write(outputFilePath);</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>transform</code> は引数で受け取った値を変更する関数を渡して処理するメソッドです。
この場合は、readで読み込んだ内容の先頭に <code>&gt;&gt;</code> という文字列を追加しているだけです。</p>
</div>
</div>
<div class="sect3">
<h4 id="_promiseによるfsのメソッドチェーン">4.7.2. Promiseによるfsのメソッドチェーン</h4>
<div class="paragraph">
<p>次に先ほどの<a href="#fs-method-chain.js">メソッドチェーン</a>をインターフェースはそのまま維持して
内部的にPromiseを使った処理にしてみたいと思います。</p>
</div>
<div id="fs-promise-chain.js" class="listingblock">
<div class="title">fs-promise-chain.js</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript"><span class="string"><span class="delimiter">&quot;</span><span class="content">use strict</span><span class="delimiter">&quot;</span></span>;
const fs = require(<span class="string"><span class="delimiter">&quot;</span><span class="content">fs</span><span class="delimiter">&quot;</span></span>);
<span class="keyword">function</span> <span class="function">File</span>() {
    <span class="local-variable">this</span>.promise = Promise.resolve();
}
<span class="comment">// Static method for File.prototype.read</span>
File.<span class="function">read</span> = <span class="keyword">function</span>(filePath) {
    const file = <span class="keyword">new</span> File();
    <span class="keyword">return</span> file.read(filePath);
};

File.prototype.<span class="function">then</span> = <span class="keyword">function</span>(onFulfilled, onRejected) {
    <span class="local-variable">this</span>.promise = <span class="local-variable">this</span>.promise.then(onFulfilled, onRejected);
    <span class="keyword">return</span> <span class="local-variable">this</span>;
};
File.prototype[<span class="string"><span class="delimiter">&quot;</span><span class="content">catch</span><span class="delimiter">&quot;</span></span>] = <span class="keyword">function</span>(onRejected) {
    <span class="local-variable">this</span>.promise = <span class="local-variable">this</span>.promise.<span class="keyword">catch</span>(onRejected);
    <span class="keyword">return</span> <span class="local-variable">this</span>;
};
File.prototype.<span class="function">read</span> = <span class="keyword">function</span>(filePath) {
    <span class="keyword">return</span> <span class="local-variable">this</span>.then(() =&gt; {
        <span class="keyword">return</span> fs.readFileSync(filePath, <span class="string"><span class="delimiter">&quot;</span><span class="content">utf-8</span><span class="delimiter">&quot;</span></span>);
    });
};
File.prototype.<span class="function">transform</span> = <span class="keyword">function</span>(fn) {
    <span class="keyword">return</span> <span class="local-variable">this</span>.then(fn);
};
File.prototype.<span class="function">write</span> = <span class="keyword">function</span>(filePath) {
    <span class="keyword">return</span> <span class="local-variable">this</span>.then((data) =&gt; {
        <span class="keyword">return</span> fs.writeFileSync(filePath, data);
    });
};
module.exports = File;</code></pre>
</div>
</div>
<div class="paragraph">
<p>内部に持ってるpromiseオブジェクトに対するエイリアスとして
<code>then</code> と <code>catch</code> を持たせていますが、それ以外のインターフェースは全く同じ使い方となっています。</p>
</div>
<div class="paragraph">
<p>そのため、先ほどのコードで <code>require</code> するモジュールを変更しただけで動作します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript">const File = require(<span class="string"><span class="delimiter">&quot;</span><span class="content">./fs-promise-chain</span><span class="delimiter">&quot;</span></span>);
const inputFilePath = <span class="string"><span class="delimiter">&quot;</span><span class="content">input.txt</span><span class="delimiter">&quot;</span></span>;
const outputFilePath = <span class="string"><span class="delimiter">&quot;</span><span class="content">output.txt</span><span class="delimiter">&quot;</span></span>;
File.read(inputFilePath)
    .transform((content) =&gt; {
        <span class="keyword">return</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">&gt;&gt;</span><span class="delimiter">&quot;</span></span> + content;
    })
    .write(outputFilePath);</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>File.prototype.then</code> というメソッドは、
<code>this.promise.then</code> が返す新しいpromiseオブジェクトを <code>this.promise</code> に対して代入しています。</p>
</div>
<div class="paragraph">
<p>これはどういうことなのかというと、以下のように擬似的に展開してみると分かりやすいでしょう。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript">const File = require(<span class="string"><span class="delimiter">&quot;</span><span class="content">./fs-promise-chain</span><span class="delimiter">&quot;</span></span>);
File.read(inputFilePath)
    .transform((content) =&gt; {
        <span class="keyword">return</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">&gt;&gt;</span><span class="delimiter">&quot;</span></span> + content;
    })
    .write(outputFilePath);
<span class="comment">// =&gt; 擬似的に以下のような流れに展開できる</span>
promise.then(() =&gt; {
    <span class="keyword">return</span> fs.readFileSync(filePath, <span class="string"><span class="delimiter">&quot;</span><span class="content">utf-8</span><span class="delimiter">&quot;</span></span>);
}).then((content) =&gt; {
    <span class="keyword">return</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">&gt;&gt;</span><span class="delimiter">&quot;</span></span> + content;
}).then(() =&gt; {
    <span class="keyword">return</span> fs.writeFileSync(filePath, data);
});</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>promise = promise.then(&#8230;&#8203;)</code> という書き方は一見すると、上書きしているようにみえるため、
それまでのpromiseのchainが途切れてしまうと思うかもしれません。</p>
</div>
<div class="paragraph">
<p>イメージとしては <code>promise = addPromiseChain(promise, fn);</code> のような感じになっていて、
既存のpromiseオブジェクトに対して新たな処理を<strong>追加</strong>したpromiseオブジェクトを作って返すため、
自分で逐次的に処理する機構を実装しなくても問題ないわけです。</p>
</div>
</div>
<div class="sect3">
<h4 id="_両者の違い">4.7.3. 両者の違い</h4>
<div class="sect4">
<h5 id="_同期と非同期">同期と非同期</h5>
<div class="paragraph">
<p><a href="#fs-method-chain.js">fs-method-chain.js</a>と<a href="#fs-promise-chain.js">Promise版</a>の違いを見ていくと、
そもそも両者には同期的、非同期的という大きな違いがあります。</p>
</div>
<div class="paragraph">
<p><a href="#fs-method-chain.js">fs-method-chain.js</a> のようなメソッドチェーンでもキュー等の処理を実装すれば、
非同期的なほぼ同様のメソッドチェーンを実装できますが、複雑になるため今回は単純な同期的なメソッドチェーンにしました。</p>
</div>
<div class="paragraph">
<p>Promise版は<a href="#promise-is-always-async">コラム: Promiseは常に非同期?</a>で紹介したように
常に非同期処理となるため、promiseを使ったメソッドチェーンも非同期となっています。</p>
</div>
</div>
<div class="sect4">
<h5 id="_エラーハンドリング">エラーハンドリング</h5>
<div class="paragraph">
<p><a href="#fs-method-chain.js">fs-method-chain.js</a>にはエラーハンドリングの処理は入っていないですが、
同期処理であるため全体を <code>try-catch</code> で囲むことで行えます。</p>
</div>
<div class="paragraph">
<p><a href="#fs-promise-chain.js">Promise版</a> では内部で利用するpromiseオブジェクトの
<code>then</code> と <code>catch</code> へのエイリアスを用意してあるため、通常のpromiseと同じように <code>catch</code> によってエラーハンドリングが行えます。</p>
</div>
<div class="listingblock">
<div class="title">fs-promise-chainでのエラーハンドリング</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript">const File = require(<span class="string"><span class="delimiter">&quot;</span><span class="content">./fs-promise-chain</span><span class="delimiter">&quot;</span></span>);
File.read(inputFilePath)
    .transform((content) =&gt; {
        <span class="keyword">return</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">&gt;&gt;</span><span class="delimiter">&quot;</span></span> + content;
    })
    .write(outputFilePath)
    .<span class="keyword">catch</span>((error) =&gt; {
        console.error(error);
    });</code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="#fs-method-chain.js">fs-method-chain.js</a>に非同期処理を加えたものを自力で実装する場合、
エラーハンドリングが大きな問題となるため、非同期処理にしたい時は
Promiseを使うと比較的簡単に実装できるといえるかもしれません。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_promise以外での非同期処理">4.7.4. Promise以外での非同期処理</h4>
<div class="paragraph">
<p>このメソッドチェーンと非同期処理を見てNode.jsに慣れている方は <a href="http://nodejs.org/api/stream.html">Stream</a> が思い浮かぶと思います。</p>
</div>
<div class="paragraph">
<p><a href="http://nodejs.org/api/stream.html">Stream</a> を使うと、
<code>this.lastValue</code> のような値を保持する必要がなくなることや大きなファイルの扱いが改善されます。
また、Promiseを使った例に比べるとより高速に処理できる可能性が高いと思います。</p>
</div>
<div class="listingblock">
<div class="title">streamによるread&#8594;transform&#8594;write</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript">readableStream.pipe(transformStream).pipe(writableStream);</code></pre>
</div>
</div>
<div class="paragraph">
<p>そのため、非同期処理には常にPromiseが最適という訳ではなく、
目的と状況にあった実装をしていくことを考えていくべきでしょう。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Node.jsのStreamはEventをベースにしている技術
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Node.jsのStreamについて詳しくは以下を参照して下さい。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="http://jxck.hatenablog.com/entry/20111204/1322966453">Node.js の Stream API で「データの流れ」を扱う方法 - Block Rockin’ Codes</a></p>
</li>
<li>
<p><a href="http://www.slideshare.net/shigeki_ohtsu/stream2-kihon">Stream2の基本</a></p>
</li>
<li>
<p><a href="http://www.slideshare.net/shigeki_ohtsu/node-v012tng12">Node-v0.12の新機能について</a></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_promiseラッパー">4.7.5. Promiseラッパー</h4>
<div class="paragraph">
<p>話を戻して<a href="#fs-method-chain.js">fs-method-chain.js</a>と<a href="#fs-promise-chain.js">Promise版</a>の両者を比べると、
内部的にもかなり似ていて、同期版のものがそのまま非同期版でも使えるような気がします。</p>
</div>
<div class="paragraph">
<p>JavaScriptでは動的にメソッドを定義することもできるため、
自動的にPromise版を生成できないかということを考えると思います。
(もちろん静的に定義する方が扱いやすいですが)</p>
</div>
<div class="paragraph">
<p>そのような仕組みは<a href="#es-promises">ES Promises</a>にはありませんが、
著名なサードパーティのPromise実装である <a href="https://github.com/petkaantonov/bluebird/">bluebird</a> などには
<a href="https://github.com/petkaantonov/bluebird/blob/master/API.md#promisification">Promisification</a> という機能が用意されています。
また、Node.jsのコアモジュールである<code>util</code>モジュールには、 <a href="https://nodejs.org/api/util.html#util_util_promisify_original">util.promisify</a> というAPIが用意されています。</p>
</div>
<div class="paragraph">
<p>これを利用すると以下のように、その場でPromise版のメソッドを作成して利用できるようになります。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript">const fs = require(<span class="string"><span class="delimiter">&quot;</span><span class="content">fs</span><span class="delimiter">&quot;</span></span>);
const util = require(<span class="string"><span class="delimiter">&quot;</span><span class="content">util</span><span class="delimiter">&quot;</span></span>);
<span class="comment">// コールバック版のAPIからPromise版を作成する</span>
const readFile = util.promisify(fs.readFile);

readFile(<span class="string"><span class="delimiter">&quot;</span><span class="content">myfile.js</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">utf8</span><span class="delimiter">&quot;</span></span>).then((contents) =&gt; {
    console.log(contents);
}).<span class="keyword">catch</span>((e) =&gt; {
    console.error(e.stack);
});</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="_arrayのpromiseラッパー">ArrayのPromiseラッパー</h5>
<div class="paragraph">
<p>先ほどの<code>util.promisify</code>が何をやっているのか少しイメージしにくいので、
次のようなネイティブ <code>Array</code> のPromise版となるメソッドを動的に定義する例を考えてみましょう。</p>
</div>
<div class="paragraph">
<p>JavaScriptにはネイティブにもDOMやString等メソッドチェーンが行える機能が多くあります。
<code>Array</code> もその一つで、<code>map</code> や <code>filter</code> 等のメソッドは配列を返すため、メソッドチェーンが利用しやすい機能です</p>
</div>
<div id="array-promise-chain.js" class="listingblock">
<div class="title">array-promise-chain.js</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript"><span class="string"><span class="delimiter">&quot;</span><span class="content">use strict</span><span class="delimiter">&quot;</span></span>;
<span class="keyword">function</span> <span class="function">ArrayAsPromise</span>(array) {
    <span class="local-variable">this</span>.array = array;
    <span class="local-variable">this</span>.promise = Promise.resolve();
}
ArrayAsPromise.prototype.<span class="function">then</span> = <span class="keyword">function</span>(onFulfilled, onRejected) {
    <span class="local-variable">this</span>.promise = <span class="local-variable">this</span>.promise.then(onFulfilled, onRejected);
    <span class="keyword">return</span> <span class="local-variable">this</span>;
};
ArrayAsPromise.prototype[<span class="string"><span class="delimiter">&quot;</span><span class="content">catch</span><span class="delimiter">&quot;</span></span>] = <span class="keyword">function</span>(onRejected) {
    <span class="local-variable">this</span>.promise = <span class="local-variable">this</span>.promise.<span class="keyword">catch</span>(onRejected);
    <span class="keyword">return</span> <span class="local-variable">this</span>;
};
Object.getOwnPropertyNames(Array.prototype).forEach((methodName) =&gt; {
    <span class="comment">// Don't overwrite</span>
    <span class="keyword">if</span> (<span class="keyword">typeof</span> ArrayAsPromise[methodName] !== <span class="string"><span class="delimiter">&quot;</span><span class="content">undefined</span><span class="delimiter">&quot;</span></span>) {
        <span class="keyword">return</span>;
    }
    const arrayMethod = Array.prototype[methodName];
    <span class="keyword">if</span> (<span class="keyword">typeof</span>  arrayMethod !== <span class="string"><span class="delimiter">&quot;</span><span class="content">function</span><span class="delimiter">&quot;</span></span>) {
        <span class="keyword">return</span>;
    }
    ArrayAsPromise.prototype[methodName] = <span class="keyword">function</span>() {
        const that = <span class="local-variable">this</span>;
        const args = <span class="local-variable">arguments</span>;
        <span class="local-variable">this</span>.promise = <span class="local-variable">this</span>.promise.then(() =&gt; {
            that.array = Array.prototype[methodName].apply(that.array, args);
            <span class="keyword">return</span> that.array;
        });
        <span class="keyword">return</span> <span class="local-variable">this</span>;
    };
});

module.exports = ArrayAsPromise;
module.exports.<span class="function">array</span> = <span class="keyword">function</span> <span class="function">newArrayAsPromise</span>(array) {
    <span class="keyword">return</span> <span class="keyword">new</span> ArrayAsPromise(array);
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>ネイティブのArrayと <code>ArrayAsPromise</code> を使った場合の違いは
<a href="#array-promise-chain.js">上記のコード</a>のテストを見てみるのが分かりやすいでしょう。</p>
</div>
<div id="array-promise-chain-test.js" class="listingblock">
<div class="title">array-promise-chain-test.js</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript">const assert = require(<span class="string"><span class="delimiter">&quot;</span><span class="content">assert</span><span class="delimiter">&quot;</span></span>);
const ArrayAsPromise = require(<span class="string"><span class="delimiter">&quot;</span><span class="content">../src/promise-chain/array-promise-chain</span><span class="delimiter">&quot;</span></span>);
describe(<span class="string"><span class="delimiter">&quot;</span><span class="content">array-promise-chain</span><span class="delimiter">&quot;</span></span>, () =&gt; {
    <span class="keyword">function</span> <span class="function">isEven</span>(value) {
        <span class="keyword">return</span> value % <span class="integer">2</span> === <span class="integer">0</span>;
    }

    <span class="keyword">function</span> <span class="reserved">double</span>(value) {
        <span class="keyword">return</span> value * <span class="integer">2</span>;
    }

    beforeEach(<span class="keyword">function</span>() {
        <span class="local-variable">this</span>.array = [<span class="integer">1</span>, <span class="integer">2</span>, <span class="integer">3</span>, <span class="integer">4</span>, <span class="integer">5</span>];
    });
    describe(<span class="string"><span class="delimiter">&quot;</span><span class="content">Native array</span><span class="delimiter">&quot;</span></span>, () =&gt; {
        it(<span class="string"><span class="delimiter">&quot;</span><span class="content">can method chain</span><span class="delimiter">&quot;</span></span>, <span class="keyword">function</span>() {
            const result = <span class="local-variable">this</span>.array.filter(isEven).map(<span class="reserved">double</span>);
            assert.deepEqual(result, [<span class="integer">4</span>, <span class="integer">8</span>]);
        });
    });
    describe(<span class="string"><span class="delimiter">&quot;</span><span class="content">ArrayAsPromise</span><span class="delimiter">&quot;</span></span>, () =&gt; {
        it(<span class="string"><span class="delimiter">&quot;</span><span class="content">can promise chain</span><span class="delimiter">&quot;</span></span>, <span class="keyword">function</span>(done) {
            const array = <span class="keyword">new</span> ArrayAsPromise(<span class="local-variable">this</span>.array);
            array.filter(isEven).map(<span class="reserved">double</span>).then((value) =&gt; {
                assert.deepEqual(value, [<span class="integer">4</span>, <span class="integer">8</span>]);
            }).then(done, done);
        });
    });
});</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>ArrayAsPromise</code> でもArrayのメソッドを利用できているのが分かります。
先ほどと同じように、ネイティブのArrayは同期処理で、<code>ArrayAsPromise</code> は非同期処理という違いがあります。</p>
</div>
<div class="paragraph">
<p><code>ArrayAsPromise</code> の実装を見て気づくと思いますが、<code>Array.prototype</code> のメソッドを全て実装しています。
しかし、<code>array.indexOf</code> など <code>Array.prototype</code> には配列を返さないものもあるため、全てをメソッドチェーンにするのは不自然なケースがあると思います。</p>
</div>
<div class="paragraph">
<p>ここで大事なのが、同じ値を受けるインターフェースを持っているAPIはこのような手段でPromise版のAPIを自動的に作成できるという点です。
このようなAPIの規則性を意識してみるとまた違った使い方が見つかるかもしれません。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>先ほどの  <a href="https://nodejs.org/api/util.html#util_util_promisify_original">util.promisify</a> は、
Node.jsのCoreモジュールの非同期処理には <code>function(error, result){}</code> というように第一引数に <code>error</code> が来るというルール（エラーファーストコールバック）を利用して、自動的にPromiseでラップしたメソッドを生成しています。</p>
</div>
<div class="paragraph">
<p>また、Node.js 10からは <code>fs</code> モジュールに <a href="https://nodejs.org/api/fs.html#fs_fs_promises_api">Promise版のAPI</a> が追加されています。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_まとめ_10">4.7.6. まとめ</h4>
<div class="paragraph">
<p>このセクションでは以下のことについて学びました。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Promise版のメソッドチェーンの実装</p>
</li>
<li>
<p>Promiseが常に非同期の最善の手段ではない</p>
</li>
<li>
<p>Promisification</p>
</li>
<li>
<p>統一的なインターフェースの再利用</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><a href="#es-promises">ES Promises</a>はCoreとなる機能しか用意されていません。
そのため、自分でPromiseを使った既存の機能のラッパー的な実装をすることがあるかもしれません。</p>
</div>
<div class="paragraph">
<p>しかし、何度もコールバックを呼ぶEventのような処理がPromiseには不向きなように、
Promiseが常に最適な非同期処理という訳ではありません。</p>
</div>
<div class="paragraph">
<p>その機能にPromiseを使うのが最適なのかを考えることはこの書籍の目的でもあるため、
何でもPromiseにするというわけではなく、その目的にPromiseが合うのかどうかを考えてみるのもいいと思います。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="promise-sequence">4.8. Promiseによる逐次処理</h3>
<div class="paragraph">
<p>第2章の<a href="#ch2-promise-all">Promise.all</a>では、
複数のpromiseオブジェクトをまとめて処理する方法について学びました。</p>
</div>
<div class="paragraph">
<p>しかし、<code>Promise.all</code> は全ての処理を並行に行うため、
Aの処理 が終わったら Bの処理 というような逐次的な処理を扱うことができません。</p>
</div>
<div class="paragraph">
<p>また、同じ2章の<a href="#ch2-promise-and-array">Promiseと配列</a>では、
効率的ではないですが、<a href="#multiple-xhr.js">thenを連ねた書き方</a>でそのような逐次処理を行っていました。</p>
</div>
<div class="paragraph">
<p>このセクションでは、Promiseを使った逐次処理の書き方について学んで行きたいと思います。</p>
</div>
<div class="sect3">
<h4 id="_ループと逐次処理">4.8.1. ループと逐次処理</h4>
<div class="paragraph">
<p><a href="#multiple-xhr.js">thenを連ねた書き方</a>では以下のような書き方でしたね。</p>
</div>
<div class="listingblock executable">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript"><span class="keyword">function</span> <span class="function">fetchURL</span>(URL) {
    <span class="keyword">return</span> <span class="keyword">new</span> Promise((resolve, reject) =&gt; {
        const req = <span class="keyword">new</span> XMLHttpRequest();
        req.open(<span class="string"><span class="delimiter">&quot;</span><span class="content">GET</span><span class="delimiter">&quot;</span></span>, URL, <span class="predefined-constant">true</span>);
        req.onload = () =&gt; {
            <span class="keyword">if</span> (<span class="integer">200</span> &lt;= req.status &amp;&amp; req.status &lt; <span class="integer">300</span>) {
                resolve(req.responseText);
            } <span class="keyword">else</span> {
                reject(<span class="keyword">new</span> Error(req.statusText));
            }
        };
        req.onerror = () =&gt; {
            reject(<span class="keyword">new</span> Error(req.statusText));
        };
        req.send();
    });
}
const request = {
    comment() {
        <span class="keyword">return</span> fetchURL(<span class="string"><span class="delimiter">&quot;</span><span class="content">https://azu.github.io/promises-book/json/comment.json</span><span class="delimiter">&quot;</span></span>).then(JSON.parse);
    },
    people() {
        <span class="keyword">return</span> fetchURL(<span class="string"><span class="delimiter">&quot;</span><span class="content">https://azu.github.io/promises-book/json/people.json</span><span class="delimiter">&quot;</span></span>).then(JSON.parse);
    }
};
<span class="keyword">function</span> <span class="function">main</span>() {
    <span class="keyword">function</span> <span class="function">recordValue</span>(results, value) {
        results.push(value);
        <span class="keyword">return</span> results;
    }
    <span class="comment">// [] は記録する初期値を部分適用している</span>
    const pushValue = recordValue.bind(<span class="predefined-constant">null</span>, []);
    <span class="keyword">return</span> request.comment()
        .then(pushValue)
        .then(request.people)
        .then(pushValue);
}



<span class="comment">// 実行例</span>
main().then((value) =&gt; {
    console.log(value);
}).<span class="keyword">catch</span>((error) =&gt; {
    console.error(error);
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>この書き方だと、<code>request</code> の数が増える分 <code>then</code> を書かないといけなくなってしまいます。</p>
</div>
<div class="paragraph">
<p>そこで、処理を配列にまとめて、forループで処理していければ、数が増えた場合も問題無いですね。
まずはforループを使って先ほどと同じ処理を書いてみたいと思います。</p>
</div>
<div id="promise-foreach-xhr.js" class="listingblock executable">
<div class="title">promise-foreach-xhr.js</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript"><span class="keyword">function</span> <span class="function">fetchURL</span>(URL) {
    <span class="keyword">return</span> <span class="keyword">new</span> Promise((resolve, reject) =&gt; {
        const req = <span class="keyword">new</span> XMLHttpRequest();
        req.open(<span class="string"><span class="delimiter">&quot;</span><span class="content">GET</span><span class="delimiter">&quot;</span></span>, URL, <span class="predefined-constant">true</span>);
        req.onload = () =&gt; {
            <span class="keyword">if</span> (<span class="integer">200</span> &lt;= req.status &amp;&amp; req.status &lt; <span class="integer">300</span>) {
                resolve(req.responseText);
            } <span class="keyword">else</span> {
                reject(<span class="keyword">new</span> Error(req.statusText));
            }
        };
        req.onerror = () =&gt; {
            reject(<span class="keyword">new</span> Error(req.statusText));
        };
        req.send();
    });
}
const request = {
    comment() {
        <span class="keyword">return</span> fetchURL(<span class="string"><span class="delimiter">&quot;</span><span class="content">https://azu.github.io/promises-book/json/comment.json</span><span class="delimiter">&quot;</span></span>).then(JSON.parse);
    },
    people() {
        <span class="keyword">return</span> fetchURL(<span class="string"><span class="delimiter">&quot;</span><span class="content">https://azu.github.io/promises-book/json/people.json</span><span class="delimiter">&quot;</span></span>).then(JSON.parse);
    }
};
<span class="keyword">function</span> <span class="function">main</span>() {
    <span class="keyword">function</span> <span class="function">recordValue</span>(results, value) {
        results.push(value);
        <span class="keyword">return</span> results;
    }

    <span class="comment">// [] は記録する初期値を部分適用してる</span>
    const pushValue = recordValue.bind(<span class="predefined-constant">null</span>, []);
    <span class="comment">// promiseオブジェクトを返す関数の配列</span>
    const tasks = [request.comment, request.people];
    let promise = Promise.resolve();<span class="comment">// スタート地点</span>
    <span class="keyword">for</span> (let i = <span class="integer">0</span>; i &lt; tasks.length; i++) {
        const task = tasks[i];
        promise = promise.then(task).then(pushValue);
    }
    <span class="keyword">return</span> promise;
}



<span class="comment">// 実行例</span>
main().then((value) =&gt; {
    console.log(value);
}).<span class="keyword">catch</span>((error) =&gt; {
    console.error(error);
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>forループで書く場合、<a href="#then-return-new-promise">コラム: thenは常に新しいpromiseオブジェクトを返す</a>や<a href="#promise-and-method-chain">Promiseとメソッドチェーン</a>で学んだように、
<a href="#promise.then">Promise#then</a> は新しいpromiseオブジェクトを返しています。</p>
</div>
<div class="paragraph">
<p>そのため、<code>promise = promise.then(task).then(pushValue);</code> というのは <code>promise</code> という変数に上書きするというよりは、
そのpromiseオブジェクトに処理を追加していくような処理になっています。</p>
</div>
<div class="paragraph">
<p>しかし、この書き方だと一時変数として <code>promise</code> が必要で、処理の内容的にもあまりスッキリしません。</p>
</div>
<div class="paragraph">
<p>このループの書き方は <code>Array.prototype.reduce</code> を使うともっとスマートに書くことができます。</p>
</div>
</div>
<div class="sect3">
<h4 id="_promise_chainとreduce">4.8.2. Promise chainとreduce</h4>
<div class="paragraph">
<p><code>Array.prototype.reduce</code> を使って書き直すと以下のようになります。</p>
</div>
<div id="promise-reduce-xhr.js" class="listingblock executable">
<div class="title">promise-reduce-xhr.js</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript"><span class="keyword">function</span> <span class="function">fetchURL</span>(URL) {
    <span class="keyword">return</span> <span class="keyword">new</span> Promise((resolve, reject) =&gt; {
        const req = <span class="keyword">new</span> XMLHttpRequest();
        req.open(<span class="string"><span class="delimiter">&quot;</span><span class="content">GET</span><span class="delimiter">&quot;</span></span>, URL, <span class="predefined-constant">true</span>);
        req.onload = () =&gt; {
            <span class="keyword">if</span> (<span class="integer">200</span> &lt;= req.status &amp;&amp; req.status &lt; <span class="integer">300</span>) {
                resolve(req.responseText);
            } <span class="keyword">else</span> {
                reject(<span class="keyword">new</span> Error(req.statusText));
            }
        };
        req.onerror = () =&gt; {
            reject(<span class="keyword">new</span> Error(req.statusText));
        };
        req.send();
    });
}
const request = {
    comment() {
        <span class="keyword">return</span> fetchURL(<span class="string"><span class="delimiter">&quot;</span><span class="content">https://azu.github.io/promises-book/json/comment.json</span><span class="delimiter">&quot;</span></span>).then(JSON.parse);
    },
    people() {
        <span class="keyword">return</span> fetchURL(<span class="string"><span class="delimiter">&quot;</span><span class="content">https://azu.github.io/promises-book/json/people.json</span><span class="delimiter">&quot;</span></span>).then(JSON.parse);
    }
};
<span class="keyword">function</span> <span class="function">main</span>() {
    <span class="keyword">function</span> <span class="function">recordValue</span>(results, value) {
        results.push(value);
        <span class="keyword">return</span> results;
    }

    const pushValue = recordValue.bind(<span class="predefined-constant">null</span>, []);
    const tasks = [request.comment, request.people];
    <span class="keyword">return</span> tasks.reduce((promise, task) =&gt; {
        <span class="keyword">return</span> promise.then(task).then(pushValue);
    }, Promise.resolve());
}



<span class="comment">// 実行例</span>
main().then((value) =&gt; {
    console.log(value);
}).<span class="keyword">catch</span>((error) =&gt; {
    console.error(error);
});</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>main</code> 以外の処理はforループのものと同様です。</p>
</div>
<div class="paragraph">
<p><code>Array.prototype.reduce</code> は第二引数に初期値を入れることができます。
つまりこの場合、最初の <code>promise</code> には <code>Promise.resolve()</code> が入り、
そのときの <code>task</code> は <code>request.comment</code> となります。</p>
</div>
<div class="paragraph">
<p>reduceの中で <code>return</code> したものが、次のループで <code>promise</code> に入ります。
つまり、<code>then</code> を使って作成した新たなpromiseオブジェクトを返すことで、
forループの場合と同じように<a href="#promise-chain">Promise chain</a>を繋げることができます。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>Array.prototype.reduce</code> については詳しくは以下を参照して下さい。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce">Array.prototype.reduce() - JavaScript | MDN</a></p>
</li>
<li>
<p><a href="https://azu.github.io/slide/JSGohan/reduce.html">Array.prototype.reduce Dance</a></p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>forループと異なる点は、一時変数としての <code>promise</code> が不要になることに伴い、
<code>promise = promise.then(task).then(pushValue);</code> という不格好な書き方がなくなる点が大きな違いだと思います。</p>
</div>
<div class="paragraph">
<p><code>Array.prototype.reduce</code> とPromiseの逐次処理は相性がよいので覚えておくといいのですが、
初めて見た時にどのような動作をするのかがまだ分かりにくいという問題があります。</p>
</div>
<div class="paragraph">
<p>そこで、処理するTaskとなる関数の配列を受け取って逐次処理を行う
<code>sequenceTasks</code> というものを作ってみます。</p>
</div>
<div class="paragraph">
<p>以下のように書くことができれば、<code>tasks</code> が順番に処理されていくことが関数名から見て分かるようになります。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript">const tasks = [request.comment, request.people];
sequenceTasks(tasks);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_逐次処理を行う関数を定義する">4.8.3. 逐次処理を行う関数を定義する</h4>
<div class="paragraph">
<p>基本的には、<a href="#promise-reduce-xhr.js">reduceを使ったやり方</a>を関数として切り離せばいいだけですね。</p>
</div>
<div id="promise-sequence.js" class="listingblock">
<div class="title">promise-sequence.js</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript"><span class="keyword">function</span> <span class="function">sequenceTasks</span>(tasks) {
    <span class="keyword">function</span> <span class="function">recordValue</span>(results, value) {
        results.push(value);
        <span class="keyword">return</span> results;
    }

    const pushValue = recordValue.bind(<span class="predefined-constant">null</span>, []);
    <span class="keyword">return</span> tasks.reduce((promise, task) =&gt; {
        <span class="keyword">return</span> promise.then(task).then(pushValue);
    }, Promise.resolve());
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>一つ注意点として、<code>Promise.all</code> 等と違い、引数に受け取るのは関数の配列です。</p>
</div>
<div class="paragraph">
<p>なぜ、渡すのがpromiseオブジェクトの配列ではないのかというと、
promiseオブジェクトを作った段階ですでにXHRが実行されている状態なので、
それを逐次処理しても意図とは異なる動作になるためです。</p>
</div>
<div class="paragraph">
<p>そのため <code>sequenceTasks</code> では関数(promiseオブジェクトを返す)の配列を引数に受け取ります。</p>
</div>
<div class="paragraph">
<p>最後に、<code>sequenceTasks</code> を使って最初の例を書き換えると以下のようになります。</p>
</div>
<div id="promise-sequence-xhr.js" class="listingblock executable">
<div class="title">promise-sequence-xhr.js</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript"><span class="keyword">function</span> <span class="function">sequenceTasks</span>(tasks) {
    <span class="keyword">function</span> <span class="function">recordValue</span>(results, value) {
        results.push(value);
        <span class="keyword">return</span> results;
    }

    const pushValue = recordValue.bind(<span class="predefined-constant">null</span>, []);
    <span class="keyword">return</span> tasks.reduce((promise, task) =&gt; {
        <span class="keyword">return</span> promise.then(task).then(pushValue);
    }, Promise.resolve());
}
<span class="keyword">function</span> <span class="function">fetchURL</span>(URL) {
    <span class="keyword">return</span> <span class="keyword">new</span> Promise((resolve, reject) =&gt; {
        const req = <span class="keyword">new</span> XMLHttpRequest();
        req.open(<span class="string"><span class="delimiter">&quot;</span><span class="content">GET</span><span class="delimiter">&quot;</span></span>, URL, <span class="predefined-constant">true</span>);
        req.onload = () =&gt; {
            <span class="keyword">if</span> (<span class="integer">200</span> &lt;= req.status &amp;&amp; req.status &lt; <span class="integer">300</span>) {
                resolve(req.responseText);
            } <span class="keyword">else</span> {
                reject(<span class="keyword">new</span> Error(req.statusText));
            }
        };
        req.onerror = () =&gt; {
            reject(<span class="keyword">new</span> Error(req.statusText));
        };
        req.send();
    });
}
const request = {
    comment() {
        <span class="keyword">return</span> fetchURL(<span class="string"><span class="delimiter">&quot;</span><span class="content">https://azu.github.io/promises-book/json/comment.json</span><span class="delimiter">&quot;</span></span>).then(JSON.parse);
    },
    people() {
        <span class="keyword">return</span> fetchURL(<span class="string"><span class="delimiter">&quot;</span><span class="content">https://azu.github.io/promises-book/json/people.json</span><span class="delimiter">&quot;</span></span>).then(JSON.parse);
    }
};
<span class="keyword">function</span> <span class="function">main</span>() {
    <span class="keyword">return</span> sequenceTasks([request.comment, request.people]);
}



<span class="comment">// 実行例</span>
main().then((value) =&gt; {
    console.log(value);
}).<span class="keyword">catch</span>((error) =&gt; {
    console.error(error);
});</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>main()</code> の中がかなりスッキリしたことが分かります。</p>
</div>
<div class="paragraph">
<p>このようにPromiseでは、逐次処理ということをするのに色々な書き方ができると思います。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#multiple-xhr.js">thenをその場に並べた書き方</a></p>
</li>
<li>
<p><a href="#promise-foreach-xhr.js">forループを使った書き方</a></p>
</li>
<li>
<p><a href="#promise-reduce-xhr.js">reduceを使った書き方</a></p>
</li>
<li>
<p><a href="#promise-sequence.js">逐次処理する関数を分けた書き方</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>さらに、ここではまだ紹介していませんが、<a href="#chapter5-async-function">Async Function</a>を使う方法もあります。</p>
</div>
<div class="paragraph">
<p>しかし、これはJavaScriptで配列を扱うのにforループや <code>forEach</code> 等、色々やり方があるのと本質的には違いはありません。
そのため、Promiseを扱う場合も処理をまとめられるところは小さく関数に分けて、実装していくのがいいといえるでしょう。</p>
</div>
</div>
<div class="sect3">
<h4 id="_まとめ_11">4.8.4. まとめ</h4>
<div class="paragraph">
<p>このセクションでは、<a href="#Promise.all"><code>Promise.all</code></a>とは違い、
一つづつ順番に処理したい場合に、Promiseでどのように実装していくかについて学びました。</p>
</div>
<div class="paragraph">
<p>手続き的な書き方から、逐次処理を行う関数を定義するところまで見ていき、
Promiseであっても関数に処理を分けるという基本的なことは変わらないことを示しました。</p>
</div>
<div class="paragraph">
<p>Promiseで書くとPromise chainを繋げすぎて縦に長い処理を書いてしまうことがあります。</p>
</div>
<div class="paragraph">
<p>そんな時は基本に振り返り、処理を関数に分けることで全体の見通しを良くすることは大切です。</p>
</div>
<div class="paragraph">
<p>また、Promiseのコンストラクタ関数や <code>then</code> 等は高階関数なので、
処理を関数に分けておくと組み合わせが行い易いという副次的な効果もあるため、意識してみるといいかもしれません。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
高階関数とは引数に関数オブジェクトを受け取る関数のこと
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="chapter5-async-function">5. Chapter.5 - Async Function</h2>
<div class="sectionbody">
<div class="paragraph">
<p>この章では、ECMAScript 2017で導入されたAsync Function(<code>async</code>/<code>await</code>)について学んでいきます。</p>
</div>
<div class="sect2">
<h3 id="async-function">5.1. Async Functionとは</h3>
<div class="paragraph">
<p>Async Functionとは非同期処理を行う関数を定義する構文です。
Async Functionは通常の関数とは異なり、必ず<code>Promise</code>インスタンスを返す関数を定義する構文です。</p>
</div>
<div class="paragraph">
<p>Async Functionは次のように関数の前に<code>async</code>をつけることで定義できます。
この<code>doAsync</code>関数は常に<code>Promise</code>インスタンスを返します。</p>
</div>
<div class="listingblock executable">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript">async <span class="keyword">function</span> <span class="function">doAsync</span>() {
    <span class="keyword">return</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">値</span><span class="delimiter">&quot;</span></span>;
}
<span class="comment">// doAsync関数はPromiseを返す</span>
doAsync().then((value) =&gt; {
    console.log(value); <span class="comment">// =&gt; &quot;値&quot;</span>
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>Async Functionでは<code>return</code>した値の代わりに、<code>Promise.resolve(返り値)</code>のように返り値をラップした<code>Promise</code>インスタンスを返します。
そのため、このAsync Functionは次のように書いた場合と同じ意味になります。</p>
</div>
<div class="listingblock executable">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript"><span class="comment">// 通常の関数でPromiseインスタンスを返している</span>
<span class="keyword">function</span> <span class="function">doAsync</span>() {
    <span class="keyword">return</span> Promise.resolve(<span class="string"><span class="delimiter">&quot;</span><span class="content">値</span><span class="delimiter">&quot;</span></span>);
}
doAsync().then((value) =&gt; {
    console.log(value); <span class="comment">// =&gt; &quot;値&quot;</span>
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>またAsync Function内では<code>await</code>式というPromiseの非同期処理が完了するまで待つ構文が利用できます。
<code>await</code>式を使うことで非同期処理を同期処理のように扱えるため、Promiseチェーンで実現していた処理の流れを読みやすくかけます。</p>
</div>
<div class="paragraph">
<p>Async Functionと<code>await</code>式の大まかな動きをイメージするために、まずはPromise APIで書いたものと比較してみます。</p>
</div>
<div class="paragraph">
<p>ここでは、XHRの現代的なバージョンである <a href="https://developer.mozilla.org/ja/docs/Web/API/Fetch_API">Fetch API</a> を使います。Fetch APIは指定したURLのリソースを読み書きでき、デフォルトでES Promisesに対応しています。</p>
</div>
<div class="paragraph">
<p>次のサンプルコードでは、<code><a href="https://azu.github.io/promises-book/json/book.json" class="bare">https://azu.github.io/promises-book/json/book.json</a></code>というURLからJSONデータを取得して、<code>title</code>プロパティを取り出す<code>getBookTitle</code>関数を実装していきます。</p>
</div>
<div class="paragraph">
<p>取得する<code><a href="https://azu.github.io/promises-book/json/book.json" class="bare">https://azu.github.io/promises-book/json/book.json</a></code>は次のような内容になっています。</p>
</div>
<div id="book.json" class="listingblock">
<div class="title">/json/book.json</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="json">{
    <span class="key"><span class="delimiter">&quot;</span><span class="content">title</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">JavaScript Promiseの本</span><span class="delimiter">&quot;</span></span>,
    <span class="key"><span class="delimiter">&quot;</span><span class="content">repository</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">https://github.com/azu/promises-book</span><span class="delimiter">&quot;</span></span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>まずは、Fetch APIを使って<code>fetchBookTitle</code>関数で取得したタイトルをコンソールに出力してみます。</p>
</div>
<div class="paragraph">
<p><code>fetch</code>メソッドはPromiseを返します。このPromiseインスタンスはリクエストのレスポンスを表す<code>Response</code>オブジェクトでresolveされます。
<code>Response#json</code>メソッドもPromiseを返します。このPromiseインスタンスは取得したリソースをJSONとしてパースしたオブジェクトでresolveされます。</p>
</div>
<div class="paragraph">
<p><code>fetchBookTitle</code>関数は、次のように<code>fetch</code>メソッドで取得したJSONの<code>title</code>プロパティでresolveされるPromiseインスタンスを返します。</p>
</div>
<div class="listingblock executable">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript"><span class="keyword">function</span> <span class="function">fetchBookTitle</span>() {
    <span class="comment">// Fetch APIは指定URLのリソースを取得しPromiseを返す関数</span>
    <span class="keyword">return</span> fetch(<span class="string"><span class="delimiter">&quot;</span><span class="content">https://azu.github.io/promises-book/json/book.json</span><span class="delimiter">&quot;</span></span>).then((res) =&gt; {
        <span class="keyword">return</span> res.json(); <span class="comment">// レスポンスをJSON形式としてパースする</span>
    }).then((json) =&gt; {
        <span class="keyword">return</span> json.title; <span class="comment">// JSONからtitleプロパティを取り出す</span>
    });
}

<span class="keyword">function</span> <span class="function">main</span>() {
    <span class="comment">// `fetchBookTitle`関数は、取得したJSONの`title`プロパティでresolveされる</span>
    fetchBookTitle().then((title) =&gt; {
        console.log(title); <span class="comment">// =&gt; &quot;JavaScript Promiseの本&quot;</span>
    });
}

main();</code></pre>
</div>
</div>
<div class="paragraph">
<p>次は、同様の処理をAsync Functionと<code>await</code>式で実装してみます。
ここではまだ挙動を理解しなくても問題ありませんが、
Promise APIを使っていた場合に比べて、<code>then</code>メソッドやコールバック関数がなくなっていることが分かります。</p>
</div>
<div class="listingblock executable">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript"><span class="comment">// `async`をつけて`fetchBookTitle`関数をAsync Functionとして定義</span>
async <span class="keyword">function</span> <span class="function">fetchBookTitle</span>() {
    <span class="comment">// リクエストしてリソースを取得する</span>
    const res = await fetch(<span class="string"><span class="delimiter">&quot;</span><span class="content">https://azu.github.io/promises-book/json/book.json</span><span class="delimiter">&quot;</span></span>);
    <span class="comment">// レスポンスをJSON形式としてパースする</span>
    const json = await res.json();
    <span class="comment">// JSONからtitleプロパティを取り出す</span>
    <span class="keyword">return</span> json.title;
}

<span class="comment">// `async`をつけて`main`関数をAsync Functionとして定義</span>
async <span class="keyword">function</span> <span class="function">main</span>() {
    <span class="comment">// `await`式で`fetchBookTitle`の非同期処理が完了するまで待つ</span>
    <span class="comment">// `fetchBookTitle`がresolveした値が返り値になる</span>
    const title = await fetchBookTitle();
    console.log(title); <span class="comment">// =&gt; &quot;JavaScript Promiseの本&quot;</span>
}

main();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Async FunctionではPromiseの状態が変化するまで待つ<code>await</code>式という機能を利用できます。
Promiseでは結果を<code>then</code>メソッドのコールバック関数で取得していたのが、<code>await</code>式の右辺にあるPromiseのresolveされた値が左辺の変数へと代入されます。そのため、Async Functionと<code>await</code>式を使うことで非同期処理をまるで同期処理のように書けます。</p>
</div>
<div class="paragraph">
<p>この章では、このAsync Functionと<code>await</code>式について詳しく見ていきます。</p>
</div>
<div class="paragraph">
<p>重要なこととしてAsync FunctionはPromiseの上に作られた構文です。
そのためAsync Functionを理解するには、Promiseを理解する必要があることに注意してください。</p>
</div>
</div>
<div class="sect2">
<h3 id="async-function-syntax">5.2. Async Functionの構文</h3>
<div class="paragraph">
<p>Async Functionは関数の定義に<code>async</code>キーワードをつけることで定義できます。
JavaScriptの関数定義には関数宣言や関数式、Arrow Function、メソッドの短縮記法などがあります。
どの定義方法でも<code>async</code>キーワードを前につけるだけでAsync Functionとして定義できます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript"><span class="comment">// 関数宣言のAsync Function版</span>
async <span class="keyword">function</span> <span class="function">fn1</span>() {}
<span class="comment">// 関数式のAsync Function版</span>
const fn2 = async <span class="keyword">function</span>() {};
<span class="comment">// Arrow FunctionのAsync Function版</span>
const fn3 = async() =&gt; {};
<span class="comment">// メソッドの短縮記法のAsync Function版</span>
const object = {
    async method() {}
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>これらのAsync Functionは、次のこと以外は通常の関数と同じ性質を持ちます。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Async Functionは必ずPromiseを返す</p>
</li>
<li>
<p>Async Function内では<code>await</code>式が利用できる</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="async-function-return-promise">5.2.1. Async FunctionはPromiseを返す</h4>
<div class="paragraph">
<p>Async Functionとして定義した関数は必ず<code>Promise</code>インスタンスを返します。
返される<code>Promise</code>インスタンスの状態は関数の返り値によって異なり、次の3つのケースが考えられます。</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Async FunctionはPromise以外の値をreturnした場合、その返り値をもつ<strong>Fulfilled</strong>なPromiseを返す</p>
</li>
<li>
<p>Async FunctionがPromiseをreturnした場合、その返り値のPromiseをそのまま返す</p>
</li>
<li>
<p>Async Function内で例外が発生した場合は、そのエラーをもつ<strong>Rejected</strong>なPromiseを返す</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>これらの挙動は<code>Promise#then</code>メソッドの返り値とそのコールバック関数が返す値の関係とほぼ同じです。</p>
</div>
<div class="paragraph">
<p>具体的な例を順番に見ていきます。</p>
</div>
<div class="paragraph">
<p>まず、Async FunctionはPromise以外の値をreturnした場合、その返り値で解決される<strong>Fulfilled</strong>なPromiseを返します。
これは、返した値が<code>Promise.resolve</code>されているのとほとんど同じ感覚です。</p>
</div>
<div class="listingblock executable">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript"><span class="comment">// `Promise.resolve(undefined)`を返したのと同じ</span>
async <span class="keyword">function</span> <span class="function">resolveUndefined</span>() {
    <span class="comment">// 何も値を返さない場合は`undefined`を返すのと同じ</span>
}
resolveUndefined().then((value) =&gt; {
    console.log(value); <span class="comment">// =&gt; undefined</span>
});
<span class="comment">// `Promise.resolve(&quot;値&quot;)`を返したのと同じ</span>
async <span class="keyword">function</span> <span class="function">resolveFn</span>() {
    <span class="keyword">return</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">値</span><span class="delimiter">&quot;</span></span>;
}
resolveFn().then((value) =&gt; {
    console.log(value); <span class="comment">// =&gt; &quot;値&quot;</span>
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>次に、 Async FunctionがPromiseをreturnした場合、その返り値のPromiseをそのまま返します。
これは、<code>Promise#then</code>メソッドで<strong>Rejected</strong>なPromiseを返すことで、<code>throw</code>文を使わずにPromiseをrejectする方法と同じです。</p>
</div>
<div class="listingblock executable">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript"><span class="comment">// resolveFnは**Fulfilled**なPromiseインスタンスを返している</span>
<span class="comment">// Async Functionは自動的にPromiseを返すので、単に値を返しても同じ</span>
async <span class="keyword">function</span> <span class="function">resolveFn</span>() {
    <span class="keyword">return</span> Promise.resolve(<span class="string"><span class="delimiter">&quot;</span><span class="content">値</span><span class="delimiter">&quot;</span></span>);
}
resolveFn().then((value) =&gt; {
    console.log(value); <span class="comment">// =&gt; &quot;値&quot;</span>
});

<span class="comment">// rejectFnは**Rejected**なPromiseインスタンスを返している</span>
async <span class="keyword">function</span> <span class="function">rejectFn</span>() {
    <span class="keyword">return</span> Promise.reject(<span class="keyword">new</span> Error(<span class="string"><span class="delimiter">&quot;</span><span class="content">エラーメッセージ</span><span class="delimiter">&quot;</span></span>));
}
rejectFn().<span class="keyword">catch</span>((error) =&gt; {
    console.log(error.message); <span class="comment">// =&gt; &quot;エラーメッセージ&quot;</span>
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>最後に、Async Function内で例外が発生した場合は、そのエラーをもつ<strong>Rejected</strong>なPromiseを返します。
これは、Promise内での処理が自動的に<code>try&#8230;&#8203;catch</code>されているのと同じで、Async Functionでも例外が発生した場合は自動的にキャッチされます。</p>
</div>
<div class="listingblock executable">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript"><span class="comment">// exceptionFnは例外を投げている</span>
async <span class="keyword">function</span> <span class="function">exceptionFn</span>() {
    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string"><span class="delimiter">&quot;</span><span class="content">例外が発生しました</span><span class="delimiter">&quot;</span></span>);
    <span class="comment">// 例外が発生したため、この行は実行されません</span>
}

<span class="comment">// Async Functionで例外が発生するとRejectedなPromiseが返される</span>
exceptionFn().<span class="keyword">catch</span>((error) =&gt; {
    console.log(error.message); <span class="comment">// =&gt; &quot;例外が発生しました&quot;</span>
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>どの場合でも、Async Functionは必ずPromiseを返すことがわかります。
このようにAsync Functionを呼び出す側から見れば、Async FunctionはPromiseを返すただの関数と何も変わりません。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="async-function-await">5.3. <code>await</code>式</h3>
<div class="paragraph">
<p>Async Functionはasync/awaitとも呼ばれることがあります。
この呼ばれ方からも分かるように、Async Functionと<code>await</code>式は共に利用します。</p>
</div>
<div class="paragraph">
<p><code>await</code>式はAsync Function内でのみ利用できます。
<code>await</code>式は右辺の<code>Promise</code>インスタンスが<strong>Fulfilled</strong>または<strong>Rejected</strong>になるまで、その行（文）で非同期処理の完了を待ちます。
そして<code>Promise</code>インスタンスの状態が変わると、次の行（文）から処理を再開します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">async <span class="keyword">function</span> <span class="function">asyncMain</span>() {
    <span class="comment">// PromiseがFulfilledまたはRejectedとなるまで待つ</span>
    await Promise<span class="error">イ</span><span class="error">ン</span><span class="error">ス</span><span class="error">タ</span><span class="error">ン</span><span class="error">ス</span>;
    <span class="comment">// Promiseインスタンスの状態が変わったら処理を再開する</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>通常の処理の流れでは、非同期処理を実行した場合にその非同期処理の完了を待つことなく、次の行（次の文）を実行します。
しかし<code>await</code>式では非同期処理を実行し完了するまで、次の行（次の文）を実行しません。
そのため<code>await</code>式を使うことで非同期処理が同期処理のように上から下へと順番に実行するような流れで書けます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js"><span class="comment">// async functionは必ずPromiseを返す</span>
async <span class="keyword">function</span> <span class="function">doAsync</span>() {
    <span class="comment">// 非同期処理</span>
}
async <span class="keyword">function</span> <span class="function">asyncMain</span>() {
    <span class="comment">// doAsyncの非同期処理が完了するまでまつ</span>
    await doAsync();
    <span class="comment">// 次の行はdoAsyncの非同期処理が完了されるまで実行されない</span>
    console.log(<span class="string"><span class="delimiter">&quot;</span><span class="content">この行は非同期処理が完了後に実行される</span><span class="delimiter">&quot;</span></span>);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>await</code>式は<strong>式</strong>であるため右辺（<code>Promise</code>インスタンス）の評価結果を値として返します。
この<code>await</code>式の評価方法は評価するPromiseの状態（<strong>Fulfilled</strong>または<strong>Rejected</strong>）によって異なります。</p>
</div>
<div class="paragraph">
<p><code>await</code>式の右辺のPromiseが<strong>Fulfilled</strong>となった場合は、resolveされた値が<code>await</code>式の返り値となります。</p>
</div>
<div class="paragraph">
<p>次のコードでは、<code>await</code>式の右辺にある<code>Promise</code>インスタンスは<code>42</code>という値でresolveされています。
そのため<code>await</code>式の返り値は<code>42</code>となり、<code>value</code>変数にもその値が入ります。</p>
</div>
<div class="listingblock executable">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript">async <span class="keyword">function</span> <span class="function">asyncMain</span>() {
    const value = await Promise.resolve(<span class="integer">42</span>);
    console.log(value); <span class="comment">// =&gt; 42</span>
}
asyncMain(); <span class="comment">// Promiseインスタンスを返す</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>これはPromiseを使って書くと次のコードと同様の意味となります。
<code>await</code>式を使うことでコールバック関数を使わずに非同期処理の流れを表現できていることがわかります。</p>
</div>
<div class="listingblock executable">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript"><span class="keyword">function</span> <span class="function">asyncMain</span>() {
    <span class="keyword">return</span> Promise.resolve(<span class="integer">42</span>).then((value) =&gt; {
        console.log(value); <span class="comment">// =&gt; 42</span>
    });
}
asyncMain(); <span class="comment">// Promiseインスタンスを返す</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>await</code>式の右辺のPromiseが<strong>Rejected</strong>となった場合は、その場でエラーを<code>throw</code>します。
また「<a href="#async-function-syntax">async-function-syntax</a>」で紹介したように、Async Function内で発生した例外は自動的にキャッチされます。
そのため<code>await</code>式でPromiseが<strong>Rejected</strong>となった場合は、そのAsync Functionが<strong>Rejected</strong>なPromiseを返すことになります。</p>
</div>
<div class="paragraph">
<p>次のコードでは、<code>await</code>式の右辺にある<code>Promise</code>インスタンスが<strong>Rejected</strong>の状態になっています。
そのため<code>await</code>式は<code>エラー</code>を<code>throw</code>します。そのエラーを自動的にキャッチするため、<code>asyncMain</code>関数は<strong>Rejected</strong>なPromiseを返します。</p>
</div>
<div class="listingblock executable">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript">async <span class="keyword">function</span> <span class="function">asyncMain</span>() {
    const value = await Promise.reject(<span class="keyword">new</span> Error(<span class="string"><span class="delimiter">&quot;</span><span class="content">エラーメッセージ</span><span class="delimiter">&quot;</span></span>));
    <span class="comment">// await式で例外が発生したため、この行は実行されません</span>
}
<span class="comment">// Async Functionは自動的に例外をキャッチできる</span>
asyncMain().<span class="keyword">catch</span>((error) =&gt; {
    console.log(error.message); <span class="comment">// =&gt; &quot;エラーメッセージ&quot;</span>
});</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>await</code>式がエラーを<code>throw</code>するということは、そのエラーは<code>try&#8230;&#8203;catch</code>構文でキャッチできます。
通常の非同期処理では完了する前に次の行が実行されてしまうため<code>try&#8230;&#8203;catch</code>構文ではエラーをキャッチできませんでした。
そのためPromiseでは<code>catch</code>メソッドを使いPromise内で発生したエラーをキャッチしていました。（<a href="#promise-done">Promise.prototype.done とは何か?</a>を参照）</p>
</div>
<div class="paragraph">
<p>次のコードでは、<code>await</code>式で発生した例外を<code>try&#8230;&#8203;catch</code>構文でキャッチしています。</p>
</div>
<div class="listingblock executable">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript">async <span class="keyword">function</span> <span class="function">asyncMain</span>() {
    <span class="comment">// await式のエラーはtry...catchできる</span>
    <span class="keyword">try</span> {
        <span class="comment">// `await`式で評価した右辺のPromiseがRejectedとなったため、例外がthrowされる</span>
        const value = await Promise.reject(<span class="keyword">new</span> Error(<span class="string"><span class="delimiter">&quot;</span><span class="content">エラーメッセージ</span><span class="delimiter">&quot;</span></span>));
        <span class="comment">// await式で例外が発生したため、この行は実行されません</span>
    } <span class="keyword">catch</span> (error) {
        console.log(error.message); <span class="comment">// =&gt; &quot;エラーメッセージ&quot;</span>
    }
}
asyncMain().then(() =&gt; {
    console.log(<span class="string"><span class="delimiter">&quot;</span><span class="content">この行は実行されます</span><span class="delimiter">&quot;</span></span>);
}, (error) =&gt; {
    <span class="comment">// すでにtry...catchされているため、この行は実行されません</span>
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>このように<code>await</code>式を使うことで、<code>try&#8230;&#8203;catch</code>構文のように非同期処理を同期処理と同じ構文を使って扱えます。
またコードの見た目も同期処理と同じように、その行（その文）の処理が完了するまで次の行を評価しないという分かりやすい形になるのは大きな利点です。</p>
</div>
</div>
<div class="sect2">
<h3 id="promise-chain-to-async-function">5.4. Async Functionと配列</h3>
<div class="paragraph">
<p><a href="#ch2-promise-and-array">Promiseと配列</a>のように、配列を元にした複数の非同期処理を扱う場合のAsync Functionについて見ていきます。</p>
</div>
<div class="paragraph">
<p>例として、複数のリソースを順番に取得する処理をPromiseで書いていきます。</p>
</div>
<div class="paragraph">
<p>まずは、Promiseを使った非同期処理を行う関数として、リソースを擬似的に取得する<code>dummyFetch</code>という関数を実装していきます。
<code>dummyFetch</code>関数は擬似的にデータ取得する関数で、1000ミリ秒未満のランダムなタイミングでレスポンスを返す非同期的な処理です。
パスが<code>/resource</code>から始まるリソースを取得した場合は、そのレスポンスをもった<strong>Resolved</strong>状態のPromiseオブジェクトを返します。
それ以外の場合は、リソースの取得に失敗したとして<strong>Rejected</strong>状態のPromiseオブジェクトを返します。</p>
</div>
<div class="listingblock executable">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript"><span class="comment">/**
 * 1000ミリ秒未満のランダムなタイミングでレスポンスを擬似的にデータ取得する関数
 * 指定した`path`にデータがある場合、成功として**Resolved**状態のPromiseオブジェクトを返す
 * 指定した`path`にデータがない場合、失敗として**Rejected**状態のPromiseオブジェクトを返す
 */</span>
<span class="keyword">function</span> <span class="function">dummyFetch</span>(path) {
    <span class="keyword">return</span> <span class="keyword">new</span> Promise((resolve, reject) =&gt; {
        setTimeout(() =&gt; {
            <span class="keyword">if</span> (path.startsWith(<span class="string"><span class="delimiter">&quot;</span><span class="content">/resource</span><span class="delimiter">&quot;</span></span>)) {
                resolve({ <span class="key">body</span>: <span class="error">`</span>Response body of <span class="predefined">$</span>{path}<span class="error">`</span> });
            } <span class="keyword">else</span> {
                reject(<span class="keyword">new</span> Error(<span class="string"><span class="delimiter">&quot;</span><span class="content">NOT FOUND</span><span class="delimiter">&quot;</span></span>));
            }
        }, <span class="integer">1000</span> * Math.random());
    });
}
<span class="comment">// `then`メソッドで成功時と失敗時に呼ばれるコールバック関数を登録</span>
<span class="comment">// /resource/A のリソースは存在するので成功しonFulfilledが呼ばれる</span>
dummyFetch(<span class="string"><span class="delimiter">&quot;</span><span class="content">/resource/A</span><span class="delimiter">&quot;</span></span>).then((response) =&gt; {
    console.log(response); <span class="comment">// =&gt; { body: &quot;Response body of /resource/A&quot; }</span>
}, (error) =&gt; {
    <span class="comment">// この行は実行されません</span>
});
<span class="comment">// /not_found のリソースは存在しないのでonRejectedが呼ばれる</span>
dummyFetch(<span class="string"><span class="delimiter">&quot;</span><span class="content">/not_found</span><span class="delimiter">&quot;</span></span>).then((response) =&gt; {
    <span class="comment">// この行は実行されません</span>
}, (error) =&gt; {
    console.log(error.message); <span class="comment">// =&gt; &quot;NOT FOUND&quot;</span>
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>この<code>dymmyFetch</code>関数を使い、複数のリソースを順番に取得する<code>fetchResources</code>関数を実装していきます。
<code>fetchResources</code>関数は、配列で複数のリソースへのパスを受け取り、取得したリソースの中身(<code>body</code>)を配列として返すことにします。</p>
</div>
<div class="paragraph">
<p>まずは、Promise APIのみを使って<code>fetchResources</code>関数を実装してみましょう。
Promise APIでは、<code>Array#reduce</code>メソッドを使った逐次処理を実装することで、複数の非同期処理を順番に実行できます。
（詳細は<a href="#promise-sequence">Promiseによる逐次処理</a>を参照）</p>
</div>
<div class="listingblock executable">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript"><span class="keyword">function</span> <span class="function">dummyFetch</span>(path) {
    <span class="keyword">return</span> <span class="keyword">new</span> Promise((resolve, reject) =&gt; {
        setTimeout(() =&gt; {
            <span class="keyword">if</span> (path.startsWith(<span class="string"><span class="delimiter">&quot;</span><span class="content">/resource</span><span class="delimiter">&quot;</span></span>)) {
                resolve({ <span class="key">body</span>: <span class="error">`</span>Response body of <span class="predefined">$</span>{path}<span class="error">`</span> });
            } <span class="keyword">else</span> {
                reject(<span class="keyword">new</span> Error(<span class="string"><span class="delimiter">&quot;</span><span class="content">NOT FOUND</span><span class="delimiter">&quot;</span></span>));
            }
        }, <span class="integer">1000</span> * Math.random());
    });
}
<span class="comment">// 複数のリソースを取得し、レスポンスボディの配列を返す</span>
<span class="keyword">function</span> <span class="function">fetchResources</span>(resources) {
    const results = [];
    <span class="comment">// 配列をpromise chainにして順番に処理する</span>
    <span class="keyword">return</span> resources.reduce((promise, resource) =&gt; {
        <span class="keyword">return</span> promise.then(() =&gt; {
            <span class="keyword">return</span> dummyFetch(resource).then((response) =&gt; {
                results.push(response.body);
                <span class="keyword">return</span> results;
            });
        });
    }, Promise.resolve());
}
const resources = [<span class="string"><span class="delimiter">&quot;</span><span class="content">/resource/A</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">/resource/B</span><span class="delimiter">&quot;</span></span>];
<span class="comment">// リソースを取得して出力する</span>
fetchResources(resources).then((results) =&gt; {
    console.log(results); <span class="comment">// =&gt; [&quot;Response body of /resource/A&quot;, &quot;Response body of /resource/B&quot;]</span>
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>次に、先ほどと同じ処理をする<code>fetchResources</code>をAsync Functionと<code>await</code>式で書いてみます。
Async Functionとして定義した<code>fetchResources</code>関数では、forループの中で<code>await</code>式を使うことで複数の非同期処理を順番に実行できます。</p>
</div>
<div class="paragraph">
<p>次のコードでは、リソースのパスをforループで順番に、<code>dummyFetch</code>関数を使ってリソースの中身を取得しています。
forループによる反復処理も<code>await</code>式で<code>dummyFetch</code>関数の完了を待っているため、その非同期処理が終ってから次の反復処理を行います。
すべてのforループの処理が終わると、<code>fetchResources</code>関数が返したPromiseオブジェクトが変数<code>results</code>が参照する値でresolveされます。</p>
</div>
<div class="listingblock executable">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript"><span class="keyword">function</span> <span class="function">dummyFetch</span>(path) {
    <span class="keyword">return</span> <span class="keyword">new</span> Promise((resolve, reject) =&gt; {
        setTimeout(() =&gt; {
            <span class="keyword">if</span> (path.startsWith(<span class="string"><span class="delimiter">&quot;</span><span class="content">/resource</span><span class="delimiter">&quot;</span></span>)) {
                resolve({ <span class="key">body</span>: <span class="error">`</span>Response body of <span class="predefined">$</span>{path}<span class="error">`</span> });
            } <span class="keyword">else</span> {
                reject(<span class="keyword">new</span> Error(<span class="string"><span class="delimiter">&quot;</span><span class="content">NOT FOUND</span><span class="delimiter">&quot;</span></span>));
            }
        }, <span class="integer">1000</span> * Math.random());
    });
}
<span class="comment">// 複数のリソースを取得し、レスポンスボディの配列を返す</span>
async <span class="keyword">function</span> <span class="function">fetchResources</span>(resources) {
    const results = [];
    <span class="keyword">for</span> (let i = <span class="integer">0</span>; i &lt; resources.length; i++) {
        const resource = resources[i];
        const response = await dummyFetch(resource);
        results.push(response.body);
    }
    <span class="keyword">return</span> results;
}
const resources = [<span class="string"><span class="delimiter">&quot;</span><span class="content">/resource/A</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">/resource/B</span><span class="delimiter">&quot;</span></span>];
<span class="comment">// リソースを取得して出力する</span>
fetchResources(resources).then((results) =&gt; {
    console.log(results); <span class="comment">// =&gt; [&quot;Response body of /resource/A&quot;, &quot;Response body of /resource/B&quot;]</span>
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>Promise APIのみで<code>fetchResources</code>関数書いた場合は、コールバックの中で処理するためややこしい見た目になりがちです。
一方で、Async Functionと<code>await</code>式を使った場合は、非同期処理での取得と追加を順番に行うだけとなりネストがなく見た目はシンプルです。</p>
</div>
<div class="sect3">
<h4 id="await-in-async-function">5.4.1. <code>await</code>式はAsync Functionの中でのみ利用可能</h4>
<div class="paragraph">
<p>先ほどの<code>fetchResources</code>関数ではforループを利用していました。
このとき、配列の反復処理に<code>Array#forEach</code>メソッドを利用したくなるかもしれません。</p>
</div>
<div class="paragraph">
<p>しかし、次のようにforループを<code>Array#forEach</code>に変更するだけでは、構文エラー（Syntax Error）となってしまいます。</p>
</div>
<div class="listingblock executable">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript">async <span class="keyword">function</span> <span class="function">fetchResources</span>(resources) {
    const results = [];
    <span class="comment">// Syntax Errorとなる例</span>
    resources.forEach(<span class="keyword">function</span>(resources) {
        const resource = resources[i];
        <span class="comment">// Async Functionではないスコープで`await`式を利用しているためSyntax Errorとなる</span>
        const response = await dummyFetch(resource);
        results.push(response.body);
    });
    <span class="keyword">return</span> results;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>これは、<code>await</code>式はAsync Functionの直下でのみ利用できるからです。</p>
</div>
<div class="paragraph">
<p>Async Functionではない通常の関数で<code>await</code>式を使うとSyntax Errorとなります。
これは間違った<code>await</code>式の使い方を防止するための仕様です。</p>
</div>
<div class="listingblock executable">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript"><span class="keyword">function</span> <span class="function">main</span>(){
    <span class="comment">// Syntax Error</span>
    await Promise.resolve();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Async Function内で<code>await</code>式を使って処理を待っている間も、関数の外側では通常とおり処理が進みます。
次のコードを実行してみると、Async Function内で<code>await</code>しても、Async Function外の処理は停止していないことがわかります。</p>
</div>
<div class="listingblock executable">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript">async <span class="keyword">function</span> <span class="function">asyncMain</span>() {
    <span class="comment">// 中でawaitしても、Async Functionの外側の処理まで止まるわけではない</span>
    await <span class="keyword">new</span> Promise((resolve) =&gt; {
        setTimeout(resolve, <span class="integer">16</span>);
    });
}
console.log(<span class="string"><span class="delimiter">&quot;</span><span class="content">1. asyncMain関数を呼び出します</span><span class="delimiter">&quot;</span></span>);
<span class="comment">// Async Functionは外から見れば単なるPromiseを返す関数</span>
asyncMain().then(() =&gt; {
    console.log(<span class="string"><span class="delimiter">&quot;</span><span class="content">3. asyncMain関数が完了しました</span><span class="delimiter">&quot;</span></span>);
});
<span class="comment">// Async Functionの外側の処理はそのまま進む</span>
console.log(<span class="string"><span class="delimiter">&quot;</span><span class="content">2. asyncMain関数外では、次の行が同期的に呼び出される</span><span class="delimiter">&quot;</span></span>);</code></pre>
</div>
</div>
<div class="paragraph">
<p>このように<code>await</code>式で非同期処理を一時停止しても、Async Function外の処理が停止するわけではありません。
Async Function外の処理も停止できてしまうと、JavaScriptでは基本的にメインスレッドで多くの処理をするため、UIを含めた他の処理が止まってしまいます。
これが<code>await</code>式がAsync Functionの外で利用できない理由の一つです。</p>
</div>
<div class="paragraph">
<p><code>await</code>式はAsync Functionの中でのみ利用可能なため、コールバック関数もAsync Functionとして定義しないと<code>await</code>式が利用できないことに注意してください。</p>
</div>
<div class="paragraph">
<p>そのため、<code>fetchResources</code>関数の<code>Array#forEach</code>メソッドのコールバック関数に対して、<code>async</code>キーワードをつけることで構文エラーは発生しなくなります。
この場合は、コールバック関数がAsync Functionとなるため、コールバック関数内で<code>await</code>式が利用できます。
しかし、コールバック関数をAsync Functionに修正するだけでは、<code>fetchResources</code>関数が意図した結果を返しません。</p>
</div>
<div class="paragraph">
<p>次のように<code>Array#forEach</code>メソッドのコールバック関数をAsync Functionにしてみます。
このコードを実行してみると、<code>fetchResources</code>関数の返したPromiseの結果は空の配列となり、意図した結果にならないことが分かります。</p>
</div>
<div class="listingblock executable">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript"><span class="keyword">function</span> <span class="function">dummyFetch</span>(path) {
    <span class="keyword">return</span> <span class="keyword">new</span> Promise((resolve, reject) =&gt; {
        setTimeout(() =&gt; {
            <span class="keyword">if</span> (path.startsWith(<span class="string"><span class="delimiter">&quot;</span><span class="content">/resource</span><span class="delimiter">&quot;</span></span>)) {
                resolve({ <span class="key">body</span>: <span class="error">`</span>Response body of <span class="predefined">$</span>{path}<span class="error">`</span> });
            } <span class="keyword">else</span> {
                reject(<span class="keyword">new</span> Error(<span class="string"><span class="delimiter">&quot;</span><span class="content">NOT FOUND</span><span class="delimiter">&quot;</span></span>));
            }
        }, <span class="integer">1000</span> * Math.random());
    });
}
<span class="comment">// リソースを順番に取得する</span>
async <span class="keyword">function</span> <span class="function">fetchResources</span>(resources) {
    const results = [];
    resources.forEach(async(resource) =&gt; {
        const response = await dummyFetch(resource);
        results.push(response.body);
    });
    <span class="keyword">return</span> results;
}
const resources = [<span class="string"><span class="delimiter">&quot;</span><span class="content">/resource/A</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">/resource/B</span><span class="delimiter">&quot;</span></span>];
<span class="comment">// リソースを取得して出力する</span>
fetchResources(resources).then((results) =&gt; {
    <span class="comment">// resultsは空になってしまう</span>
    console.log(results); <span class="comment">// =&gt; []</span>
});</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>forEach</code>メソッドのコールバック関数としてAsync Functionを渡し、コールバック関数中で<code>await</code>式を利用して非同期処理の完了を待っています。
しかし、この非同期処理の完了を待つのはコールバック関数Async Functionの中だけで、外側では<code>fetchResources</code>関数の処理が進んでいます。
そのため、コールバック関数で<code>results</code>に結果を追加する前に、<code>fetchResources</code>関数はその時点の変数<code>results</code>の値でresolveしてしまいます。</p>
</div>
<div class="paragraph">
<p>次のように<code>fetchResources</code>関数にコンソール出力を入れてみると動作が分かりやすいでしょう。
<code>forEach</code>メソッドのコールバック関数が完了するのは、<code>fetchResources</code>関数の呼び出しがすべて終わった後になります。
そのため<code>fetchResources</code>関数はその時点の変数<code>results</code>の値である空の配列でresolveします。</p>
</div>
<div class="listingblock executable">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript"><span class="keyword">function</span> <span class="function">dummyFetch</span>(path) {
    <span class="keyword">return</span> <span class="keyword">new</span> Promise((resolve, reject) =&gt; {
        setTimeout(() =&gt; {
            <span class="keyword">if</span> (path.startsWith(<span class="string"><span class="delimiter">&quot;</span><span class="content">/resource</span><span class="delimiter">&quot;</span></span>)) {
                resolve({ <span class="key">body</span>: <span class="error">`</span>Response body of <span class="predefined">$</span>{path}<span class="error">`</span> });
            } <span class="keyword">else</span> {
                reject(<span class="keyword">new</span> Error(<span class="string"><span class="delimiter">&quot;</span><span class="content">NOT FOUND</span><span class="delimiter">&quot;</span></span>));
            }
        }, <span class="integer">1000</span> * Math.random());
    });
}
<span class="comment">// リソースを順番に取得する</span>
async <span class="keyword">function</span> <span class="function">fetchResources</span>(resources) {
    const results = [];
    console.log(<span class="string"><span class="delimiter">&quot;</span><span class="content">1. fetchResourcesを開始</span><span class="delimiter">&quot;</span></span>);
    resources.forEach(async(resource) =&gt; {
        console.log(<span class="error">`</span><span class="integer">2</span>. <span class="predefined">$</span>{resource}<span class="error">の</span><span class="error">取</span><span class="error">得</span><span class="error">開</span><span class="error">始</span><span class="error">`</span>);
        const response = await dummyFetch(resource);
        console.log(<span class="error">`</span><span class="integer">3</span>. <span class="predefined">$</span>{resource}<span class="error">の</span><span class="error">取</span><span class="error">得</span><span class="error">完</span><span class="error">了</span><span class="error">`</span>);
        results.push(response.body);
    });
    console.log(<span class="string"><span class="delimiter">&quot;</span><span class="content">4. fetchResourcesを終了</span><span class="delimiter">&quot;</span></span>);
    <span class="keyword">return</span> results;
}
const resources = [<span class="string"><span class="delimiter">&quot;</span><span class="content">/resource/A</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">/resource/B</span><span class="delimiter">&quot;</span></span>];
<span class="comment">// リソースを取得して出力する</span>
fetchResources(resources).then((results) =&gt; {
    console.log(results); <span class="comment">// =&gt; []</span>
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>この問題を解決する方法として、先ほどのようにコールバック関数を使わずにforループを使う方法があります。
また、リソースを順番が重要ではない場合は、<code>Promise.all</code>メソッドを使い、複数の非同期処理を1つのPromiseとしてまとめる方法があります。</p>
</div>
</div>
<div class="sect3">
<h4 id="relationship-promise-async-function">5.4.2. PromiseとAsync Functionを組み合わせる</h4>
<div class="paragraph">
<p>Async Functionと<code>await</code>式でも非同期処理を同期処理のような見た目で書けます。
しかし、非同期処理は必ずしも順番に処理することが重要ではない場合があります。
その際に、forループと<code>await</code>式で書くと複数の非同期処理を順番に行ってしまい無駄な待ち時間を作ってしまうコードになってしまいます。</p>
</div>
<div class="paragraph">
<p>先ほど<code>fetchResources</code>関数ではリソースAを取得し終わってから、リソースBを取得していました。
このとき、取得順が変わっても問題無い場合は、リソースAとリソースBを同時に取得する方が効率的です。</p>
</div>
<div class="paragraph">
<p><code>Promise.all</code>メソッドを使い、リソースAとリソースBを取得する非同期処理を1つの<code>Promise</code>インスタンスにまとめることができます。
<code>await</code>式が評価するのは<code>Promise</code>インスタンスであるため、<code>await</code>式は<code>Promise.all</code>メソッドなど<code>Promise</code>インスタンスを返す処理と組み合わせて利用できます。</p>
</div>
<div class="paragraph">
<p>そのため、先ほど<code>fetchResources</code>関数でリソースを同時に取得する場合は、次のように書けます。
<code>Promise.all</code>メソッドは複数のPromiseを配列で受け取り、それを1つのPromiseとしてまとめたものを返す関数です。
<code>Promise.all</code>メソッドの返す<code>Promise</code>インスタンスを<code>await</code>することで、非同期処理の結果を配列としてまとめて取得できます。</p>
</div>
<div class="listingblock executable">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript"><span class="keyword">function</span> <span class="function">dummyFetch</span>(path) {
    <span class="keyword">return</span> <span class="keyword">new</span> Promise((resolve, reject) =&gt; {
        setTimeout(() =&gt; {
            <span class="keyword">if</span> (path.startsWith(<span class="string"><span class="delimiter">&quot;</span><span class="content">/resource</span><span class="delimiter">&quot;</span></span>)) {
                resolve({ <span class="key">body</span>: <span class="error">`</span>Response body of <span class="predefined">$</span>{path}<span class="error">`</span> });
            } <span class="keyword">else</span> {
                reject(<span class="keyword">new</span> Error(<span class="string"><span class="delimiter">&quot;</span><span class="content">NOT FOUND</span><span class="delimiter">&quot;</span></span>));
            }
        }, <span class="integer">1000</span> * Math.random());
    });
}

<span class="comment">// 複数のリソースを取得しレスポンスボディの配列を返す</span>
async <span class="keyword">function</span> <span class="function">fetchResources</span>(resources) {
    <span class="comment">// リソースをまとめて取得する</span>
    const promises = resources.map((resource) =&gt; {
        <span class="keyword">return</span> dummyFetch(resource);
    });
    <span class="comment">// すべてのリソースが取得できるまで待つ</span>
    <span class="comment">// Promise.allは [ResponseA, ResponseB] のように結果が配列となる</span>
    const responses = await Promise.all(promises);
    <span class="comment">// 取得した結果からレスポンスのボディだけを取り出す</span>
    <span class="keyword">return</span> responses.map((response) =&gt; {
        <span class="keyword">return</span> response.body;
    });
}
const resources = [<span class="string"><span class="delimiter">&quot;</span><span class="content">/resource/A</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">/resource/B</span><span class="delimiter">&quot;</span></span>];
<span class="comment">// リソースを取得して出力する</span>
fetchResources(resources).then((results) =&gt; {
    console.log(results); <span class="comment">// =&gt; [&quot;Response body of /resource/A&quot;, &quot;Response body of /resource/B&quot;]</span>
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>このようにAsync Functionや<code>await</code>式は既存のPromise APIと組み合わせて利用できます。
Async Functionも内部的にPromiseの仕組みを利用した構文です。
そのため、Async FunctionとPromiseのAPIを組み合わせて考えることは重要です。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="promise-api-reference">6. Promises API Reference</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="promise.then">6.1. Promise#then</h3>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript">promise.then(onFulfilled, onRejected);</code></pre>
</div>
</div>
<div class="listingblock executable">
<div class="title">thenコード例</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript">const promise = <span class="keyword">new</span> Promise((resolve, reject) =&gt; {
    resolve(<span class="string"><span class="delimiter">&quot;</span><span class="content">thenに渡す値</span><span class="delimiter">&quot;</span></span>);
});
promise.then((value) =&gt; {
    console.log(value);
}, (error) =&gt; {
    console.error(error);
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>promiseオブジェクトに対してonFulfilledとonRejectedのハンドラを定義し、
新たなpromiseオブジェクトを作成して返す。</p>
</div>
<div class="paragraph">
<p>このハンドラはpromiseがresolve または rejectされた時にそれぞれ呼ばれる。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>定義されたハンドラ内で返した値は、新たなpromiseオブジェクトのonFulfilledに対して渡される。</p>
</li>
<li>
<p>定義されたハンドラ内で例外が発生した場合は、新たなpromiseオブジェクトのonRejectedに対して渡される。</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="promise.catch">6.2. Promise#catch</h3>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript">promise.<span class="keyword">catch</span>(onRejected);</code></pre>
</div>
</div>
<div class="listingblock executable">
<div class="title">catchのコード例</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript">const promise = <span class="keyword">new</span> Promise((resolve, reject) =&gt; {
    resolve(<span class="string"><span class="delimiter">&quot;</span><span class="content">thenに渡す値</span><span class="delimiter">&quot;</span></span>);
});
promise.then((value) =&gt; {
    console.log(value);
}).<span class="keyword">catch</span>((error) =&gt; {
    console.error(error);
});</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>promise.then(undefined, onRejected)</code> と同等の意味をもつシンタックスシュガー。</p>
</div>
</div>
<div class="sect2">
<h3 id="promise.finally">6.3. Promise#finally</h3>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript">promise.<span class="keyword">finally</span>(onFinally);</code></pre>
</div>
</div>
<div class="listingblock executable">
<div class="title">finallyのコード例</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript">let isLoading = <span class="predefined-constant">true</span>;

fetch(<span class="string"><span class="delimiter">&quot;</span><span class="content">https://httpbin.org/get</span><span class="delimiter">&quot;</span></span>).then((response) =&gt; {
    <span class="keyword">if</span> (response.ok) {
        <span class="keyword">return</span> response.json();
    }
    <span class="keyword">throw</span> <span class="keyword">new</span> TypeError(<span class="string"><span class="delimiter">&quot;</span><span class="content">正しくデータを取得できなかった</span><span class="delimiter">&quot;</span></span>);
  })
  .then((json) =&gt; {
      console.log(<span class="string"><span class="delimiter">&quot;</span><span class="content">リクエストが成功した</span><span class="delimiter">&quot;</span></span>, json);
   })
  .<span class="keyword">catch</span>((error) =&gt; {
      console.error(<span class="string"><span class="delimiter">&quot;</span><span class="content">リクエストが失敗した</span><span class="delimiter">&quot;</span></span>, error);
   })
  .<span class="keyword">finally</span>(() =&gt; {
      <span class="comment">// 成功、失敗どちらの場合も必ず呼ばれる処理</span>
      isLoading = <span class="predefined-constant">false</span>;
  });</code></pre>
</div>
</div>
<div class="paragraph">
<p>Promise chainが成功、失敗どちらの場合でも呼ばれるハンドラを登録し、新しいpromiseオブジェクトを作成して返す。
返したpromiseオブジェクトは、finallyの呼び出し元となったpromiseオブジェクトの状態を引き継ぐ。</p>
</div>
</div>
<div class="sect2">
<h3 id="Promise.resolve">6.4. Promise.resolve</h3>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript">Promise.resolve(promise);
Promise.resolve(thenable);
Promise.resolve(object);</code></pre>
</div>
</div>
<div class="listingblock executable">
<div class="title">Promise.resolveのコード例</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript">const taskName = <span class="string"><span class="delimiter">&quot;</span><span class="content">task 1</span><span class="delimiter">&quot;</span></span>;
asyncTask(taskName).then((value) =&gt; {
    console.log(value);
}).<span class="keyword">catch</span>((error) =&gt; {
    console.error(error);
});
<span class="keyword">function</span> <span class="function">asyncTask</span>(name) {
    <span class="keyword">return</span> Promise.resolve(name).then((value) =&gt; {
        <span class="keyword">return</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Done! </span><span class="delimiter">&quot;</span></span> + value;
    });
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>受け取った値に応じたpromiseオブジェクトを返す。</p>
</div>
<div class="paragraph">
<p>どの場合でもpromiseオブジェクトを返すが、大きく分けて以下の3種類となる。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">promiseオブジェクトを受け取った場合</dt>
<dd>
<p>受け取ったpromiseオブジェクトをそのまま返す</p>
</dd>
<dt class="hdlist1">thenableなオブジェクトを受け取った場合</dt>
<dd>
<p><code>then</code> をもつオブジェクトを新たなpromiseオブジェクトにして返す</p>
</dd>
<dt class="hdlist1">その他の値(オブジェクトやnull等も含む)を受け取った場合</dt>
<dd>
<p>その値でresolveされる新たなpromiseオブジェクトを作り返す</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="Promise.reject">6.5. Promise.reject</h3>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript">Promise.reject(object);</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Promise.rejectのコード例</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript">const failureStub = sinon.stub(xhr, <span class="string"><span class="delimiter">&quot;</span><span class="content">request</span><span class="delimiter">&quot;</span></span>).returns(Promise.reject(<span class="keyword">new</span> Error(<span class="string"><span class="delimiter">&quot;</span><span class="content">bad!</span><span class="delimiter">&quot;</span></span>)));</code></pre>
</div>
</div>
<div class="paragraph">
<p>受け取った値でrejectされた新たなpromiseオブジェクトを返す。</p>
</div>
<div class="paragraph">
<p>Promise.rejectに渡す値は <code>Error</code> オブジェクトとすべきである。</p>
</div>
<div class="paragraph">
<p>また、Promise.resolveとは異なり、promiseオブジェクトを渡した場合も常に新たなpromiseオブジェクトを作成する。</p>
</div>
<div class="listingblock executable">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript">const r = Promise.reject(<span class="keyword">new</span> Error(<span class="string"><span class="delimiter">&quot;</span><span class="content">error</span><span class="delimiter">&quot;</span></span>));
console.log(r === Promise.reject(r));<span class="comment">// false</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="Promise.all">6.6. Promise.all</h3>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript">Promise.all(promiseArray);</code></pre>
</div>
</div>
<div class="listingblock executable">
<div class="title">Promise.allのコード例</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript">const p1 = Promise.resolve(<span class="integer">1</span>);
const p2 = Promise.resolve(<span class="integer">2</span>);
const p3 = Promise.resolve(<span class="integer">3</span>);
Promise.all([p1, p2, p3]).then((results) =&gt; {
    console.log(results);  <span class="comment">// [1, 2, 3]</span>
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>新たなpromiseオブジェクトを作成して返す。</p>
</div>
<div class="paragraph">
<p>渡されたpromiseオブジェクトの配列が全てresolveされた時に、
新たなpromiseオブジェクトはその値でresolveされる。</p>
</div>
<div class="paragraph">
<p>どれかの値がrejectされた場合は、その時点で新たなpromiseオブジェクトはrejectされる。</p>
</div>
<div class="paragraph">
<p>渡された配列の値はそれぞれ <code>Promise.resolve</code> にラップされるため、
promiseオブジェクト以外が混在している場合も扱える。</p>
</div>
</div>
<div class="sect2">
<h3 id="Promise.race">6.7. Promise.race</h3>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript">Promise.race(promiseArray);</code></pre>
</div>
</div>
<div class="listingblock executable">
<div class="title">Promise.raceのコード例</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript">const p1 = Promise.resolve(<span class="integer">1</span>);
const p2 = Promise.resolve(<span class="integer">2</span>);
const p3 = Promise.resolve(<span class="integer">3</span>);
Promise.race([p1, p2, p3]).then((value) =&gt; {
    console.log(value);  <span class="comment">// 1</span>
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>新たなpromiseオブジェクトを作成して返す。</p>
</div>
<div class="paragraph">
<p>渡されたpromiseオブジェクトの配列のうち、
一番最初にresolve または rejectされたpromiseにより、
新たなpromiseオブジェクトはその値でresolve または rejectされる。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="promise-glossary">7. 用語集</h2>
<div class="sectionbody">
<div class="dlist">
<dl>
<dt class="hdlist1">Promises</dt>
<dd>
<p>プロミスという仕様そのもの</p>
</dd>
<dt class="hdlist1">promiseオブジェクト</dt>
<dd>
<p>プロミスオブジェクト、<code>Promise</code> のインスタンスオブジェクトのこと</p>
</dd>
</dl>
</div>
<div id="es-promises" class="dlist">
<dl>
<dt class="hdlist1">ES Promises</dt>
<dd>
<p><a href="https://tc39.es/ecma262/">ECMAScriptの仕様</a> を明示的に示す場合にprefixとして <em>ES</em> をつける</p>
</dd>
</dl>
</div>
<div id="promises-aplus" class="dlist">
<dl>
<dt class="hdlist1">Promises/A+</dt>
<dd>
<p><a href="http://promises-aplus.github.io/promises-spec/">Promises/A+</a>のこと。
ES Promisesの前身となったコミュニティベースの仕様であり、ES Promisesとは多くの部分が共通している。</p>
</dd>
</dl>
</div>
<div id="Thenable" class="dlist">
<dl>
<dt class="hdlist1">Thenable</dt>
<dd>
<p>Promiseライクなオブジェクトのこと。
<code>.then</code> というメソッドをもつオブジェクト。</p>
</dd>
</dl>
</div>
<div id="promise-chain" class="dlist">
<dl>
<dt class="hdlist1">promise chain</dt>
<dd>
<p>promiseオブジェクトを <code>then</code> や <code>catch</code> のメソッドチェーンでつなげたもの。
この用語は書籍中のものであり、<a href="#es-promises">ES6 Promises</a>で定められた用語ではありません。</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect1">
<h2 id="resouce-link">8. 参考サイト</h2>
<div class="sectionbody">
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="https://github.com/w3ctag/promises-guide">w3ctag/promises-guide</a> <a href="https://triple-underscore.github.io/promises-guide-ja.html">（日本語訳）</a></dt>
<dd>
<p>Promisesのガイド - 概念的な説明はここから得たものが多い</p>
</dd>
<dt class="hdlist1"><a href="https://github.com/domenic/promises-unwrapping">domenic/promises-unwrapping</a></dt>
<dd>
<p>ES Promisesの仕様の元となったリポジトリ - issueを検索して得た経緯や情報も多い</p>
</dd>
<dt class="hdlist1"><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-promise-objects">ECMAScript 2015 Language Specification – ECMA-262 6th Edition</a></dt>
<dd>
<p>ECMAScript 2015におけるPromiseの仕様書 - PromiseはES2015で導入された</p>
</dd>
<dt class="hdlist1"><a href="https://tc39.es/ecma262/">ECMAScript® Language Specification</a></dt>
<dd>
<p>ECMAScriptの仕様書 - 最新の仕様</p>
</dd>
<dt class="hdlist1"><a href="http://www.html5rocks.com/ja/tutorials/es6/promises/">JavaScript Promises: There and back again - HTML5 Rocks</a></dt>
<dd>
<p>Promisesについての記事 - 完成度がとても高くサンプルコードやリファレンス等を参考にした</p>
</dd>
<dt class="hdlist1"><a href="http://d.hatena.ne.jp/jovi0608/20140319/1395199285">Node.jsにPromiseが再びやって来た！ - ぼちぼち日記</a></dt>
<dd>
<p>Node.jsとPromiseの記事 - <em>thenable</em>について参考にした</p>
</dd>
<dt class="hdlist1"><a href="https://exploringjs.com/">Exploring JS: JavaScript books for programmers</a></dt>
<dd>
<p>ECMAScript全般について詳しく書かれている書籍</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect1">
<h2 id="about-author">9. 著者について</h2>
<div class="sectionbody">
<div class="paragraph">
<p><span class="image"><img src="Appendix-Glossary/img/simple320_320.png" alt="azu" width="32" height="32"></span>
<strong><a href="https://github.com/azu/">azu</a></strong> (Twitter : @<a href="https://twitter.com/azu_re">azu_re</a> )</p>
</div>
<div class="paragraph">
<p>ブラウザ、JavaScriptの最新技術を常に追いかけている。</p>
</div>
<div class="paragraph">
<p>目的を手段にしてしまうことを得意としている(この書籍もその結果できた)。</p>
</div>
<div class="paragraph">
<p><a href="https://efcl.info/">Web Scratch</a> や <a href="https://jser.info/">JSer.info</a> といったサイトを運営している。</p>
</div>
<div class="sect2">
<h3 id="omake-message">9.1. 著者へのメッセージ/おまけ</h3>
<div class="paragraph">
<p>以下の <a href="https://gumroad.com/l/javascript-promise">おまけ.pdf</a> では、
この書籍を書き始めた理由や、どのように書いていったか、テストなどについて書かれています。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://gumroad.com/l/javascript-promise">JavaScript Promiseの本のおまけ</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Gumroadから無料 または 好きな値段でダウンロードすることができます。</p>
</div>
<div class="paragraph">
<p>ダウンロードする際に作者へのメッセージも書けるので、
メッセージを残すついでにダウンロードして行ってください。</p>
</div>
<div class="paragraph">
<p>問題の指摘などがありましたら、GitHubやGitterに書いてくださると解決できます。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/azu/promises-book/issues?state=open">Issues · azu/promises-book</a></p>
</li>
<li>
<p><a href="https://gitter.im/azu/promises-book">azu/promises-book - Gitter</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Version 2.0.0<br>
Last updated 2025-06-14 10:53:56 UTC
</div>
</div>
</body>
</html>