<?xml version="1.0" encoding="UTF-8"?>
<?asciidoc-toc?>
<!DOCTYPE article [<!ENTITY % db5ent PUBLIC "-//FOPUB//ENTITIES Entities for DocBook 5" "db5.ent"> %db5ent;]>
<article xmlns="http://docbook.org/ns/docbook" xmlns:xl="http://www.w3.org/1999/xlink" version="5.0" xml:lang="en">
<info>
<title>JavaScript Promiseの本</title>
<date>2021-12-20</date>
<author>
<personname>
<firstname>azu</firstname>
</personname>
</author>
<authorinitials>azu</authorinitials>
</info>
<simpara><inlinemediaobject>
<imageobject>
<imagedata fileref="./images/icons/globe.png"/>
</imageobject>
<textobject><phrase>globe</phrase></textobject>
</inlinemediaobject> This book has been released in :</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Chinese</emphasis>: <link xl:href="http://liubin.github.io/promises-book/">JavaScript Promise迷你书（中文版）</link></simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Korean</emphasis>: <link xl:href="http://www.hanbit.co.kr/store/books/look.php?p_code=E5027975256">한빛미디어 eBook JavaScript Promise（번역서）</link></simpara>
</listitem>
</itemizedlist>
<simpara>These translated is based on Promise Book ver 1.</simpara>
<itemizedlist>
<listitem>
<simpara><link xl:href="https://azu.github.io/promises-book/archives/v1/">JavaScript Promiseの本(v1)</link></simpara>
</listitem>
</itemizedlist>
<simpara><?asciidoc-hr?></simpara>
<simpara><?asciidoc-pagebreak?></simpara>
<section xml:id="introduction">
<title>はじめに</title>
<section xml:id="_書籍の目的">
<title>書籍の目的</title>
<simpara>この書籍はJavaScript標準仕様の<link linkend="es-promises">ECMAScript Promises</link>を中心にし、
JavaScriptにおけるPromiseについて学ぶことが目的です。</simpara>
<simpara>この書籍では、次の3つを目標としています。</simpara>
<itemizedlist>
<listitem>
<simpara>Promiseについて学び、パターンやテストを扱えること</simpara>
</listitem>
<listitem>
<simpara>Promiseの向き不向きについて学び、何でもPromiseで解決するべきではないと知ること</simpara>
</listitem>
<listitem>
<simpara>ES Promisesを元に基本をよく学び、より発展した形を自分で形成できること</simpara>
</listitem>
</itemizedlist>
<simpara>この書籍では、先程も述べたように<link linkend="es-promises">ES Promises</link>、
つまりJavaScriptの標準仕様(ECMAScript)をベースとしたPromiseについて書かれています。</simpara>
<simpara>そのため、FirefoxやChromeなどモダンなブラウザでは、ライブラリを使うこと無く利用できる機能であり、
またES Promisesは元が<link linkend="promises-aplus">Promises/A+</link>というコミュニティベースの仕様であるため、多くの実装ライブラリがあります。</simpara>
<simpara>ブラウザネイティブの機能、またはライブラリを使うことで今すぐ利用できるPromiseについて基本的なAPIから学んでいきます。
その中でPromiseの得意/不得意を知り、Promiseを活用したJavaScriptを書けることを目的としています。</simpara>
</section>
<section xml:id="_本書を読むにあたって">
<title>本書を読むにあたって</title>
<simpara>この書籍では、JavaScriptの基本的な文法や機能をすでに学習している前提です。</simpara>
<simpara>次のいずれかの書籍を読んでいれば、十分読み解ける内容だと思います。</simpara>
<itemizedlist>
<listitem>
<simpara><link xl:href="https://www.oreilly.co.jp/books/9784873113913/">JavaScript: The Good Parts</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://www.oreilly.co.jp/books/9784873114880/">JavaScriptパターン</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://www.oreilly.co.jp/books/9784873117836/">初めてのJavaScript 第3版</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://www.oreilly.co.jp/books/9784873115733/">JavaScript 第6版</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://gihyo.jp/book/2011/978-4-7741-4813-7">パーフェクトJavaScript</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://gihyo.jp/book/2016/978-4-7741-8411-1">改訂新版JavaScript本格入門</link></simpara>
</listitem>
</itemizedlist>
<simpara>この書籍ではECMAScript 2015(ES2015)で追加された構文を利用するため、JavaScriptの基本的な文法や機能に不安がある方は、次の書籍を参照してください。
ES2015以降をベースに、JavaScriptの基礎を一から学べる書籍です。
この書籍と同一の著者によって書かれており、ウェブでも公開されています。</simpara>
<itemizedlist>
<listitem>
<simpara><link xl:href="https://jsprimer.net">JavaScript Primer #jsprimer</link></simpara>
</listitem>
</itemizedlist>
<simpara>または、JavaScriptでウェブアプリケーションを書いた経験やNode.js でコマンドラインアプリやサーバサイドを書いたことがあれば、
どこかで見たことがある内容が出てくるかもしれません。</simpara>
<simpara>一部セクションではNode.js環境での話となるため、Node.jsについて軽くでも知っておくとより理解がしやすいと思います。</simpara>
</section>
<section xml:id="_表記法">
<title>表記法</title>
<simpara>この書籍では短縮するために幾つかの表記を用いています。</simpara>
<itemizedlist>
<listitem>
<simpara>Promiseに関する用語は<link linkend="promise-glossary">用語集</link>を参照する。</simpara>
<itemizedlist>
<listitem>
<simpara>大体、初回に出てきた際にはリンクを貼っています。</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>インスタンスメソッドを instance#method という表記で示す。</simpara>
<itemizedlist>
<listitem>
<simpara>たとえば、<literal>Promise#then</literal> という表記は、Promiseのインスタンスオブジェクトの <literal>then</literal> メソッドを示しています。</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>オブジェクトメソッドを object.method という表記で示す。</simpara>
<itemizedlist>
<listitem>
<simpara>これはJavaScriptの意味そのままで、<literal>Promise.all</literal> なら静的メソッドを示しています。</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<note>
<simpara>この部分には文章についての補足が書かれています。</simpara>
</note>
</section>
<section xml:id="_本書のソースコード_ライセンス">
<title>本書のソースコード/ライセンス</title>
<simpara>この書籍に登場するサンプルのソースコード また その文章のソースコードは全てGitHubから取得できます。</simpara>
<simpara>この書籍は <link xl:href="http://asciidoctor.org/">AsciiDoc</link> という形式で書かれています。</simpara>
<itemizedlist>
<listitem>
<simpara><link xl:href="https://github.com/azu/promises-book">azu/promises-book</link> <inlinemediaobject>
<imageobject>
<imagedata fileref="https://travis-ci.org/azu/promises-book.svg?branch=master"/>
</imageobject>
<textobject><phrase>Build Status</phrase></textobject>
</inlinemediaobject></simpara>
</listitem>
</itemizedlist>
<simpara>また、リポジトリには書籍中に出てくるサンプルコードのテストも含まれています。</simpara>
<simpara>ソースコードのライセンスはMITライセンスで、文章はCC-BY-NCで利用できます。</simpara>
</section>
<section xml:id="_意見や疑問点">
<title>意見や疑問点</title>
<simpara>意見や疑問点がある場合はGitHubに直接Issueを作成できます。</simpara>
<itemizedlist>
<listitem>
<simpara><link xl:href="https://github.com/azu/promises-book/issues?state=open">Issues · azu/promises-book</link></simpara>
</listitem>
</itemizedlist>
<simpara>また、この書籍についての <link xl:href="https://gitter.im/azu/promises-book">チャットページ</link> に書いていくのもいいでしょう。</simpara>
<simpara>Twitterでのハッシュタグは <inlinemediaobject>
<imageobject>
<imagedata fileref="./images/icons/twitter.png"/>
</imageobject>
<textobject><phrase>twitter</phrase></textobject>
</inlinemediaobject> <link xl:href="https://twitter.com/search?q=%23Promise%E6%9C%AC">#Promise本</link>
なので、こちらを利用するのもいいでしょう。</simpara>
<simpara>この書籍は読める権利と同時に編集する権利があるため、
GitHubで <link xl:href="https://github.com/azu/promises-book/pulls">Pull Requests</link> も歓迎しています。</simpara>
</section>
</section>
<section xml:id="chapter1-what-is-promise">
<title>Chapter.1 - Promiseとは何か</title>
<simpara>この章では、JavaScriptにおけるPromiseについて簡単に紹介していきます。</simpara>
<section xml:id="what-is-promise">
<title>What Is Promise</title>
<simpara>まずPromiseとはそもそもどのようなものでしょうか?</simpara>
<simpara>Promiseは非同期処理を抽象化したオブジェクトとそれを操作する仕組みのことをいいます。
詳しくはこれから学んでいくとして、PromiseはJavaScriptで発見された概念ではありません。</simpara>
<simpara>最初に発見されたのは <link xl:href="http://erights.org/elib/distrib/pipeline.html">E言語</link>におけるもので、
並列/並行処理におけるプログラミング言語のデザインの一種です。</simpara>
<simpara>このデザインをJavaScriptに持ってきたものが、この書籍で学ぶJavaScript Promiseです。
Promiseは、JavaScriptの仕様を決めるECMAScript 2015で導入され動作が定義されています。</simpara>
<simpara>一方、JavaScriptにおける非同期処理といえば、コールバックを利用する場合が多いと思います。</simpara>
<formalpara>
<title>コールバックを使った非同期処理の一例</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">getAsync("fileA.txt", (error, result) =&gt; { <co xml:id="CO1-1"/>
    if (error) { // 取得失敗時の処理
        throw error;
    }
    // 取得成功の処理
});</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO1-1">
<para>コールバック関数の引数には(エラーオブジェクト, 結果)が入る</para>
</callout>
</calloutlist>
<simpara>Node.js等JavaScriptでのコールバック関数の第一引数には <literal>Error</literal> オブジェクトを渡すというルールを用いるケースがあります。</simpara>
<simpara>このようにコールバックでの非同期処理もルールが統一されていた場合、コールバック関数の書き方が明確になります。
しかし、これはあくまでコーディングルールであるため、異なる書き方をしても決して間違いではありません。</simpara>
<simpara>Promiseでは、このような非同期に対するオブジェクトとルールを仕様化して、
統一的なインターフェースで書くようになっており、それ以外の書き方は出来ないようになっています。</simpara>
<formalpara>
<title>Promiseを使った非同期処理の一例</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">const promise = getAsyncPromise("fileA.txt"); <co xml:id="CO2-1"/>
promise.then((result) =&gt; {
    // 取得成功の処理
}).catch((error) =&gt; {
    // 取得失敗時の処理
});</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO2-1">
<para>promiseオブジェクトを返す</para>
</callout>
</calloutlist>
<simpara>非同期処理を抽象化したpromiseオブジェクトというものを用意し、
そのpromiseオブジェクトに対して成功時の処理と失敗時の処理の関数を登録するようにして使います。</simpara>
<simpara>コールバック関数と比べると何が違うのかを簡単に見ると、
非同期処理の書き方がpromiseオブジェクトのインターフェースに沿った書き方に限定されます。</simpara>
<simpara>つまり、promiseオブジェクトに用意されているメソッド(ここでは <literal>then</literal> や <literal>catch</literal>)以外は使えないため、
コールバックのように引数に何を入れるかが自由に決められるわけではなく、一定のやり方に統一されます。</simpara>
<simpara>この、Promiseという統一されたインターフェースがあることで、
そのインターフェースにおけるさまざまな非同期処理のパターンを形成することができます。</simpara>
<simpara>つまり、複雑な非同期処理等を上手くパターン化できるというのがPromiseの役割であり、
Promiseを使う理由の一つであるといえるでしょう。</simpara>
<simpara>それでは、実際にJavaScriptでのPromiseについて学んでいきましょう。</simpara>
<note>
<title>Arrow Function <literal>&#8658;</literal></title>
<simpara>この書籍のサンプルコードはArrow FunctionなどECMAScript 2015で導入された構文を利用します。</simpara>
<simpara>Arrow Functionは、矢印のような <literal>&#8658;</literal> （イコールと大なり記号）を使い、匿名関数を定義する構文です。
関数式と定義方法や使い方は同じです。</simpara>
<programlisting language="javascript" linenumbering="unnumbered">// 関数式の定義と実行
const fn = function (arg) {
    console.log("通常の関数定義, 引数:" + arg)
}
fn("引数");

// Arrow Functionの定義と実行
const arrowFunction = (arg) =&gt; {
    console.log("Arrow Functionでの関数定義, 引数:" + arg);
}
arrowFunction("引数");</programlisting>
<simpara>通常の関数式と`&#8658;`という記法を使う以外にも次のような特徴があります。</simpara>
<simpara>Arrow Functionには次のような特徴があります。</simpara>
<itemizedlist>
<listitem>
<simpara>名前を付けることができない（常に匿名関数）</simpara>
</listitem>
<listitem>
<simpara><literal>this</literal> が静的に決定できる</simpara>
</listitem>
<listitem>
<simpara><literal>function</literal> キーワードに比べて短く書くことができる</simpara>
</listitem>
<listitem>
<simpara><literal>new</literal> できない（コンストラクタ関数ではない）</simpara>
</listitem>
<listitem>
<simpara><literal>arguments</literal> 変数を参照できない(Rest Parametersを代わりに利用する)</simpara>
</listitem>
</itemizedlist>
<simpara>Arrow Functionを使うことで、コールバック関数を関数式に比べて短く簡潔に書くことができます。
そのため、この書籍ではArrow Functionをメインに利用しています。</simpara>
<simpara>Arrow Functionの詳細は <link xl:href="https://jsprimer.net">JavaScript Primer</link> を参照してください。</simpara>
<itemizedlist>
<listitem>
<simpara><link xl:href="https://jsprimer.net/basic/function-declaration/#arrow-function">関数と宣言 · JavaScript Primer #jsprimer</link></simpara>
</listitem>
</itemizedlist>
</note>
</section>
<section xml:id="promises-overview">
<title>Promise Overview</title>
<simpara><link linkend="es-promises">ES Promises</link>の仕様で定義されているAPIはそこまで多くはありません。</simpara>
<simpara>大きく分けて以下の3種類になります。</simpara>
<simpara><emphasis role="strong">Constructor</emphasis></simpara>
<simpara>Promiseは <literal>XMLHttpRequest</literal> のように、コンストラクタ関数である <literal>Promise</literal> からインスタンスとなる
promiseオブジェクトを作成して利用します。</simpara>
<simpara>promiseオブジェクトを作成するには、<literal>Promise</literal> コンストラクタを <literal>new</literal> でインスタンス化します。</simpara>
<programlisting language="javascript" linenumbering="unnumbered">const promise = new Promise((resolve, reject) =&gt; {
    // 非同期の処理
    // 処理が終わったら、resolve または rejectを呼ぶ
});</programlisting>
<simpara><emphasis role="strong">Instance Method</emphasis></simpara>
<simpara>newによって生成されたpromiseオブジェクトにはpromiseの値を <emphasis role="strong">resolve</emphasis>(成功) / <emphasis role="strong">reject</emphasis>(失敗) した時に呼ばれる
コールバック関数を登録するために <literal>promise.then()</literal> というインスタンスメソッドがあります。</simpara>
<programlisting language="javascript" linenumbering="unnumbered">promise.then(onFulfilled, onRejected);</programlisting>
<variablelist>
<varlistentry>
<term>resolve(成功)した時</term>
<listitem>
<simpara><literal>onFulfilled</literal> が呼ばれる</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>reject(失敗)した時</term>
<listitem>
<simpara><literal>onRejected</literal>  が呼ばれる</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><literal>onFulfilled</literal>、<literal>onRejected</literal> どちらもオプショナルな引数となっています。</simpara>
<simpara><literal>promise.then</literal> では成功時と失敗時の処理を同時に登録することができます。
また、エラー処理だけを書きたい場合には <literal>promise.then(undefined, onRejected)</literal> と同じ意味である
<literal>promise.catch(onRejected)</literal> を使うことができます。</simpara>
<programlisting language="javascript" linenumbering="unnumbered">promise.catch(onRejected);</programlisting>
<simpara><emphasis role="strong">Static Method</emphasis></simpara>
<simpara><literal>Promise</literal> というグローバルオブジェクトには幾つかの静的なメソッドが存在します。</simpara>
<simpara><literal>Promise.all()</literal> や <literal>Promise.resolve()</literal> などが該当し、Promiseを扱う上での補助メソッドが中心となっています。</simpara>
<section xml:id="_promise_workflow">
<title>Promise workflow</title>
<simpara>以下のようなサンプルコードを見てみましょう。</simpara>
<formalpara xml:id="promise-workflow.js" role="executable">
<title>promise-workflow.js</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">function asyncFunction() {
    <co xml:id="CO3-1"/>
    return new Promise((resolve) =&gt; {
        setTimeout(() =&gt; {
            resolve("Async Hello world");
        }, 16);
    });
}
<co xml:id="CO3-2"/>
asyncFunction().then((value) =&gt; {
    console.log(value); // =&gt; 'Async Hello world'
}).catch((error) =&gt; {
    console.error(error);
});</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO3-1">
<para>Promiseコンストラクタを <literal>new</literal> して、promiseオブジェクトを返します</para>
</callout>
<callout arearefs="CO3-2">
<para>&lt;1&gt;のpromiseオブジェクトに対して <literal>.then</literal> で値が返ってきた時のコールバックを設定します</para>
</callout>
</calloutlist>
<simpara><literal>asyncFunction</literal> という関数 は promiseオブジェクトを返していて、
そのpromiseオブジェクトに対して <literal>then</literal> でresolveした時のコールバックを、
<literal>catch</literal> でエラーとなった場合のコールバックを設定しています。</simpara>
<simpara>このpromiseオブジェクトはsetTimeoutで16ms後にresolveされるので、
そのタイミングで <literal>then</literal> のコールバックが呼ばれ <literal>'Async Hello world'</literal> と出力されます。</simpara>
<simpara>この場合 <literal>catch</literal> のコールバックは呼ばれることはないですが、
<literal>setTimeout</literal> が存在しない環境などでは、例外が発生し <literal>catch</literal> で登録したコールバック関数が呼ばれると思います。</simpara>
<simpara>もちろん、<literal>promise.then(onFulfilled, onRejected)</literal> というように、
<literal>catch</literal> を使わずに <literal>then</literal> を使い、以下のように2つのコールバック関数を設定することでもほぼ同様の動作になります。</simpara>
<programlisting language="javascript" linenumbering="unnumbered">asyncFunction().then((value) =&gt; {
    console.log(value);
}, (error) =&gt; {
    console.error(error);
});</programlisting>
</section>
<section xml:id="promise-states">
<title>Promiseの状態</title>
<simpara>Promiseの処理の流れが少しわかった所で、Promiseの状態について整理したいと思います。</simpara>
<simpara><literal>new Promise</literal> でインスタンス化したpromiseオブジェクトには以下の3つの状態が存在します。</simpara>
<variablelist>
<varlistentry>
<term>Fulfilled</term>
<listitem>
<simpara>resolve(成功)した時。このとき <literal>onFulfilled</literal> が呼ばれる</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Rejected</term>
<listitem>
<simpara>reject(失敗)した時。このとき <literal>onRejected</literal>  が呼ばれる</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Pending</term>
<listitem>
<simpara>FulfilledまたはRejectedではない時。つまりpromiseオブジェクトが作成された初期状態等が該当する</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>これらの状態は<link linkend="es-promises">ES Promises</link>の仕様で定められている名前です。
この状態をプログラムで直接触る方法は用意されていないため、書く際には余り気にしなくても問題ないですが、
Promiseについて理解するのに役に立ちます。</simpara>
<simpara>この書籍では、<emphasis>Pending</emphasis>、<emphasis>Fulfilled</emphasis> 、<emphasis>Rejected</emphasis> の状態を用いて解説していきます。</simpara>
<figure>
<title>promise states</title>
<mediaobject>
<imageobject>
<imagedata fileref="Ch1_WhatsPromises/img/promise-states.png"/>
</imageobject>
<textobject><phrase>promise-states</phrase></textobject>
</mediaobject>
</figure>
<note>
<simpara><link linkend="es-promises">ES Promisesの仕様</link> では <literal>[[PromiseStatus]]</literal> という内部定義によって状態が定められています。
<literal>[[PromiseStatus]]</literal> にアクセスするユーザーAPIは用意されていないため、基本的には知る方法はありません。</simpara>
</note>
<simpara>3つの状態を見たところで、すでにこの章で全ての状態が出てきていることが分かります。</simpara>
<simpara>promiseオブジェクトの状態は、一度<emphasis>Pending</emphasis>から<emphasis>Fulfilled</emphasis>や<emphasis>Rejected</emphasis>になると、
そのpromiseオブジェクトの状態はそれ以降変化することはなくなります。</simpara>
<simpara>つまり、PromiseはEvent等とは違い、<literal>.then</literal> で登録した関数が呼ばれるのは1回限りということが明確になっています。</simpara>
<simpara>また、<emphasis>Fulfilled</emphasis>と<emphasis>Rejected</emphasis>のどちらかの状態であることを<emphasis role="strong">Settled</emphasis>(不変の)と表現することがあります。</simpara>
<variablelist>
<varlistentry>
<term>Settled</term>
<listitem>
<simpara>resolve(成功) または reject(失敗) した時。</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Pending</emphasis>と<emphasis>Settled</emphasis>が対となる関係であると考えると、Promiseの状態の種類/遷移がシンプルであることが分かると思います。</simpara>
<simpara>このpromiseオブジェクトの状態が変化した時に、一度だけ呼ばれる関数を登録するのが <literal>.then</literal> といったメソッドとなるわけです。</simpara>
<note>
<simpara><link xl:href="https://speakerdeck.com/kerrick/javascript-promises-thinking-sync-in-an-async-world">JavaScript Promises - Thinking Sync in an Async World // Speaker Deck</link>
というスライドではPromiseの状態遷移について分かりやすく書かれています。</simpara>
</note>
</section>
</section>
<section xml:id="how-to-write-promise">
<title>Promiseの書き方</title>
<simpara>Promiseの基本的な書き方について解説します。</simpara>
<section xml:id="_promiseオブジェクトの作成">
<title>promiseオブジェクトの作成</title>
<simpara>promiseオブジェクトを作る流れは以下のようになっています。</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara><literal>new Promise(fn)</literal> の返り値がpromiseオブジェクト</simpara>
</listitem>
<listitem>
<simpara><literal>fn</literal> には非同期等の何らかの処理を書く</simpara>
<itemizedlist>
<listitem>
<simpara>処理結果が正常なら、<literal>resolve(結果の値)</literal> を呼ぶ</simpara>
</listitem>
<listitem>
<simpara>処理結果がエラーなら、<literal>reject(Errorオブジェクト)</literal> を呼ぶ</simpara>
</listitem>
</itemizedlist>
</listitem>
</orderedlist>
<simpara>この流れに沿っているものを実際に書いてみましょう。</simpara>
<simpara>非同期処理であるXMLHttpRequest(XHR)を使いデータを取得するものをPromiseで書いていきます。</simpara>
<section xml:id="_xhrのpromiseオブジェクトを作る">
<title>XHRのpromiseオブジェクトを作る</title>
<simpara>まずは、XHRをPromiseを使って包んだような <literal>fetchURL</literal> という関数を作ります。</simpara>
<formalpara xml:id="xhr-promise.js" role="executable">
<title>xhr-promise.js</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">function fetchURL(URL) {
    return new Promise((resolve, reject) =&gt; {
        const req = new XMLHttpRequest();
        req.open("GET", URL, true);
        req.onload = () =&gt; {
            if (200 &lt;= req.status &amp;&amp; req.status &lt; 300) {
                resolve(req.responseText);
            } else {
                reject(new Error(req.statusText));
            }
        };
        req.onerror = () =&gt; {
            reject(new Error(req.statusText));
        };
        req.send();
    });
}

// 実行例
const URL = "https://httpbin.org/get";
fetchURL(URL).then(function onFulfilled(value){
    console.log(value);
}).catch(function onRejected(error){
    console.error(error);
});</programlisting>
</para>
</formalpara>
<simpara>この <literal>fetchURL</literal> では、
XHRでの取得結果のステータスコードが200以上300未満の場合は <literal>resolve</literal> - つまり取得に成功、
それ以外はエラーであるとして <literal>reject</literal> しています。</simpara>
<simpara><literal>resolve(req.responseText)</literal> ではレスポンスの内容を引数に入れています。
resolveの引数に入れる値には特に決まりはありませんが、コールバックと同様に次の処理へ渡したい値を入れるといいでしょう。
(この値は <literal>then</literal> メソッドで受け取ることができます)</simpara>
<simpara>Node.jsをやっている人は、コールバックを書く時に <literal>callback(error, response)</literal> と第一引数にエラーオブジェクトを
入れることがよくあると思いますが、Promiseでは役割がresolve/rejectで分担されているので、
resolveにはresponseの値のみをいれるだけで問題ありません。</simpara>
<simpara>次に、<literal>reject</literal> の方を見ていきましょう。</simpara>
<simpara>XHRで <literal>onerror</literal> のイベントが呼ばれた場合はもちろんエラーなので <literal>reject</literal> を呼びます。
ここで <literal>reject</literal> に渡している値に注目してみてください。</simpara>
<simpara>エラーの場合は <literal>reject(new Error(req.statusText));</literal> というように、Errorオブジェクトを作成して渡していることが分かると思います。
<literal>reject</literal> に渡す値に制限はありませんが、一般的にErrorオブジェクト(またはErrorオブジェクトを継承したもの)を渡すことになっています。</simpara>
<simpara><literal>reject</literal> に渡す値は、rejectする理由を書いたErrorオブジェクトとなっています。
今回は、ステータスコードが2xx以外であるならrejectするとしていたため、<literal>reject</literal> にはstatusTextを入れています。
(この値は <literal>then</literal> メソッドの第二引数 or <literal>catch</literal> メソッドで受け取ることができます)</simpara>
</section>
</section>
<section xml:id="_promiseオブジェクトに処理を書く">
<title>promiseオブジェクトに処理を書く</title>
<simpara>先ほどの作成したpromiseオブジェクトを返す関数を実際に使ってみましょう。</simpara>
<programlisting language="javascript" linenumbering="unnumbered">fetchURL("https://httpbin.org/get"); // =&gt; promiseオブジェクトが返ってくる</programlisting>
<simpara><link linkend="promises-overview">Promises Overview</link> でも簡単に紹介したようにpromiseオブジェクトは幾つかインスタンスメソッドを持っており、
これを使いpromiseオブジェクトの状態に応じて一度だけ呼ばれるコールバックとなる関数を登録します。</simpara>
<simpara>promiseオブジェクトに登録する処理は以下の2種類が主となります。</simpara>
<itemizedlist>
<listitem>
<simpara>promiseオブジェクトが <emphasis role="strong">resolve</emphasis> された時の処理(onFulfilled)</simpara>
</listitem>
<listitem>
<simpara>promiseオブジェクトが <emphasis role="strong">reject</emphasis> された時の処理(onRejected)</simpara>
</listitem>
</itemizedlist>
<figure xml:id="promise-value-flow">
<title>promise value flow</title>
<mediaobject>
<imageobject>
<imagedata fileref="Ch1_WhatsPromises/img/promise-onFulfilled_onRejected.png"/>
</imageobject>
<textobject><phrase>promise-resolve-flow</phrase></textobject>
</mediaobject>
</figure>
<simpara>まずは、<literal>fetchURL</literal> で通信が成功して値が取得できた場合の処理を書いてみましょう。</simpara>
<simpara>この場合の <emphasis>通信が成功した</emphasis> というのは、
resolveされたことにより <emphasis>promiseオブジェクトがFulfilledの状態になった</emphasis> 時ということですね。</simpara>
<simpara><emphasis role="strong">resolve</emphasis>された時の処理は、 <link linkend="promise.then"><literal>.then</literal></link> メソッドに呼びたい関数を渡すことで行えます。</simpara>
<programlisting language="javascript" linenumbering="unnumbered">const URL = "https://httpbin.org/get";
fetchURL(URL).then(function onFulfilled(value){ <co xml:id="CO4-1"/>
    console.log(value);
});</programlisting>
<calloutlist>
<callout arearefs="CO4-1">
<para>分かりやすくするため関数に <literal>onFulfilled</literal> という名前を付けています</para>
</callout>
</calloutlist>
<simpara><link linkend="xhr-promise.js">fetchURL関数</link> 内で <literal>resolve(req.responseText);</literal> によってpromiseオブジェクトが解決されると、
値と共に <literal>onFulfilled</literal> 関数が呼ばれます。</simpara>
<simpara>このままでは通信エラーが起きた場合などに何も処理がされないため、
今度は、<literal>fetchURL</literal> で何らかの問題があってエラーが起きた場合の処理を書いてみましょう。</simpara>
<simpara>この場合の <emphasis>エラーが起きた</emphasis> というのは、
rejectされたことより <emphasis>promiseオブジェクトがRejectedの状態になった</emphasis> 時ということですね。</simpara>
<simpara><emphasis role="strong">reject</emphasis>された時の処理は、<link linkend="promise.then"><literal>.then</literal> の第二引数</link> または <link linkend="promise.catch"><literal>.catch</literal></link> メソッドに呼びたい関数を渡すことで行えます。</simpara>
<simpara>先ほどのソースにrejectされた場合の処理を追加してみましょう。</simpara>
<programlisting language="javascript" linenumbering="unnumbered">const URL = "https://httpbin.org/status/500"; <co xml:id="CO5-1"/>
fetchURL(URL).then(function onFulfilled(value){
    console.log(value);
}).catch(function onRejected(error){ <co xml:id="CO5-2"/>
    console.error(error);
});</programlisting>
<calloutlist>
<callout arearefs="CO5-1">
<para>サーバはステータスコード500のレスポンスを返す</para>
</callout>
<callout arearefs="CO5-2">
<para>分かりやすくするため関数 <literal>onRejected</literal> という名前を付けています</para>
</callout>
</calloutlist>
<simpara><literal>fetchURL</literal> の処理中に何らかの理由で例外が起きた場合、または明示的にrejectされた場合に、
その理由(Errorオブジェクト)と共に <link linkend="promise.catch"><literal>.catch</literal></link> の処理が呼ばれます。</simpara>
<simpara><link linkend="promise.catch"><literal>.catch</literal></link>は <literal>promise.then(undefined, onRejected)</literal> のエイリアスであるため、
同様の処理は以下のように書くこともできます。</simpara>
<programlisting xml:id="catch-as-alias" language="javascript" linenumbering="unnumbered">fetchURL(URL).then(onFulfilled, onRejected);<co xml:id="CO6-1"/></programlisting>
<calloutlist>
<callout arearefs="CO6-1">
<para>onFulfilled, onRejected それぞれは先ほどと同じ関数</para>
</callout>
</calloutlist>
<simpara>基本的には、<link linkend="promise.catch"><literal>.catch</literal></link>を使いresolveとrejectそれぞれを別々に処理した方がよいと考えられますが、
両者の違いについては <link linkend="then-or-catch">then or catch?</link> で紹介します。</simpara>
<section xml:id="_まとめ">
<title>まとめ</title>
<simpara>この章では以下のことについて簡単に紹介しました。</simpara>
<itemizedlist>
<listitem>
<simpara><literal>new Promise</literal> を使ったpromiseオブジェクトの作成</simpara>
</listitem>
<listitem>
<simpara><link linkend="promise.then"><literal>.then</literal></link> や <link linkend="promise.catch"><literal>.catch</literal></link> を使ったpromiseオブジェクトの処理</simpara>
</listitem>
</itemizedlist>
<simpara>Promiseの基本的な書き方について学びました。
他の多くの処理はこれを発展させたり、用意された静的メソッドを利用したものになります。</simpara>
<simpara>ここでは、同様のことはコールバック関数を渡す形でもできるのに対してPromiseで書くメリットについては触れていませんでした。
次の章では、Promiseのメリットであるエラーハンドリングの仕組みをコールバックベースの実装と比較しながら見ていきたいと思います。</simpara>
</section>
</section>
</section>
</section>
<section xml:id="chapter2-how-to-write-promise">
<title>Chapter.2 - Promiseの書き方</title>
<simpara>この章では、Promiseのメソッドの使い方、エラーハンドリングについて学びます。</simpara>
<section xml:id="ch2-promise-resolve">
<title>Promise.resolve</title>
<simpara>一般に <literal>new Promise()</literal> を使うことでpromiseオブジェクトを生成しますが、
それ以外にもpromiseオブジェクトを生成する方法があります。</simpara>
<simpara>ここでは、<link linkend="Promise.resolve"><literal>Promise.resolve</literal></link> と <link linkend="Promise.reject"><literal>Promise.reject</literal></link> について学びたいと思います。</simpara>
<section xml:id="_new_promiseのショートカット">
<title>new Promiseのショートカット</title>
<simpara><link linkend="Promise.resolve"><literal>Promise.resolve(value)</literal></link> という静的メソッドは、
<literal>new Promise()</literal> のショートカットとなるメソッドです。</simpara>
<simpara>たとえば、 <literal>Promise.resolve(42);</literal> というのは下記のコードのシンタックスシュガーです。</simpara>
<programlisting language="javascript" linenumbering="unnumbered">new Promise((resolve) =&gt; {
    resolve(42);
});</programlisting>
<simpara>結果的にすぐに <literal>resolve(42);</literal> と解決されて、次のthenの <literal>onFulfilled</literal> に設定された関数に <literal>42</literal> という値を渡します。</simpara>
<simpara><literal>Promise.resolve(value);</literal> で返ってくる値も同様にpromiseオブジェクトなので、
以下のように続けて <literal>.then</literal> を使った処理を書くことができます。</simpara>
<programlisting role="executable" language="javascript" linenumbering="unnumbered">Promise.resolve(42).then((value) =&gt; {
    console.log(value);
});</programlisting>
<simpara><link linkend="Promise.resolve">Promise.resolve</link>は <literal>new Promise()</literal> のショートカットとして、
promiseオブジェクトの初期化時やテストコードを書く際にも活用できます。</simpara>
</section>
<section xml:id="_thenable">
<title>Thenable</title>
<simpara>もう一つ <literal>Promise.resolve</literal> の大きな特徴として、<link linkend="Thenable">thenable</link>なオブジェクトをpromiseオブジェクトに変換するという機能があります。</simpara>
<simpara><link linkend="es-promises">ES Promises</link>には<link linkend="Thenable">Thenable</link>という概念があり、簡単にいえばpromiseっぽいオブジェクトのことを言います。</simpara>
<simpara><literal>.length</literal> を持っているが配列ではないものをArray likeというのと同じで、
thenableの場合は <literal>.then</literal> というメソッドを持ってるオブジェクトを言います。</simpara>
<simpara>thenableなオブジェクトがもつ <literal>then</literal> は、Promiseのもつ <literal>then</literal> と同じような挙動を期待していて、
thenableなオブジェクトがもつ元々の <literal>then</literal> を上手く利用できるようにしpromiseオブジェクトに変換するという仕組みです。</simpara>
<simpara>どのようなものがthenableなのかというと、分かりやすい例では
<link xl:href="https://api.jquery.com/jQuery.ajax/">jQuery.ajax()</link>の返り値もthenableです。</simpara>
<simpara><literal>jQuery.ajax()</literal> の返り値は <link xl:href="http://api.jquery.com/jQuery.ajax/#jqXHR">jqXHR Object</link> というもので、
このオブジェクトは <literal>.then</literal> というメソッドを持っているためです。</simpara>
<programlisting language="javascript" linenumbering="unnumbered">$.ajax("https://httpbin.org/get");// =&gt; `.then` をもつオブジェクト</programlisting>
<simpara>このthenableなオブジェクトを <literal>Promise.resolve</literal> ではpromiseオブジェクトにすることができます。</simpara>
<simpara>promiseオブジェクトにすることができれば、<literal>then</literal> や <literal>catch</literal> といった、
<link linkend="es-promises">ES Promises</link>がもつ機能をそのまま利用することができるようになります。</simpara>
<formalpara>
<title>thenableをpromiseオブジェクトにする</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">// このサンプルコードはjQueryをロードしている場所でないと動きません
const promise = Promise.resolve($.ajax("https://httpbin.org/get"));// =&gt; promiseオブジェクト
promise.then((value) =&gt; {
    console.log(value);
});</programlisting>
</para>
</formalpara>
<warning>
<title>jQueryとthenable</title>
<simpara><link xl:href="https://api.jquery.com/jQuery.ajax/">jQuery.ajax()</link>の返り値も <literal>.then</literal> というメソッドを持った <link xl:href="http://api.jquery.com/jQuery.ajax/#jqXHR">jqXHR Object</link>で、
このオブジェクトは <link xl:href="http://api.jquery.com/category/deferred-object/">Deferred Object</link> のメソッドやプロパティ等を継承しています。</simpara>
<simpara>しかし、jQuery 2.x以下では、このDeferred Objectは<link linkend="promises-aplus">Promises/A+</link>や<link linkend="es-promises">ES Promises</link>に準拠したものではありません。
そのため、Deferred Objectをpromiseオブジェクトへ変換できたように見えて、一部欠損する情報がでてしまうという問題があります。</simpara>
<simpara>この問題はjQueryの <link xl:href="http://api.jquery.com/category/deferred-object/">Deferred Object</link> の <literal>then</literal> の挙動が違うために発生します。</simpara>
<simpara>そのため、<literal>.then</literal> というメソッドを持っていた場合でも、必ずES Promisesとして使えるとは限らないことは知っておくべきでしょう。</simpara>
<itemizedlist>
<listitem>
<simpara><link xl:href="http://www.html5rocks.com/ja/tutorials/es6/promises/#toc-lib-compatibility">JavaScript Promises: There and back again - HTML5 Rocks</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="http://domenic.me/2012/10/14/youre-missing-the-point-of-promises/">You&#39;re Missing the Point of Promises</link></simpara>
</listitem>
</itemizedlist>
<simpara>なお、jQuery 3.0からは、 <link xl:href="http://api.jquery.com/category/deferred-object/">Deferred Object</link>や <link xl:href="http://api.jquery.com/jQuery.ajax/#jqXHR">jqXHR Object</link>が<link linkend="promises-aplus">Promises/A+</link>準拠へと変更されています。
そのため、上記で紹介されている <literal>.then</literal> の挙動が異なる問題は解消されています。</simpara>
<itemizedlist>
<listitem>
<simpara><link xl:href="https://blog.jquery.com/2016/06/09/jquery-3-0-final-released/">jQuery 3.0 Final Released! | Official jQuery Blog</link></simpara>
</listitem>
</itemizedlist>
</warning>
<simpara><literal>Promise.resolve</literal> は共通の挙動である <literal>then</literal> だけを利用して、
さまざまなライブラリ間でのpromiseオブジェクトを相互に変換して使える仕組みを持っていることになります。</simpara>
<simpara>このthenableを変換する機能は、以前は <literal>Promise.cast</literal> という名前であったことからもその挙動が想像できるかもしれません。</simpara>
<simpara>ThenableについてはPromiseを使ったライブラリを書くとき等には知っておくべきですが、
通常の利用だとそこまで使う機会がないものかもしれません。</simpara>
<note>
<simpara>ThenableとPromise.resolveの具体的な例を交えたものは
第4章の<link linkend="resolve-thenable">Promise.resolveとThenable</link>にて詳しく解説しています。</simpara>
</note>
<simpara><literal>Promise.resolve</literal> を簡単にまとめると、「渡した値でFulfilledされるpromiseオブジェクトを返すメソッド」と考えるのがいいでしょう。</simpara>
<simpara>また、Promiseの多くの処理は内部的に <literal>Promise.resolve</literal> のアルゴリズムを使って値をpromiseオブジェクトに変換しています。</simpara>
</section>
</section>
<section xml:id="ch2-promise-reject">
<title>Promise.reject</title>
<simpara><link linkend="Promise.reject"><literal>Promise.reject(error)</literal></link>は
<link linkend="Promise.resolve"><literal>Promise.resolve(value)</literal></link> と同じ静的メソッドで <literal>new Promise()</literal> のショートカットとなるメソッドです。</simpara>
<simpara>たとえば、 <literal>Promise.reject(new Error("エラー"))</literal> というのは下記のコードのシンタックスシュガーです。</simpara>
<programlisting language="javascript" linenumbering="unnumbered">new Promise((resolve, reject) =&gt; {
    reject(new Error("エラー"));
});</programlisting>
<simpara>返り値のpromiseオブジェクトに対して、thenの <literal>onRejected</literal> に設定された関数にエラーオブジェクトが渡ります。</simpara>
<programlisting role="executable" language="javascript" linenumbering="unnumbered">Promise.reject(new Error("BOOM!")).catch((error) =&gt; {
    console.error(error);
});</programlisting>
<simpara><link linkend="Promise.resolve"><literal>Promise.resolve(value)</literal></link> との違いは resolveではなくrejectが呼ばれるという点で、
テストコードやデバッグ、一貫性を保つために利用する機会などがあるかもしれません。</simpara>
</section>
<section xml:id="promise-is-always-async">
<title>コラム: Promiseは常に非同期?</title>
<simpara><link linkend="Promise.resolve"><literal>Promise.resolve(value)</literal></link> 等を使った場合、
promiseオブジェクトがすぐにresolveされるので、<literal>.then</literal> に登録した関数も同期的に処理が行われるように錯覚してしまいます。</simpara>
<simpara>しかし、実際には <literal>.then</literal> で登録した関数が呼ばれるのは、非同期となります。</simpara>
<programlisting role="executable" language="javascript" linenumbering="unnumbered">const promise = new Promise((resolve) =&gt; {
    console.log("inner promise"); // 1
    resolve(42);
});
promise.then((value) =&gt; {
    console.log(value); // 3
});
console.log("outer promise"); // 2</programlisting>
<simpara>上記のコードを実行すると以下の順に呼ばれていることが分かります。</simpara>
<screen>inner promise // 1
outer promise // 2
42            // 3</screen>
<simpara>JavaScriptは上から実行されていくため、まず最初に <literal>&lt;1&gt;</literal> が実行されますね。
そして次に <literal>resolve(42);</literal> が実行され、この <literal>promise</literal> オブジェクトはこの時点で <literal>42</literal> という値にFulfilledされます。</simpara>
<simpara>次に、<literal>promise.then</literal> で <literal>&lt;3&gt;</literal> のコールバック関数を登録しますが、ここがこのコラムの焦点です。</simpara>
<simpara><literal>promise.then</literal> を行う時点でpromiseオブジェクトの状態が決まっているため、
プログラム的には同期的にコールバック関数に <literal>42</literal> を渡して呼び出すことはできますね。</simpara>
<simpara>しかし、Promiseでは <literal>promise.then</literal> で登録する段階でpromiseの状態が決まっていても、
そこで登録したコールバック関数は非同期で呼び出される仕様になっています。</simpara>
<simpara>そのため、<literal>&lt;2&gt;</literal> が先に呼び出されて、最後に <literal>&lt;3&gt;</literal> のコールバック関数が呼ばれています。</simpara>
<simpara>なぜ、同期的に呼び出せるのにわざわざ非同期的に呼び出しているでしょうか?</simpara>
<section xml:id="_同期と非同期の混在の問題">
<title>同期と非同期の混在の問題</title>
<simpara>これはPromise以外でも適用できるため、もう少し一般的な問題として考えてみましょう。</simpara>
<simpara>この問題はコールバック関数を受け取る関数が、
状況によって同期処理になるのか非同期処理になるのかが変わってしまう問題と同じです。</simpara>
<simpara>次のような、コールバック関数を受け取り処理する <literal>onReady(fn)</literal> を見てみましょう。</simpara>
<formalpara xml:id="mixed-onready.js" role="executable">
<title>mixed-onready.js</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">function onReady(fn) {
    const readyState = document.readyState;
    if (readyState === "interactive" || readyState === "complete") {
        fn();
    } else {
        window.addEventListener("DOMContentLoaded", fn);
    }
}
onReady(() =&gt; {
    console.log("DOM fully loaded and parsed");
});
console.log("==Starting==");</programlisting>
</para>
</formalpara>
<simpara><xref linkend="mixed-onready.js"/>ではDOMが読み込み済みかどうかで、
コールバック関数が同期的か非同期的に呼び出されるのかが異なっています。</simpara>
<variablelist>
<varlistentry>
<term>onReadyを呼ぶ前にDOMの読み込みが完了している</term>
<listitem>
<simpara>同期的にコールバック関数が呼ばれる</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>onReadyを呼ぶ前にDOMの読み込みが完了していない</term>
<listitem>
<simpara><literal>DOMContentLoaded</literal> のイベントハンドラとしてコールバック関数を設定する</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>そのため、このコードは配置する場所によって、
コンソールに出てくるメッセージの順番が変わってしまいます。</simpara>
<simpara>この問題の対処法は、常に非同期で呼び出すように統一することです。</simpara>
<formalpara xml:id="async-onready.js" role="executable">
<title>async-onready.js</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">function onReady(fn) {
    const readyState = document.readyState;
    if (readyState === "interactive" || readyState === "complete") {
        setTimeout(fn, 0);
    } else {
        window.addEventListener("DOMContentLoaded", fn);
    }
}
onReady(() =&gt; {
    console.log("DOM fully loaded and parsed");
});
console.log("==Starting==");</programlisting>
</para>
</formalpara>
<simpara>この問題については、 <link xl:href="http://effectivejs.com/">Effective JavaScript</link> の
<emphasis role="strong">項目67 非同期コールバックを同期的に呼び出してはいけない</emphasis> で紹介されています。</simpara>
<blockquote>
<attribution>
David Herman
<citetitle>Effective JavaScript</citetitle>
</attribution>
<itemizedlist>
<listitem>
<simpara>非同期コールバックは（たとえデータが即座に利用できても）決して同期的に使ってはならない。</simpara>
</listitem>
<listitem>
<simpara>非同期コールバックを同期的に呼び出すと、処理の期待されたシーケンスが乱され、
コードの実行順序に予期しない変動が生じるかもしれない。</simpara>
</listitem>
<listitem>
<simpara>非同期コールバックを同期的に呼び出すと、スタックオーバーフローや例外処理の間違いが発生するかもしれない。</simpara>
</listitem>
<listitem>
<simpara>非同期コールバックを次回に実行されるようスケジューリングするには、<literal>setTimeout</literal> のような非同期APIを使う。</simpara>
</listitem>
</itemizedlist>
</blockquote>
<simpara>先ほどの <literal>promise.then</literal> も同様のケースであり、この同期と非同期処理の混在の問題が起きないようにするため、
<emphasis role="strong">Promiseは常に非同期</emphasis> で処理されるということが仕様で定められているわけです。</simpara>
<simpara>最後に、この <literal>onReady</literal> をPromiseを使って定義すると以下のようになります。</simpara>
<formalpara xml:id="onready-as-promise.js" role="executable">
<title>onready-as-promise.js</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">function onReadyPromise() {
    return new Promise((resolve) =&gt; {
        const readyState = document.readyState;
        if (readyState === "interactive" || readyState === "complete") {
            resolve();
        } else {
            window.addEventListener("DOMContentLoaded", resolve);
        }
    });
}
onReadyPromise().then(() =&gt; {
    console.log("DOM fully loaded and parsed");
});
console.log("==Starting==");</programlisting>
</para>
</formalpara>
<simpara>Promiseは常に非同期で実行されることが保証されているため、
<literal>setTimeout</literal> のような明示的に非同期処理にするためのコードが不要となることが分かります。</simpara>
</section>
</section>
<section xml:id="ch2-promise.then">
<title>Promise#then</title>
<simpara>先ほどの章でPromiseの基本となるインスタンスメソッドである <literal>then</literal> と <literal>catch</literal> の使い方を説明しました。</simpara>
<simpara>その中で <literal>.then().catch()</literal> とメソッドチェーンで繋げて書いていたことからも分かるように、
Promiseではいくらでもメソッドチェーンを繋げて処理を書いていくことができます。</simpara>
<formalpara>
<title>promiseはメソッドチェーンで繋げて書ける</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">aPromise.then((value) =&gt; {
// task A
}).then((value) =&gt; {
// task B
}).catch((error) =&gt; {
    console.error(error);
});</programlisting>
</para>
</formalpara>
<simpara><literal>then</literal> で登録するコールバック関数をそれぞれtaskというものにした時に、
taskA &#8594; task B という流れをPromiseのメソッドチェーンを使って書くことができます。</simpara>
<simpara>Promiseのメソッドチェーンだと長いので、今後は<link linkend="promise-chain">promise chain</link>と呼びます。
このpromise chainがPromiseが非同期処理の流れを書きやすい理由の一つといえるかもしれません。</simpara>
<simpara>このセクションでは、<literal>then</literal> を使ったpromise chainの挙動と流れについて学んでいきましょう。</simpara>
<section xml:id="_promise_chain">
<title>promise chain</title>
<simpara>第一章の例だと、<link linkend="promise-chain">promise chain</link>は
then &#8594; catch というシンプルな例でしたが、このpromise chainをもっとつなげた場合に、
それぞれのpromiseオブジェクトに登録された onFulfilledとonRejectedがどのように呼ばれるかを見ていきましょう。</simpara>
<note>
<simpara>promise chain - すなわちメソッドチェーンが短いことはよいことです。
この例では説明のために長いメソッドチェーンを用います。</simpara>
</note>
<simpara>次のようなpromise chainを見てみましょう。</simpara>
<formalpara xml:id="promise-then-catch-flow.js" role="executable">
<title>promise-then-catch-flow.js</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">function taskA() {
    console.log("Task A");
}
function taskB() {
    console.log("Task B");
}
function onRejected(error) {
    console.log("Catch Error: A or B", error);
}
function finalTask() {
    console.log("Final Task");
}

const promise = Promise.resolve();
promise
    .then(taskA)
    .then(taskB)
    .catch(onRejected)
    .then(finalTask);</programlisting>
</para>
</formalpara>
<simpara>このようなpromise chainをつなげた場合、
それぞれの処理の流れは以下のように図で表せます。</simpara>
<figure xml:id="promise-then-catch-flow.png">
<title>promise-then-catch-flow.jsの図</title>
<mediaobject>
<imageobject>
<imagedata fileref="Ch2_HowToWrite/img/promise-then-catch-flow.png"/>
</imageobject>
<textobject><phrase>promise-then-catch-flow</phrase></textobject>
</mediaobject>
</figure>
<simpara><link linkend="promise-then-catch-flow.js">上記のコード</link>では <literal>then</literal> は第二引数(onRejected)を使っていないため、
以下のように読み替えても問題ありません。</simpara>
<variablelist>
<varlistentry>
<term><literal>then</literal></term>
<listitem>
<simpara>onFulfilledの処理を登録</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>catch</literal></term>
<listitem>
<simpara>onRejectedの処理を登録</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><link linkend="promise-then-catch-flow.png">図</link>の方に注目してもらうと、
<emphasis>Task A</emphasis> と <emphasis>Task B</emphasis> それぞれから <emphasis>onRejected</emphasis> への線が出ていることが分かります。</simpara>
<simpara>これは、<emphasis>Task A</emphasis> または <emphasis>Task B</emphasis> の処理にて、次のような場合に <emphasis>onRejected</emphasis> が呼ばれるということを示しています。</simpara>
<itemizedlist>
<listitem>
<simpara>例外が発生した時</simpara>
</listitem>
<listitem>
<simpara>Rejectedなpromiseオブジェクトがreturnされた時</simpara>
</listitem>
</itemizedlist>
<simpara><link linkend="how-to-write-promise">第一章</link>でPromiseの処理は常に <literal>try-catch</literal> されているようなものなので、
例外が起きた場合もキャッチして、<literal>catch</literal> で登録された <literal>onRejected</literal> の処理を呼ぶことは学びましたね。</simpara>
<simpara>もう一つの <emphasis>Rejectedなpromiseオブジェクトがreturnされた時</emphasis> については、
<literal>throw</literal> を使わずにpromise chain中に <literal>onRejected</literal> を呼ぶ方法です。</simpara>
<simpara>これについては、ここでは必要ない内容なので詳しくは、 第4章の <link linkend="not-throw-use-reject">throwしないで、rejectしよう</link> にて解説しています。</simpara>
<simpara>また、<emphasis>onRejected</emphasis> と <emphasis>Final Task</emphasis> には <literal>catch</literal> のpromise chainがこれより後ろにありません。
つまり、この処理中に例外が起きた場合はキャッチすることができないことに気をつけましょう。</simpara>
<simpara>もう少し具体的に、<emphasis>Task A</emphasis> &#8594; <emphasis>onRejected</emphasis> となる例を見てみます。</simpara>
<section xml:id="_task_aで例外が発生したケース">
<title>Task Aで例外が発生したケース</title>
<simpara><emphasis>Task A</emphasis> の処理中に例外が発生した場合、
TaskA &#8594; onRejected &#8594; FinalTask という流れで処理が行われます。</simpara>
<figure>
<title>Task Aで例外が発生した時の図</title>
<mediaobject>
<imageobject>
<imagedata fileref="Ch2_HowToWrite/img/promise-taska-rejected-flow.png"/>
</imageobject>
<textobject><phrase>promise taska rejected flow</phrase></textobject>
</mediaobject>
</figure>
<simpara>コードにしてみると以下のようになります。</simpara>
<formalpara xml:id="promise-then-taska-throw.js" role="executable">
<title>promise-then-taska-throw.js</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">function taskA() {
    console.log("Task A");
    throw new Error("throw Error @ Task A");
}
function taskB() {
    console.log("Task B");// 呼ばれない
}
function onRejected(error) {
    console.error(error);// =&gt; "throw Error @ Task A"
}
function finalTask() {
    console.log("Final Task");
}

const promise = Promise.resolve();
promise
    .then(taskA)
    .then(taskB)
    .catch(onRejected)
    .then(finalTask);</programlisting>
</para>
</formalpara>
<simpara>実行してみると、<emphasis>Task B</emphasis> が呼ばれていないことが分かるでしょう。</simpara>
<note>
<simpara>例では説明のためにtaskAで <literal>throw</literal> して例外を発生させています。
しかし、実際に明示的にonRejectedを呼びたい場合は、Rejectedなpromiseオブジェクトを返すべきでしょう。
それぞれの違いについては <link linkend="not-throw-use-reject">throwしないで、rejectしよう</link> で解説しています。</simpara>
</note>
</section>
</section>
<section xml:id="_promise_chainでの値渡し">
<title>promise chainでの値渡し</title>
<simpara>先ほどの例ではそれぞれのTaskが独立していて、ただ呼ばれているだけでした。</simpara>
<simpara>このときに、Task AがTask Bへ値を渡したい時はどうすればよいでしょうか?</simpara>
<simpara>答えはものすごく単純でTask Aの処理で <literal>return</literal> した値がTask Bが呼ばれるときに引数に設定されます。</simpara>
<simpara>実際に例を見てみましょう。</simpara>
<formalpara xml:id="promise-then-passing-value.js" role="executable">
<title>promise-then-passing-value.js</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">function doubleUp(value) {
    return value * 2;
}
function increment(value) {
    return value + 1;
}
function output(value) {
    console.log(value);// =&gt; (1 + 1) * 2
}

const promise = Promise.resolve(1);
promise
    .then(increment)
    .then(doubleUp)
    .then(output)
    .catch((error) =&gt; {
        // promise chain中にエラーが発生した場合に呼ばれる
        console.error(error);
    });</programlisting>
</para>
</formalpara>
<simpara>スタートは <literal>Promise.resolve(1);</literal> で、この処理は以下のような流れでpromise chainが処理されていきます。</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara><literal>Promise.resolve(1);</literal> から 1 が <literal>increment</literal> に渡される</simpara>
</listitem>
<listitem>
<simpara><literal>increment</literal> では渡された値に+1した値を <literal>return</literal> している</simpara>
</listitem>
<listitem>
<simpara>この値(2)が次の <literal>doubleUp</literal> に渡される</simpara>
</listitem>
<listitem>
<simpara>最後に <literal>output</literal> が出力する</simpara>
</listitem>
</orderedlist>
<figure>
<title>promise-then-passing-value.jsの図</title>
<mediaobject>
<imageobject>
<imagedata fileref="Ch2_HowToWrite/img/promise-then-passing-value.png"/>
</imageobject>
<textobject><phrase>promise-then-passing-value</phrase></textobject>
</mediaobject>
</figure>
<simpara>この <literal>return</literal> する値は数字や文字列だけではなく、
オブジェクトやpromiseオブジェクトも <literal>return</literal> することができます。</simpara>
<simpara>returnした値は <literal>Promise.resolve(returnされた値);</literal> のように処理されるため、
何をreturnしても最終的には新しいpromiseオブジェクトを返します。</simpara>
<note>
<simpara>これについて詳しくは <link linkend="then-return-new-promise">thenは常に新しいpromiseオブジェクトを返す</link> にて、
よくある間違いと共に紹介しています。</simpara>
</note>
<simpara>つまり、 <literal>Promise#then</literal> は単にコールバックとなる関数を登録するだけではなく、
受け取った値を変化させて別のpromiseオブジェクトを生成する という機能も持っていることを覚えておくといいでしょう。</simpara>
</section>
</section>
<section xml:id="ch2-promise-catch">
<title>Promise#catch</title>
<simpara><link linkend="ch2-promise.then">先ほどのPromise#then</link>についてでも <literal>Promise#catch</literal> はすでに使っていましたね。</simpara>
<simpara>改めて説明すると<link linkend="promise.catch">Promise#catch</link>は <literal>promise.then(undefined, onRejected);</literal> のエイリアスとなるメソッドです。
つまり、promiseオブジェクトがRejectedとなった時に呼ばれる関数を登録するためのメソッドです。</simpara>
<simpara>次のコードのように <literal>Promise#catch</literal> は <literal>Promise#then</literal> でのエラーハンドリングだけを簡潔に書くためのメソッドです。</simpara>
<formalpara>
<title>Promise#catchとPromise#then</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">Promise.reject(new Error("message")).catch((error) =&gt; {
    // エラーハンドリング
});
// Promise#catchは次のPromise#thenと同じ意味
Promise.reject(new Error("message")).then(undefined, (error) =&gt; {
    // エラーハンドリング
});</programlisting>
</para>
</formalpara>
<note>
<simpara><link linkend="promise.then">Promise#then</link>と<link linkend="promise.catch">Promise#catch</link>の使い分けについては、
<link linkend="then-or-catch">then or catch?</link>で紹介しています。</simpara>
</note>
<section xml:id="_ie8以下での問題">
<title>IE8以下での問題</title>
<simpara><inlinemediaobject>
<imageobject>
<imagedata fileref="Ch2_HowToWrite/img/promise-catch-error.png"/>
</imageobject>
<textobject><phrase>Build Status</phrase></textobject>
</inlinemediaobject></simpara>
<simpara>このバッジは以下のコードが、 <link xl:href="https://github.com/jakearchibald/es6-promise">polyfill</link> を用いた状態でそれぞれのブラウザで正しく実行できているかを示したものです。</simpara>
<note>
<simpara>polyfillとはその機能が実装されていないブラウザでも、その機能が使えるようにするライブラリのことです。
この例では <link xl:href="https://github.com/jakearchibald/es6-promise">jakearchibald/es6-promise</link> を利用しています。</simpara>
</note>
<formalpara role="executable">
<title>Promise#catchの実行結果</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">const promise = Promise.reject(new Error("message"));
promise.catch((error) =&gt; {
    console.error(error);
});</programlisting>
</para>
</formalpara>
<simpara>このコードをそれぞれのブラウザで実行させると、IE8以下では実行する段階で <emphasis role="strong">識別子がありません</emphasis> というSyntax Errorになってしまいます。</simpara>
<simpara>これはどういうことかというと、<literal>catch</literal> という単語はECMAScriptにおける <link xl:href="http://mothereff.in/js-properties#catch">予約語</link> であることが関係します。</simpara>
<simpara>ECMAScript 3では予約語はプロパティの名前に使うことができませんでした。
IE8以下はECMAScript 3の実装であるため、<literal>catch</literal> というプロパティを使う <literal>promise.catch()</literal> という書き方が出来ないので、
<emphasis role="strong">識別子がありません</emphasis>というエラーを起こしてしまう訳です。</simpara>
<simpara>一方、現在のブラウザが実装済みであるECMAScript 5以降では、
予約語を <link xl:href="http://es5.github.io/#x7.6">IdentifierName</link> 、つまりプロパティ名に利用することが可能となっています。</simpara>
<note>
<simpara>ECMAScript 5でも予約語は <link xl:href="http://es5.github.io/#x7.6">Identifier</link> 、つまり変数名、関数名には利用することができません。
<literal>for</literal> という変数が定義できてしまうと <literal>for</literal> 文との区別ができなくなってしまいます。
プロパティの場合は <literal>object.for</literal> と <literal>for</literal> 文の区別はできるので、少し考えてみると自然な動作ですね。</simpara>
</note>
<simpara>このECMAScript 3の予約語の問題を回避する書き方も存在します。</simpara>
<simpara><link xl:href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Operators/Property_Accessors#Dot_notation">ドット表記法</link>
はプロパティ名が有効な識別子(ECMAScript 3の場合は予約語が使えない)でないといけませんが、
<link xl:href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Operators/Property_Accessors#Bracket_notation">ブラケット表記法</link>
は有効な識別子ではなくても利用できます。</simpara>
<simpara>つまり、先ほどのコードは以下のように書き換えれば、IE8以下でも実行することができます。(もちろんpolyfillは必要です)</simpara>
<formalpara role="executable">
<title>Promise#catchの識別子エラーの回避</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">const promise = Promise.reject(new Error("message"));
promise["catch"]((error) =&gt; {
    console.error(error);
});</programlisting>
</para>
</formalpara>
<simpara>もしくは単純に <literal>catch</literal> を使わずに、<literal>then</literal> を使うことでも回避できます。</simpara>
<formalpara role="executable">
<title>Promise#catchではなくPromise#thenを使う</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">const promise = Promise.reject(new Error("message"));
promise.then(undefined, (error) =&gt; {
    console.error(error);
});</programlisting>
</para>
</formalpara>
<simpara><literal>catch</literal> という識別子が問題となっているため、ライブラリによっては <literal>caught</literal> 等の名前が違うだけのメソッドを用意しているケースがあります。</simpara>
<simpara>また多くの圧縮ツールは <literal>promise.catch</literal> を <literal>promise["catch"]</literal> へと置換する処理が組み込まれているため、知らない間に回避できていることも多いかも知れません。</simpara>
<simpara>サポートブラウザにIE8以下を含める時は、この <literal>catch</literal> の問題に気をつけるといいでしょう。</simpara>
</section>
</section>
<section xml:id="ch2-promise-finally">
<title>Promise#finally</title>
<simpara>ECMAScript 2018からpromise chainの最後に処理を実行する <literal>Promise#finally</literal> メソッド追加されました。</simpara>
<simpara><literal>Promise#finally</literal> メソッドは成功時、失敗時どちらの場合でも呼び出すコールバック関数を登録できます。
<literal>try&#8230;&#8203;catch&#8230;&#8203;finally</literal> 構文の <literal>finally</literal> 節と同様の役割をもつメソッドです。</simpara>
<simpara>次のコードのように、 <literal>Promise#finally</literal> メソッドで登録したコールバック関数は、promiseオブジェクトが <emphasis role="strong">resolve</emphasis>(成功) / <emphasis role="strong">reject</emphasis>(失敗) どちらの場合でも呼ばれます。</simpara>
<formalpara role="executable">
<title>finallyのコード例</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">Promise.resolve("成功").finally(() =&gt; {
    console.log("成功時に実行される");
});
Promise.reject(new Error("失敗")).finally(() =&gt; {
    console.log("失敗時に実行される");
});</programlisting>
</para>
</formalpara>
<simpara><literal>finally</literal> メソッドのコールバック関数は引数を受け取らず、どのような値を返してもpromise chainには影響を与えません。
また、 <literal>finally</literal> メソッドは新しいpromiseオブジェクトを返し、新しいpromiseオブジェクトは呼び出し元のpromiseオブジェクトの状態をそのまま引き継ぎます。</simpara>
<formalpara role="executable">
<title>finallyとpromise chain</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">function onFinally() {
    // 成功、失敗どちらでも実行したい処理
}

// `Promise#finally` は新しいpromiseオブジェクトを返す
Promise.resolve(42)
    .finally(onFinally)
    .then((value) =&gt; {
        // 呼び出し元のpromiseオブジェクトの状態をそのまま引き継ぐ
        // 呼び出し元のpromiseオブジェクトは `42` で resolveされている
        console.log(value); // 42
    });</programlisting>
</para>
</formalpara>
<simpara><literal>Promise#finally</literal> メソッドと同等の表現を <literal>Promise#then</literal> メソッドで書くと次のように書けます。</simpara>
<formalpara>
<title>finallyをthenで表現</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">function onFinally() {
    // 成功、失敗どちらでも実行したい処理
}

// Promise#finally(onFinally) と同等の表現
promise.then((result) =&gt; {
    onFinally();
    return result;
}, (error) =&gt; {
    onFinally();
    return Promise.reject(error);
});</programlisting>
</para>
</formalpara>
<simpara><literal>Promise#finally</literal> メソッドを使うことで、promise chainで必ず実行したい処理を簡単に書けるようになっています。</simpara>
<simpara>次のコードでは、リソースを取得中かどうかを判定するためのフラグを <literal>isLoading</literal> という変数で管理しています。
<literal>Promise#finally</literal> メソッドを使い成功失敗どちらにもかかわらず、取得が終わったら <literal>isLoading</literal> は <literal>false</literal> にしています。</simpara>
<formalpara role="executable">
<title>finallyのユースケース</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">// リソースを取得中かどうかのフラグ
let isLoading = false;
function fetchResource(URL) {
    // リソース取得中フラグをONに
    isLoading = true;
    return new Promise((resolve, reject) =&gt; {
        const req = new XMLHttpRequest();
        req.open("GET", URL, true);
        req.onload = () =&gt; {
            if (200 &lt;= req.status &amp;&amp; req.status &lt; 300) {
                resolve(req.responseText);
            } else {
                reject(new Error(req.statusText));
            }
        };
        req.onerror = () =&gt; {
            reject(new Error(req.statusText));
        };
        req.send();
    }).finally(() =&gt; {
        // リソース取得に成功/失敗どちらの場合も取得中フラグをOFFに
        isLoading = false;
    });
}

console.log("リソースロード開始", isLoading);
fetchResource("https://httpbin.org/get").then((value) =&gt; {
    console.log("リソース取得に成功", isLoading);
    console.log(value);
}).catch((error) =&gt; {
    console.log("リソース取得に失敗", isLoading);
    console.error(error);
});
console.log("リソースロード中", isLoading);</programlisting>
</para>
</formalpara>
<simpara><literal>then</literal> と <literal>catch</literal> メソッドでも実現できますが、 <literal>Promise#finally</literal> メソッドを使うことで <literal>isLoading</literal> の代入を一箇所にまとめられます。</simpara>
</section>
<section xml:id="then-return-new-promise">
<title>コラム: thenは常に新しいpromiseオブジェクトを返す</title>
<simpara><literal>aPromise.then(&#8230;&#8203;).catch(&#8230;&#8203;)</literal> は一見すると、全て最初の <literal>aPromise</literal> オブジェクトに
メソッドチェーンで処理を書いてるように見えます。</simpara>
<simpara>しかし、実際には <literal>then</literal> で新しいpromiseオブジェクト、<literal>catch</literal> でも別の新しいpromiseオブジェクトを作成して返しています。</simpara>
<simpara>本当に新しいpromiseオブジェクトを返しているのか確認してみましょう。</simpara>
<programlisting role="executable" language="javascript" linenumbering="unnumbered">const aPromise = new Promise((resolve) =&gt; {
    resolve(100);
});
const thenPromise = aPromise.then((value) =&gt; {
    console.log(value);
});
const catchPromise = thenPromise.catch((error) =&gt; {
    console.error(error);
});
console.log(aPromise !== thenPromise); // =&gt; true
console.log(thenPromise !== catchPromise);// =&gt; true</programlisting>
<simpara><literal>===</literal> 厳密比較演算子によって比較するとそれぞれが別々のオブジェクトなので、
本当に <literal>then</literal> や <literal>catch</literal> は別のpromiseオブジェクトを返していることが分かりました。</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="Ch2_HowToWrite/img/then_catch.png"/>
</imageobject>
<textobject><phrase>Then Catch flow</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>この仕組みはPromiseを拡張する時は意識しないと、いつのまにか触ってるpromiseオブジェクトが
別のものであったということが起こりえると思います。</simpara>
<simpara>また、<literal>then</literal> は新しいオブジェクトを作って返すということがわかっていれば、
次の <literal>then</literal> の使い方では意味が異なることに気づくでしょう。</simpara>
<programlisting role="executable" language="javascript" linenumbering="unnumbered">// 1: それぞれの `then` は同時に呼び出される
const aPromise = new Promise((resolve) =&gt; {
    resolve(100);
});
aPromise.then((value) =&gt; {
    return value * 2;
});
aPromise.then((value) =&gt; {
    return value * 2;
});
aPromise.then((value) =&gt; {
    console.log("1: " + value); // =&gt; 100
});

// vs

// 2: `then` はpromise chain通り順番に呼び出される
const bPromise = new Promise((resolve) =&gt; {
    resolve(100);
});
bPromise.then((value) =&gt; {
    return value * 2;
}).then((value) =&gt; {
    return value * 2;
}).then((value) =&gt; {
    console.log("2: " + value); // =&gt; 100 * 2 * 2
});</programlisting>
<simpara>1のpromiseをメソッドチェーン的に繋げない書き方はあまりすべきではありませんが、
このような書き方をした場合、それぞれの <literal>then</literal> はほぼ同時に呼ばれ、また <literal>value</literal> に渡る値も全て同じ <literal>100</literal> となります。</simpara>
<simpara>2はメソッドチェーン的につなげて書くことにより、resolve &#8594; then &#8594; then &#8594; then と書いた順番にキチンと実行され、
それぞれの <literal>value</literal> に渡る値は、一つ前のpromiseオブジェクトで <literal>return</literal> された値が渡ってくるようになります。</simpara>
<simpara>1の書き方により発生するアンチパターンとしては以下のようなものが有名です。</simpara>
<formalpara>
<title>✘ <literal>then</literal> の間違った使い方</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">function badAsyncCall() {
    const promise = Promise.resolve();
    promise.then(() =&gt; {
        // 何かの処理
        return newVar;
    });
    return promise;
}</programlisting>
</para>
</formalpara>
<simpara>このように書いてしまうと、<literal>promise.then</literal> の中で例外が発生するとその例外を取得する方法がなくなり、
また、何かの値を返していてもそれを受け取る方法が無くなってしまいます。</simpara>
<simpara>これは <literal>promise.then</literal> によって新たに作られたpromiseオブジェクトを返すようにすることで、
2のようにpromise chainをつなげるようにするべきなので、次のように修正することができます。</simpara>
<formalpara>
<title><literal>then</literal> で作成したオブジェクトを返す</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">function anAsyncCall() {
    const promise = Promise.resolve();
    return promise.then(() =&gt; {
        // 何かの処理
        return newVar;
    });
}</programlisting>
</para>
</formalpara>
<simpara>これらのアンチパターンについて、詳しくは
<link xl:href="http://taoofcode.net/promise-anti-patterns/">Promise Anti-patterns</link> を参照して下さい。</simpara>
<simpara>この挙動はPromise全般に当てはまるため、後に説明する<link linkend="ch2-promise-all">Promise.all</link>や<link linkend="ch2-promise-race">Promise.race</link>も
引数で受け取ったものとは別のpromiseオブジェクトを作って返しています。</simpara>
</section>
<section xml:id="ch2-promise-and-array">
<title>Promiseと配列</title>
<simpara>ここまでで、promiseオブジェクトが Fulfilled または Rejected となった時の処理は <link linkend="promise.then"><literal>.then</literal></link> と <link linkend="promise.catch"><literal>.catch</literal></link> で登録でき、 <link linkend="promise.finally"><literal>.finally</literal></link> を使うことで Fulfilled と Rejected どちらの場合でも実行される処理を登録できることを学びました。</simpara>
<simpara>一つのpromiseオブジェクトなら、そのpromiseオブジェクトに対して処理を書けばよいですが、
複数のpromiseオブジェクトが全てFulfilledとなった時の処理を書く場合はどうすればよいでしょうか?</simpara>
<simpara>たとえば、複数のXHR(非同期処理)が全て終わった後に、何かをしたいという事例を考えてみます。</simpara>
<simpara>少しイメージしにくいので、
まずは、通常のコールバックスタイルを使って複数のXHRを行う以下のようなコードを見てみます。</simpara>
<warning>
<title>CORSについて</title>
<simpara>ブラウザにおけるXHRのリソース取得には、CORS(<link xl:href="https://developer.mozilla.org/ja/docs/Web/HTTP/HTTP_access_control">Cross-Origin Resource Sharing</link>)というセキュリティ上の制約が存在します。</simpara>
<simpara>このCORSの制約により、ブラウザでは同一ドメインではないリソースを許可なく取得することはできません。そのため、一般的には別サイトのリソースは許可なくXHRでアクセスすることができません。</simpara>
<simpara>次のサンプルでは <literal><link xl:href="https://azu.github.io/promises-book/json/comment.json">https://azu.github.io/promises-book/json/comment.json</link></literal> という <literal>azu.github.io</literal> ドメイン以下にあるリソースを取得する例が登場します。</simpara>
<simpara><literal>azu.github.io</literal> ドメイン以下のJSONには、別ドメインからの取得が許可する設定がされています。</simpara>
<simpara>また、 <link xl:href="https://httpbin.org/">httpbin.org</link> というドメインがリソース取得の例として登場します。
こちらも、同一ドメインでなくてもリソースの取得が許可されています。</simpara>
</warning>
<section xml:id="_コールバックで複数の非同期処理">
<title>コールバックで複数の非同期処理</title>
<formalpara xml:id="multiple-xhr-callback.js" role="executable">
<title>multiple-xhr-callback.js</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">function fetchURLCallback(URL, callback) {
    const req = new XMLHttpRequest();
    req.open("GET", URL, true);
    req.onload = () =&gt; {
        if (200 &lt;= req.status &amp;&amp; req.status &lt; 300) {
            callback(null, req.responseText);
        } else {
            callback(new Error(req.statusText), req.response);
        }
    };
    req.onerror = () =&gt; {
        callback(new Error(req.statusText));
    };
    req.send();
}
// &lt;1&gt; JSONパースを安全に行う
function jsonParse(callback, error, value) {
    if (error) {
        callback(error, value);
    } else {
        try {
            const result = JSON.parse(value);
            callback(null, result);
        } catch (e) {
            callback(e, value);
        }
    }
}
// &lt;2&gt; XHRを叩いてリクエスト
const request = {
    comment(callback) {
        return fetchURLCallback("https://azu.github.io/promises-book/json/comment.json", jsonParse.bind(null, callback));
    },
    people(callback) {
        return fetchURLCallback("https://azu.github.io/promises-book/json/people.json", jsonParse.bind(null, callback));
    }
};
// &lt;3&gt; 複数のXHRリクエストを行い、全部終わったらcallbackを呼ぶ
function allRequest(requests, callback, results) {
    if (requests.length === 0) {
        return callback(null, results);
    }
    const req = requests.shift();
    req((error, value) =&gt; {
        if (error) {
            callback(error, value);
        } else {
            results.push(value);
            allRequest(requests, callback, results);
        }
    });
}

function main(callback) {
    allRequest([request.comment, request.people], callback, []);
}



// 実行例
main(function(error, results){
    if(error){
        console.error(error);
        return;
    }
    console.log(results);
});</programlisting>
</para>
</formalpara>
<simpara>このコールバックスタイルでは幾つかの要素が出てきます。</simpara>
<itemizedlist>
<listitem>
<simpara><literal>JSON.parse</literal> をそのまま使うと例外となるケースがあるためラップした <literal>jsonParse</literal> 関数を使う</simpara>
</listitem>
<listitem>
<simpara>複数のXHRをそのまま書くとネストが深くなるため、<literal>allRequest</literal> というrequest関数を実行するものを利用する</simpara>
</listitem>
<listitem>
<simpara>コールバック関数には <literal>callback(error,value)</literal> のように第一引数にエラー、第二引数にレスポンスを渡す。</simpara>
</listitem>
</itemizedlist>
<simpara><literal>jsonParse</literal> 関数を使うときに <literal>bind</literal> を使うことで、部分適用を使って無名関数を減らすようにしています。
(コールバックスタイルでも関数の処理などをちゃんと分離すれば、無名関数の使用も減らせると思います)</simpara>
<programlisting language="javascript" linenumbering="unnumbered">jsonParse.bind(null, callback);
// は以下のように置き換えるのと殆ど同じ
function bindJSONParse(error, value) {
    jsonParse(callback, error, value);
}</programlisting>
<simpara>コールバックスタイルで書いたものを見ると以下のような点が気になります。</simpara>
<itemizedlist>
<listitem>
<simpara>明示的な例外のハンドリングが必要</simpara>
</listitem>
<listitem>
<simpara>ネストを深くしないために、requestを扱う関数が必要</simpara>
</listitem>
<listitem>
<simpara>コールバックがたくさんでてくる</simpara>
</listitem>
</itemizedlist>
<simpara>次は、<literal>Promise#then</literal> を使って同様のことをしてみたいと思います。</simpara>
</section>
<section xml:id="_promise_thenのみで複数の非同期処理">
<title>Promise#thenのみで複数の非同期処理</title>
<simpara>先に述べておきますが、<literal>Promise.all</literal> というこのような処理に適切なものがあるため、
ワザと <literal>.then</literal> の部分をクドく書いています。</simpara>
<simpara><link linkend="promise.then"><literal>.then</literal></link> を使った場合は、コールバックスタイルと完全に同等というわけではないですが以下のように書けると思います。</simpara>
<formalpara xml:id="multiple-xhr.js" role="executable">
<title>multiple-xhr.js</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">function fetchURL(URL) {
    return new Promise((resolve, reject) =&gt; {
        const req = new XMLHttpRequest();
        req.open("GET", URL, true);
        req.onload = () =&gt; {
            if (200 &lt;= req.status &amp;&amp; req.status &lt; 300) {
                resolve(req.responseText);
            } else {
                reject(new Error(req.statusText));
            }
        };
        req.onerror = () =&gt; {
            reject(new Error(req.statusText));
        };
        req.send();
    });
}
const request = {
    comment() {
        return fetchURL("https://azu.github.io/promises-book/json/comment.json").then(JSON.parse);
    },
    people() {
        return fetchURL("https://azu.github.io/promises-book/json/people.json").then(JSON.parse);
    }
};
function main() {
    function recordValue(results, value) {
        results.push(value);
        return results;
    }
    // [] は記録する初期値を部分適用している
    const pushValue = recordValue.bind(null, []);
    return request.comment()
        .then(pushValue)
        .then(request.people)
        .then(pushValue);
}



// 実行例
main().then((value) =&gt; {
    console.log(value);
}).catch((error) =&gt; {
    console.error(error);
});</programlisting>
</para>
</formalpara>
<simpara><link linkend="multiple-xhr-callback.js">コールバックスタイル</link>と比較してみると次のことがわかります。</simpara>
<itemizedlist>
<listitem>
<simpara><literal>JSON.parse</literal> をそのまま使っている</simpara>
</listitem>
<listitem>
<simpara><literal>main()</literal> はpromiseオブジェクトを返している</simpara>
</listitem>
<listitem>
<simpara>エラーハンドリングは返ってきたpromiseオブジェクトに対して書いている</simpara>
</listitem>
</itemizedlist>
<simpara>先ほども述べたように mainの <literal>then</literal> の部分がクドく感じます。</simpara>
<simpara>Promiseでは、このような複数の非同期処理をまとめて扱う <literal>Promise.all</literal> と <literal>Promise.race</literal> という静的メソッドが用意されています。</simpara>
<simpara>次のセクションではそれらについて学んでいきましょう。</simpara>
</section>
</section>
<section xml:id="ch2-promise-all">
<title>Promise.all</title>
<simpara><link linkend="Promise.all"><literal>Promise.all</literal></link> は promiseオブジェクトの配列を受け取り、
その配列に入っているpromiseオブジェクトが全てresolveされた時に、次の <literal>.then</literal> を呼び出します。</simpara>
<simpara>先ほどの複数のXHRの結果をまとめて取得する処理は、 <link linkend="Promise.all"><literal>Promise.all</literal></link> を使うとシンプルに書くことができます。</simpara>
<simpara>先ほどの例の <literal>fetchURL</literal> はXHRによる通信を抽象化したpromiseオブジェクトを返しています。
<literal>Promise.all</literal> に通信を抽象化したpromiseオブジェクトの配列を渡すことで、
全ての通信が完了(FulfilledまたはRejected)した時に、次の <literal>.then</literal> を呼び出すことができます。</simpara>
<formalpara xml:id="promise-all-xhr.js" role="executable">
<title>promise-all-xhr.js</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">function fetchURL(URL) {
    return new Promise((resolve, reject) =&gt; {
        const req = new XMLHttpRequest();
        req.open("GET", URL, true);
        req.onload = () =&gt; {
            if (200 &lt;= req.status &amp;&amp; req.status &lt; 300) {
                resolve(req.responseText);
            } else {
                reject(new Error(req.statusText));
            }
        };
        req.onerror = () =&gt; {
            reject(new Error(req.statusText));
        };
        req.send();
    });
}
const request = {
    comment() {
        return fetchURL("https://azu.github.io/promises-book/json/comment.json").then(JSON.parse);
    },
    people() {
        return fetchURL("https://azu.github.io/promises-book/json/people.json").then(JSON.parse);
    }
};
function main() {
    return Promise.all([request.comment(), request.people()]);
}



// 実行例
main().then((value) =&gt; {
    console.log(value);
}).catch((error) =&gt; {
    console.error(error);
});</programlisting>
</para>
</formalpara>
<simpara>実行方法は <link linkend="xhr-promise.js">前回のもの</link> と同じですね。
<link linkend="Promise.all"><literal>Promise.all</literal></link> を使うことで以下のような違いがあることがわかります。</simpara>
<itemizedlist>
<listitem>
<simpara>mainの処理がスッキリしている</simpara>
</listitem>
<listitem>
<simpara>Promise.all は promiseオブジェクトの配列を扱っている</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">Promise.all([request.comment(), request.people()]);</programlisting>
<simpara>というように処理を書いた場合は、<literal>request.comment()</literal> と <literal>request.people()</literal> は同時に実行されますが、
それぞれのpromiseの結果(resolve,rejectで渡される値)は、<link linkend="Promise.all"><literal>Promise.all</literal></link>に渡した配列の順番となります。</simpara>
<simpara>つまり、この場合に次の <literal>.then</literal> に渡される結果の配列は [comment, people]の順番になることが保証されています。</simpara>
<programlisting language="javascript" linenumbering="unnumbered">main().then((results) =&gt; {
    console.log(results); // [comment, people]の順番
});</programlisting>
<simpara><link linkend="Promise.all"><literal>Promise.all</literal></link> に渡したpromiseオブジェクトが同時に実行されてるのは、
次のようなタイマーを使った例を見てみると分かりやすいです。</simpara>
<formalpara xml:id="promise-all-timer.js" role="executable">
<title>promise-all-timer.js</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">// `delay`ミリ秒後にresolveする
function timerPromisefy(delay) {
    return new Promise((resolve) =&gt; {
        setTimeout(() =&gt; {
            resolve(delay);
        }, delay);
    });
}
const startDate = Date.now();
// 全てがresolveされたら終了
Promise.all([
    timerPromisefy(1),
    timerPromisefy(32),
    timerPromisefy(64),
    timerPromisefy(128)
]).then((values) =&gt; {
    console.log(Date.now() - startDate + "ms");// 約128ms
    console.log(values); // [1,32,64,128]
});</programlisting>
</para>
</formalpara>
<simpara><literal>timerPromisefy</literal> は引数で指定したミリ秒後に、その指定した値でFulfilledとなる
promiseオブジェクトを返してくれます。</simpara>
<simpara><literal>Promise.all</literal> に渡してるのは、それを複数作り配列にしたものですね。</simpara>
<programlisting language="javascript" linenumbering="unnumbered">const promises = [
    timerPromisefy(1),
    timerPromisefy(32),
    timerPromisefy(64),
    timerPromisefy(128)
];</programlisting>
<simpara>この場合は、1, 32, 64, 128 ミリ秒後にそれぞれ <literal>resolve</literal> されます。</simpara>
<simpara>つまり、このpromiseオブジェクトの配列がすべてresolveされるには、最低でも128msかかることがわかります。
実際に<link linkend="Promise.all"><literal>Promise.all</literal></link> で処理してみると 約128msかかることがわかります。</simpara>
<simpara>このことから、<link linkend="Promise.all"><literal>Promise.all</literal></link> が一つづつ順番にやるわけではなく、
渡されたpromiseオブジェクトの配列を並列に実行してるということがわかります。</simpara>
<note>
<simpara>仮に逐次的に行われていた場合は、
1ms待機 &#8594; 32ms待機 &#8594; 64ms待機 &#8594; 128ms待機 となるので、
全て完了するまで225ms程度かかる計算になります。</simpara>
<simpara>実際にPromiseを逐次的に処理したいケースについては第4章の<link linkend="promise-sequence">Promiseによる逐次処理</link>を参照して下さい。</simpara>
</note>
</section>
<section xml:id="ch2-promise-race">
<title>Promise.race</title>
<simpara><link linkend="Promise.all"><literal>Promise.all</literal></link> と同様に複数のpromiseオブジェクトを扱う<link linkend="Promise.race"><literal>Promise.race</literal></link>を見てみましょう。</simpara>
<simpara>使い方はPromise.allと同様で、promiseオブジェクトの配列を引数に渡します。</simpara>
<simpara><literal>Promise.all</literal> は、渡した全てのpromiseがFulfilled または Rejectedになるまで次の処理を待ちましたが、
<literal>Promise.race</literal> は、どれか一つでもpromiseがFulfilled または Rejectedになったら次の処理を実行します。</simpara>
<simpara>Promise.allのときと同じく、タイマーを使った <literal>Promise.race</literal> の例を見てみましょう。</simpara>
<formalpara xml:id="promise-race-timer.js" role="executable">
<title>promise-race-timer.js</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">// `delay`ミリ秒後にresolveする
function timerPromisefy(delay) {
    return new Promise((resolve) =&gt; {
        setTimeout(() =&gt; {
            resolve(delay);
        }, delay);
    });
}
// 一つでもresolve または reject した時点で終了
Promise.race([
    timerPromisefy(1),
    timerPromisefy(32),
    timerPromisefy(64),
    timerPromisefy(128)
]).then((value) =&gt; {
    console.log(value); // =&gt; 1
});</programlisting>
</para>
</formalpara>
<simpara>上記のコードだと、1ms後、32ms後、64ms後、128ms後にそれぞれpromiseオブジェクトがFulfilledとなりますが、
一番最初に1msのものがFulfilledとなった時点で、<literal>.then</literal> が呼ばれます。
また、<literal>resolve(1)</literal> が呼ばれるため <literal>value</literal> に渡される値も1となります。</simpara>
<simpara>最初にFulfilledとなったpromiseオブジェクト以外は、その後呼ばれているのかを見てみましょう。</simpara>
<formalpara xml:id="promise-race-other.js" role="executable">
<title>promise-race-other.js</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">const winnerPromise = new Promise((resolve) =&gt; {
    setTimeout(() =&gt; {
        console.log("this is winner");
        resolve("this is winner");
    }, 4);
});
const loserPromise = new Promise((resolve) =&gt; {
    setTimeout(() =&gt; {
        console.log("this is loser");
        resolve("this is loser");
    }, 1000);
});

// 一番最初のものがresolveされた時点で終了
Promise.race([winnerPromise, loserPromise]).then((value) =&gt; {
    console.log(value); // =&gt; 'this is winner'
});</programlisting>
</para>
</formalpara>
<simpara>先ほどのコードに <literal>console.log</literal> をそれぞれ追加しただけの内容となっています。</simpara>
<simpara>実行してみると、winner/loser どちらも <literal>setTimeout</literal> の中身が実行されて <literal>console.log</literal> がそれぞれ出力されていることがわかります。</simpara>
<simpara>つまり、<link linkend="Promise.race"><literal>Promise.race</literal></link>では、
一番最初のpromiseオブジェクトがFulfilledとなっても、他のpromiseがキャンセルされるわけでは無いということがわかります。</simpara>
<note>
<simpara><link linkend="es-promises">ES Promises</link>の仕様には、キャンセルという概念はありません。
必ず、resolve or rejectによる状態の解決が起こることが前提となっています。
つまり、<link linkend="promise-states">状態</link>が固定されてしまうかもしれない処理には不向きであるといえます。
ライブラリによってはキャンセルを行う仕組みが用意されている場合があります。</simpara>
</note>
</section>
<section xml:id="then-or-catch">
<title>then or catch?</title>
<simpara><link linkend="catch-as-alias">前の章</link>で <link linkend="promise.catch"><literal>.catch</literal></link> は  <literal>promise.then(undefined, onRejected)</literal> であるということを紹介しました。</simpara>
<simpara>この書籍では基本的には、<link linkend="promise.catch"><literal>.catch</literal></link>を使い <link linkend="promise.then"><literal>.then</literal></link> とは分けてエラーハンドリングを書くようにしています。</simpara>
<simpara>ここでは、<literal>.then</literal> でまとめて指定した場合と、どのような違いがでるかについて学んでいきましょう。</simpara>
<section xml:id="_エラー処理ができないonrejected">
<title>エラー処理ができないonRejected</title>
<simpara>次のようなコードを見ていきます。</simpara>
<formalpara xml:id="then-throw-error.js" role="executable">
<title>then-throw-error.js</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">function throwError(value) { // 例外を投げる
    throw new Error(value);
}
// &lt;1&gt; onRejectedが呼ばれることはない
function badMain(onRejected) {
    return Promise.resolve(42).then(throwError, onRejected);
}
// &lt;2&gt; onRejectedが例外発生時に呼ばれる
function goodMain(onRejected) {
    return Promise.resolve(42).then(throwError).catch(onRejected);
}



// 実行例
badMain(function(){
    console.log("BAD");
});
goodMain(function(){
    console.log("GOOD");
});</programlisting>
</para>
</formalpara>
<simpara>このコード例では、(必ずしも悪いわけではないですが)良くないパターンの <literal>badMain</literal> と
ちゃんとエラーハンドリングが行える <literal>goodMain</literal> があります。</simpara>
<simpara><literal>badMain</literal> がなぜ良くないかというと、<literal>.then</literal> の第二引数にはエラー処理を書くことができますが、
そのエラー処理は第一引数の <literal>onFulfilled</literal> で指定した関数内で起きたエラーをキャッチすることはできません。</simpara>
<simpara>つまり、この場合、 <literal>throwError</literal> でエラーがおきても、<literal>onRejected</literal> に指定した関数は呼ばれることなく、
どこでエラーが発生したのかわからなくなってしまいます。</simpara>
<simpara>それに対して、 <literal>goodMain</literal> は <literal>throwError</literal> &#8594; <literal>onRejected</literal> となるように書かれています。
この場合は <literal>throwError</literal> でエラーが発生しても、次のchainである <literal>.catch</literal> が呼ばれるため、エラーハンドリングを行うことができます。</simpara>
<simpara><literal>.then</literal> のonRejectedが扱う処理は、その(またはそれ以前の)promiseオブジェクトに対してであって、
<literal>.then</literal> に書かれたonFulfilledは対象ではないためこのような違いが生まれます。</simpara>
<note>
<simpara><literal>.then</literal> や <literal>.catch</literal> はその場で<emphasis role="strong">新しい</emphasis>promiseオブジェクトを作って返します。
Promiseではchainする度に異なるpromiseオブジェクトに対して処理を書くようになっています。</simpara>
</note>
<figure xml:id="then-catch-flow">
<title>Then Catch flow</title>
<mediaobject>
<imageobject>
<imagedata fileref="Ch2_HowToWrite/img/then_catch.png"/>
</imageobject>
<textobject><phrase>Then Catch flow</phrase></textobject>
</mediaobject>
</figure>
<simpara>この場合の <literal>then</literal> は <literal>Promise.resolve(42)</literal> に対する処理となり、
<literal>onFulfilled</literal> で例外が発生しても、同じ <literal>then</literal> で指定された <literal>onRejected</literal> はキャッチすることはありません。</simpara>
<simpara>この <literal>then</literal> で発生した例外をキャッチできるのは、次のchainで書かれた <literal>catch</literal> となります。</simpara>
<simpara>もちろん <literal>.catch</literal> は <literal>.then</literal> のエイリアスなので、下記のように <literal>.then</literal> を使っても問題はありませんが、
<literal>.catch</literal> を使ったほうが意図が明確で分かりやすいでしょう。</simpara>
<programlisting language="javascript" linenumbering="unnumbered">Promise.resolve(42).then(throwError).then(null, onRejected);</programlisting>
</section>
<section xml:id="_まとめ_2">
<title>まとめ</title>
<simpara>ここでは次のようなことについて学びました。</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara><literal>promise.then(onFulfilled, onRejected)</literal> において</simpara>
<itemizedlist>
<listitem>
<simpara><literal>onFulfilled</literal> で例外がおきても、この <literal>onRejected</literal> はキャッチできない</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara><literal>promise.then(onFulfilled).catch(onRejected)</literal> とした場合</simpara>
<itemizedlist>
<listitem>
<simpara><literal>then</literal> で発生した例外を <literal>.catch</literal> でキャッチできる</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara><link linkend="promise.then"><literal>.then</literal></link>と<link linkend="promise.catch"><literal>.catch</literal></link>に本質的な意味の違いはない</simpara>
<itemizedlist>
<listitem>
<simpara>使い分けると意図が明確になる</simpara>
</listitem>
</itemizedlist>
</listitem>
</orderedlist>
<simpara><literal>badMain</literal> のような書き方をすると、意図とは異なりエラーハンドリングができないケースが存在することは覚えておきましょう。</simpara>
</section>
</section>
</section>
<section xml:id="chapter3-promise-testing">
<title>Chapter.3 - Promiseのテスト</title>
<simpara>この章ではPromiseのテストの書き方について学んで行きます。</simpara>
<section xml:id="basic-tests">
<title>基本的なテスト</title>
<simpara><link linkend="es-promises">ES Promises</link>のメソッド等についてひととおり学ぶことができたため、
実際にPromiseを使った処理を書いていくことはできると思います。</simpara>
<simpara>そうした時に、次にどうすればいいのか悩むのがPromiseのテストの書き方です。</simpara>
<simpara>ここではまず、 <link xl:href="https://mochajs.org/">Mocha</link>を使った基本的なPromiseのテストの書き方について学んでいきましょう。</simpara>
<simpara>また、この章でのテストコードはNode.js環境で実行することを前提としているため、
各自Node.js環境を用意してください。</simpara>
<note>
<simpara>この書籍中に出てくるサンプルコードはそれぞれテストも書かれています。
テストコードは <link xl:href="https://github.com/azu/promises-book">azu/promises-book</link> から参照できます。</simpara>
</note>
<section xml:id="_mochaとは">
<title>Mochaとは</title>
<simpara>Mochaの公式サイト: <link xl:href="https://mochajs.org/">https://mochajs.org/</link></simpara>
<simpara>ここでは、 Mocha自体については詳しく解説しませんが、
MochaはNode.js製のテストフレームワークツールです。</simpara>
<simpara>MochaはBDD,TDD,exportsのどれかのスタイルを選択でき、テストに使うアサーションメソッドも任意のライブラリと組み合わせて利用します。
つまり、Mocha自体はテスト実行時の枠だけを提供しており、他は利用者が選択するというものになっています。</simpara>
<simpara>Mochaを選択した理由は、以下のとおりです。</simpara>
<itemizedlist>
<listitem>
<simpara>著名なテストフレームワークであること</simpara>
</listitem>
<listitem>
<simpara>Node.jsとブラウザ どちらのテストもサポートしている</simpara>
</listitem>
<listitem>
<simpara>"Promiseのテスト"をサポートしている</simpara>
</listitem>
</itemizedlist>
<simpara>最後の <emphasis>"Promiseのテスト"をサポートしている</emphasis> とはどういうことなのかについては後ほど解説します。</simpara>
<simpara>この章ではMochaを利用するため、npmを使いMochaをインストールしておく必要があります。</simpara>
<programlisting language="console" linenumbering="unnumbered">$ npm install -g mocha</programlisting>
<simpara>また、アサーション自体はNode.jsに同梱されている <literal>assert</literal> モジュールを使用するので別途インストールは必要ありません。</simpara>
<simpara>まずはコールバックスタイルの非同期処理をテストしてみましょう。</simpara>
</section>
<section xml:id="_コールバックスタイルのテスト">
<title>コールバックスタイルのテスト</title>
<simpara>コールバックスタイルの非同期処理をテストする場合、Mochaでは以下のように書くことができます。</simpara>
<formalpara>
<title>basic-test.js</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">const assert = require("assert");
it("should use `done` for test", (done) =&gt; {
    setTimeout(() =&gt; {
        assert(true);
        done();
    }, 0);
});</programlisting>
</para>
</formalpara>
<simpara>このテストを <literal>basic-test.js</literal> というファイル名で作成し、
先ほどインストールしたMochaでコマンドラインからテストを実行することができます。</simpara>
<programlisting language="sh" linenumbering="unnumbered">$ mocha basic-test.js</programlisting>
<simpara>Mochaは <literal>it</literal> の仮引数に <literal>done</literal> のように指定してあげると、
<literal>done()</literal> が呼ばれるまでテストの終了を待つことで非同期のテストをサポートしています。</simpara>
<simpara>Mochaでの非同期テストは以下のような流れで実行されます。</simpara>
<programlisting xml:id="callback-style-test" language="javascript" linenumbering="unnumbered">it("should use `done` for test", (done) =&gt; {
    <co xml:id="CO7-1"/>
    setTimeout(() =&gt; {
        assert(true);
        done();<co xml:id="CO7-2"/>
    }, 0);
});</programlisting>
<calloutlist>
<callout arearefs="CO7-1">
<para>コールバックを使う非同期処理</para>
</callout>
<callout arearefs="CO7-2">
<para><literal>done</literal> を呼ぶことでテストが終了する</para>
</callout>
</calloutlist>
<simpara>よく見かける形の書き方ですね。</simpara>
</section>
<section xml:id="done-promise-test">
<title><literal>done</literal> を使ったPromiseのテスト</title>
<simpara>次に、同じく <literal>done</literal> を使ったPromiseのテストを書いてみましょう。</simpara>
<programlisting language="javascript" linenumbering="unnumbered">it("should use `done` for test?", (done) =&gt; {
    const promise = Promise.resolve(42);<co xml:id="CO8-1"/>
    promise.then((value) =&gt; {
        assert(value === 42);
        done();<co xml:id="CO8-2"/>
    });
});</programlisting>
<calloutlist>
<callout arearefs="CO8-1">
<para><literal>Fulfilled</literal> となるpromiseオブジェクトを作成</para>
</callout>
<callout arearefs="CO8-2">
<para><literal>done</literal> を呼ぶことでテストの終了を宣言</para>
</callout>
</calloutlist>
<simpara><link linkend="Promise.resolve"><literal>Promise.resolve</literal></link> はpromiseオブジェクトを返しますが、
そのpromiseオブジェクトはFulfilledの状態になります。
その結果として <literal>.then</literal> で登録したコールバック関数が呼び出されます。</simpara>
<simpara><link linkend="promise-is-always-async">コラム: Promiseは常に非同期?</link> でも出てきたように、
promiseオブジェクトは常に非同期で処理されるため、テストも非同期に対応した書き方が必要となります。</simpara>
<simpara>しかし、先ほどのテストコードでは <literal>assert</literal> が失敗した場合に問題が発生します。</simpara>
<formalpara xml:id="promise-assert-fail">
<title>意図しない結果となるPromiseのテスト</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">it("should use `done` for test?", (done) =&gt; {
    const promise = Promise.resolve();
    promise.then((value) =&gt; {
        assert(false);// =&gt; throw AssertionError
        done();
    });
});</programlisting>
</para>
</formalpara>
<simpara>このテストは <literal>assert</literal> が失敗しているため、「テストは失敗する」と思うかもしれませんが、
実際にはテストが終わることがなくタイムアウトします。</simpara>
<figure>
<title>テストが終わることがないためタイムアウトするまでそこで止まる</title>
<mediaobject>
<imageobject>
<imagedata fileref="Ch3_Testing/img/promise-test-timeout.png"/>
</imageobject>
<textobject><phrase>promise test timeout</phrase></textobject>
</mediaobject>
</figure>
<simpara><literal>assert</literal> が失敗した場合は通常はエラーをthrowし、
テストフレームワークがそれをキャッチすることで、テストが失敗したと判断します。</simpara>
<simpara>しかし、Promiseの場合は <literal>.then</literal> の中で行われた処理でエラーが発生しても、
Promiseがそれをキャッチしてしまい、テストフレームワークまでエラーが届きません。</simpara>
<simpara><link linkend="promise-assert-fail">意図しない結果となるPromiseのテスト</link>を改善して、
<literal>assert</literal> が失敗した場合にちゃんとテストが失敗となるようにしてみましょう。</simpara>
<formalpara xml:id="promise-assert-fail-fixed">
<title>意図通りにテストが失敗する例</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">it("should use `done` for test?", (done) =&gt; {
    const promise = Promise.resolve();
    promise.then((value) =&gt; {
        assert(false);
    }).then(done, done);
});</programlisting>
</para>
</formalpara>
<simpara>ちゃんとテストが失敗する例では、必ず <literal>done</literal> が呼ばれるようにするため、
最後に <literal>.then(done, done);</literal> を追加しています。</simpara>
<simpara><literal>assert</literal> がパスした場合は単純に <literal>done()</literal> が呼ばれ、<literal>assert</literal> が失敗した場合は <literal>done(error)</literal> が呼ばれます。</simpara>
<simpara>これでようやく<link linkend="callback-style-test">コールバックスタイルのテスト</link>と同等のPromiseのテストを書くことができました。</simpara>
<simpara>しかし、<literal>assert</literal> が失敗した時のために <literal>.then(done, done);</literal> というものを付ける必要があります。
Promiseのテストを書くときにつけ忘れてしまうと終わらないテストができ上がってしまう場合があることに気をつけましょう。</simpara>
<simpara>次に、最初にmochaを使う理由に上げた"Promisesのテスト"のサポートがどのような機能であるか学んでいきましょう。</simpara>
</section>
</section>
<section xml:id="mocha-promise">
<title>MochaのPromiseサポート</title>
<simpara>Mochaがサポートしてる"Promiseのテスト"とは何かについて学んでいきましょう。</simpara>
<simpara>公式サイトの <link xl:href="https://mochajs.org/#asynchronous-code">Asynchronous code</link>にもその概要が書かれています。</simpara>
<blockquote>
<simpara>Alternately, instead of using the done() callback, you can return a promise. This is useful if the APIs you are testing return promises instead of taking callbacks:</simpara>
</blockquote>
<simpara>Promiseのテストの場合はコールバックとして <literal>done()</literal> を呼ぶ代わりに、promiseオブジェクトをreturnすることができると書いてあります。</simpara>
<simpara>では、実際にどのように書くかの例を見ていきたいと思います。</simpara>
<formalpara xml:id="mocha-promise-test.js">
<title>mocha-promise-test.js</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">const assert = require("assert");
describe("Promise Test", () =&gt; {
    it("should return a promise object", () =&gt; {
        const promise = Promise.resolve(42);
        return promise.then((value) =&gt; {
            assert(value === 42);
        });
    });
});</programlisting>
</para>
</formalpara>
<simpara><link linkend="promise-assert-fail-fixed">先ほどの <literal>done</literal> を使った例</link>をMochaのPromiseテストの形式に変更しました。</simpara>
<simpara>変更点としては以下の2つとなっています。</simpara>
<itemizedlist>
<listitem>
<simpara><literal>done</literal> そのものを取り除いた</simpara>
</listitem>
<listitem>
<simpara>promiseオブジェクトを返すようにした</simpara>
</listitem>
</itemizedlist>
<simpara>この書き方をした場合、<literal>assert</literal> が失敗した場合はもちろんテストが失敗します。</simpara>
<programlisting language="javascript" linenumbering="unnumbered">it("should be fail", () =&gt; {
    return Promise.resolve().then(() =&gt; {
        assert(false);// =&gt; テストが失敗する
    });
});</programlisting>
<simpara>これにより <literal>.then(done, done);</literal> というような本質的にはテストとは関係ない記述を省くことができるようになりました。</simpara>
<note>
<simpara><link xl:href="http://efcl.info/2014/0314/res3708/">MochaがPromisesのテストをサポートしました | Web scratch</link> という記事でも
MochaのPromiseサポートについて書かれています。</simpara>
</note>
<section xml:id="_意図しないテスト結果">
<title>意図しないテスト結果</title>
<simpara>MochaがPromiseのテストをサポートしているため、この書き方でよいと思われるかもしれません。
しかし、この書き方にも意図しない結果になる例外が存在します。</simpara>
<simpara>たとえば、以下はある条件だとRejectedなpromiseオブジェクトを返す <literal>mayBeRejected()</literal> のテストコードです。</simpara>
<formalpara xml:id="mocha-rejected-promise-test">
<title>エラーオブジェクトをテストしたい</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">function mayBeRejected() { <co xml:id="CO9-1"/>
    return Promise.reject(new Error("woo"));
}
it("is bad pattern", () =&gt; {
    return mayBeRejected().catch((error) =&gt; {
        assert(error.message === "woo");
    });
});</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO9-1">
<para>この関数が返すpromiseオブジェクトをテストしたい</para>
</callout>
</calloutlist>
<simpara>このテストの目的とは以下のようになっています。</simpara>
<variablelist>
<varlistentry>
<term><literal>mayBeRejected()</literal> が返すpromiseオブジェクトがFulfilledとなった場合</term>
<listitem>
<simpara>テストを失敗させる</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>mayBeRejected()</literal> が返すpromiseオブジェクトがRejectedとなった場合</term>
<listitem>
<simpara><literal>assert</literal> でErrorオブジェクトをチェックする</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>上記のテストコードでは、Rejectedとなって <literal>onRejected</literal> に登録された関数が呼ばれるためテストはパスしますね。</simpara>
<simpara>このテストで問題になるのは <literal>mayBeRejected()</literal> で返されたpromiseオブジェクトが
<emphasis role="strong">Fulfilledとなった場合</emphasis>に、必ずテストがパスしてしまうという問題が発生します。</simpara>
<programlisting language="javascript" linenumbering="unnumbered">function mayBeRejected() { <co xml:id="CO10-1"/>
    return Promise.resolve();
}
it("is bad pattern", () =&gt; {
    return mayBeRejected().catch((error) =&gt; {
        assert(error.message === "woo");
    });
});</programlisting>
<calloutlist>
<callout arearefs="CO10-1">
<para>返されるpromiseオブジェクトはFulfilledとなる</para>
</callout>
</calloutlist>
<simpara>この場合、<literal>catch</literal> で登録した <literal>onRejected</literal> の関数はそもそも呼ばれないため、
<literal>assert</literal> がひとつも呼ばれることなくテストが必ずパスしてしまいます。</simpara>
<simpara>これを解消しようとして、<literal>.catch</literal> の前に <literal>.then</literal> を入れて、
<literal>.then</literal> が呼ばれたらテストを失敗にしたいと考えるかもしれません。</simpara>
<programlisting language="javascript" linenumbering="unnumbered">function failTest() { <co xml:id="CO11-1"/>
    throw new Error("Expected promise to be rejected but it was fulfilled");
}
function mayBeRejected() {
    return Promise.resolve();
}
it("should bad pattern", () =&gt; {
    return mayBeRejected().then(failTest).catch((error) =&gt; {
        assert(error.message === "woo");
    });
});</programlisting>
<calloutlist>
<callout arearefs="CO11-1">
<para>throwすることでテストを失敗にしたい</para>
</callout>
</calloutlist>
<simpara>しかし、この書き方だと<link linkend="then-or-catch">then or catch?</link>で紹介したように、
<literal>failTest</literal> で投げられたエラーが <literal>catch</literal> されてしまいます。</simpara>
<figure>
<title>Then Catch flow</title>
<mediaobject>
<imageobject>
<imagedata fileref="Ch2_HowToWrite/img/then_catch.png"/>
</imageobject>
<textobject><phrase>Then Catch flow</phrase></textobject>
</mediaobject>
</figure>
<simpara><literal>then</literal> &#8594; <literal>catch</literal> となり、<literal>catch</literal> に渡ってくるErrorオブジェクトは <literal>AssertionError</literal> となり、
意図したものとは違うものが渡ってきてしまいます。</simpara>
<simpara>つまり、onRejectedになること<emphasis role="strong">だけ</emphasis>を期待して書かれたテストは、onFulfilledの状態になってしまうと
常にテストがパスしてしまうという問題を持っていることが分かります。</simpara>
</section>
<section xml:id="_両状態を明示して意図しないテストを改善">
<title>両状態を明示して意図しないテストを改善</title>
<simpara><link linkend="mocha-rejected-promise-test">上記のエラーオブジェクトのテスト</link>を書く場合、
どのようにすれば意図せず通ってしまうテストを無くすことができるでしょうか?</simpara>
<simpara>一番単純な方法としては、以下のようにそれぞれの状態の場合にどうなるのかをテストコードに書く方法です。</simpara>
<variablelist>
<varlistentry>
<term>Fulfilledとなった場合</term>
<listitem>
<simpara>意図したとおりテストが失敗する</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Rejectedとなった場合</term>
<listitem>
<simpara><literal>assert</literal> でテストを行える</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>つまり、Fulfilled、Rejected 両方の状態について、テストがどうなってほしいかを明示する必要があるわけです。</simpara>
<programlisting language="javascript" linenumbering="unnumbered">function mayBeRejected() {
    return Promise.resolve();
}
it("catch -&gt; then", () =&gt; {
    // Fulfilledとなった場合はテストは失敗する
    return mayBeRejected().then(failTest, (error) =&gt; {
        assert(error.message === "woo");
    });
});</programlisting>
<simpara>このように書くことで、Fulfilledとなった場合は失敗するテストコードを書くことができます。</simpara>
<figure>
<title>Promise onRejected test</title>
<mediaobject>
<imageobject>
<imagedata fileref="Ch3_Testing/img/promise-test.png"/>
</imageobject>
<textobject><phrase>Promise onRejected test</phrase></textobject>
</mediaobject>
</figure>
<simpara><link linkend="then-or-catch">then or catch?</link>のときは、エラーの見逃しを避けるため、
<literal>.then(onFulfilled, onRejected)</literal> の第二引数ではなく、<literal>then</literal> &#8594; <literal>catch</literal> と分けることを推奨していました。</simpara>
<simpara>しかし、テストの場合はPromiseの強力なエラーハンドリングが逆にテストの邪魔をしてしまいます。
そのため <literal>.then(failTest, onRejected)</literal> と書くことで、どちらの状態になるのかを明示してテストを書くことができました。</simpara>
</section>
<section xml:id="_まとめ_3">
<title>まとめ</title>
<simpara>MochaのPromiseサポートについてと意図しない挙動となる場合について紹介しました。</simpara>
<itemizedlist>
<listitem>
<simpara>通常のコードは <literal>then</literal> &#8594; <literal>catch</literal> と分けた方がよい</simpara>
<itemizedlist>
<listitem>
<simpara>エラーハンドリングのため。<link linkend="then-or-catch">then or catch?</link>を参照</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>テストコードは <literal>then</literal> にまとめた方がよい</simpara>
<itemizedlist>
<listitem>
<simpara>アサーションエラーがテストフレームワークに届くようにするため。</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<simpara><literal>.then(onFulfilled, onRejected)</literal> を使うことで、
promiseオブジェクトがFulfilled、Rejectedどちらの状態になるかを明示してテストする必要があります。</simpara>
<simpara>しかし、Rejectedのテストであることを明示するために、以下のように書くのはあまり直感的ではないと思います。</simpara>
<programlisting language="javascript" linenumbering="unnumbered">promise.then(failTest, (error) =&gt; {
    // assertでerrorをテストする
});</programlisting>
<simpara>次は、Promiseのテストを手助けするヘルパー関数を定義して、
もう少し分かりやすいテストを書くにはどうするべきかについて見ていきましょう。</simpara>
</section>
</section>
<section xml:id="controllable-tests">
<title>意図したテストを書くには</title>
<simpara>ここでいう意図したテストとは以下のような定義で進めます。</simpara>
<simpara>あるpromiseオブジェクトをテスト対象として</simpara>
<itemizedlist>
<listitem>
<simpara>Fulfilledされることを期待したテストを書いた時</simpara>
<itemizedlist>
<listitem>
<simpara>Rejectedとなった場合は<emphasis role="strong">Fail</emphasis></simpara>
</listitem>
<listitem>
<simpara>assertionの結果が一致しなかった場合は<emphasis role="strong">Fail</emphasis></simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Rejectedされることを期待したテストを書いた時</simpara>
<itemizedlist>
<listitem>
<simpara>Fulfilledとなった場合は<emphasis role="strong">Fail</emphasis></simpara>
</listitem>
<listitem>
<simpara>assertionの結果が一致しなかった場合は<emphasis role="strong">Fail</emphasis></simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<simpara>上記のケース(Fail)に該当しなければテストがパスするということですね。</simpara>
<simpara>つまり、ひとつのテストケースにおいて以下のことを書く必要があります。</simpara>
<itemizedlist>
<listitem>
<simpara>Fulfilled or Rejected どちらを期待するか</simpara>
</listitem>
<listitem>
<simpara>assertionで渡された値のチェック</simpara>
</listitem>
</itemizedlist>
<simpara>先ほどの <literal>.then</literal> を使ったコードはRejectedを期待したテストとなっていますね。</simpara>
<programlisting language="javascript" linenumbering="unnumbered">promise.then(failTest, (error) =&gt; {
    // assertでerrorをテストする
    assert(error instanceof Error);
});</programlisting>
<section xml:id="_どちらの状態になるかを明示する">
<title>どちらの状態になるかを明示する</title>
<simpara>意図したテストにするためには、<link linkend="promise-states">promiseの状態</link>が
Fulfilled or Rejected どちらの状態になって欲しいかを明示する必要があります。</simpara>
<simpara>しかし、<literal>.then</literal> だと引数は省略可能なので、テストが落ちる条件を入れ忘れる可能性もあります。</simpara>
<simpara>そこで、promiseオブジェクトに期待する状態を明示できるヘルパー関数を定義してみましょう。</simpara>
<note>
<simpara>ライブラリ化したものが <link xl:href="https://github.com/azu/promise-test-helper">azu/promise-test-helper</link> にありますが、
今回はその場で簡単に定義して進めます。</simpara>
</note>
<simpara>まずは、先ほどの <literal>.then</literal> の例を元にonRejectedを期待してテストできる
<literal>shouldRejected</literal> というヘルパー関数を作ってみたいと思います。</simpara>
<formalpara xml:id="shouldRejected-test.js">
<title>shouldRejected-test.js</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">const assert = require("assert");
function shouldRejected(promise) {
    return {
        "catch": function(fn) {
            return promise.then(() =&gt; {
                throw new Error("Expected promise to be rejected but it was fulfilled");
            }, (reason) =&gt; {
                fn.call(promise, reason);
            }
            );
        }
    };
}
it("should be rejected", () =&gt; {
    const promise = Promise.reject(new Error("human error"));
    return shouldRejected(promise).catch((error) =&gt; {
        assert(error.message === "human error");
    });
});</programlisting>
</para>
</formalpara>
<simpara><literal>shouldRejected</literal> にpromiseオブジェクトを渡すと、<literal>catch</literal> というメソッドをもつオブジェクトを返します。</simpara>
<simpara>この <literal>catch</literal> にはonRejectedで書くものと全く同じ使い方ができるので、
<literal>catch</literal> の中にassertionによるテストを書けるようになっています。</simpara>
<simpara><literal>shouldRejected</literal> で囲む以外は、通常のpromiseの処理と似た感じになるので以下のようになります。</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara><literal>shouldRejected</literal> にテスト対象のpromiseオブジェクトを渡す</simpara>
</listitem>
<listitem>
<simpara>返ってきたオブジェクトの <literal>catch</literal> メソッドでonRejectedの処理を書く</simpara>
</listitem>
<listitem>
<simpara>onRejectedにassertionによるテストを書く</simpara>
</listitem>
</orderedlist>
<simpara><literal>shouldRejected</literal> を使った場合、Fulfilledが呼ばれるとエラーをthrowしてテストが失敗するようになっています。</simpara>
<programlisting language="javascript" linenumbering="unnumbered">promise.then(failTest, (error) =&gt; {
    assert(error.message === "human error");
});
// == ほぼ同様の意味
shouldRejected(promise).catch((error) =&gt; {
    assert(error.message === "human error");
});</programlisting>
<simpara><literal>shouldRejected</literal> のようなヘルパー関数を使うことで、テストコードが少し直感的になりましたね。</simpara>
<figure>
<title>Promise onRejected test</title>
<mediaobject>
<imageobject>
<imagedata fileref="Ch3_Testing/img/promise-test.png"/>
</imageobject>
<textobject><phrase>Promise onRejected test</phrase></textobject>
</mediaobject>
</figure>
<simpara>同様に、promiseオブジェクトがFulfilledになることを期待する <literal>shouldFulfilled</literal> も書いてみましょう。</simpara>
<formalpara xml:id="shouldFulfilled-test.js">
<title>shouldFulfilled-test.js</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">const assert = require("assert");
function shouldFulfilled(promise) {
    return {
        "then": function(fn) {
            return promise.then((value) =&gt; {
                fn.call(promise, value);
            }, (reason) =&gt; {
                throw reason;
            }
            );
        }
    };
}
it("should be fulfilled", () =&gt; {
    const promise = Promise.resolve("value");
    return shouldFulfilled(promise).then((value) =&gt; {
        assert(value === "value");
    });
});</programlisting>
</para>
</formalpara>
<simpara><xref linkend="shouldRejected-test.js"/>と基本は同じで、返すオブジェクトの <literal>catch</literal> が <literal>then</literal> になって中身が逆転しただけですね。</simpara>
</section>
<section xml:id="_まとめ_4">
<title>まとめ</title>
<simpara>Promiseで意図したテストを書くためにはどうするか、またそれを補助するヘルパー関数について学びました。</simpara>
<note>
<simpara>今回書いた <literal>shouldFulfilled</literal> と <literal>shouldRejected</literal> はライブラリとして利用できるようになっています。</simpara>
<simpara><link xl:href="https://github.com/azu/promise-test-helper">azu/promise-test-helper</link> からダウンロードすることができます。</simpara>
<simpara>また、Node.js 10.0.0から <literal>assert.rejects</literal> と <literal>assert.doesNotReject</literal> というよく似た趣旨のassertionが提供されています。
詳細は、 <link xl:href="https://nodejs.org/api/assert.html">Node.jsのAPIドキュメント</link>を参照してください。</simpara>
</note>
<simpara>また、今回のヘルパー関数は<link linkend="mocha-promise">MochaのPromiseサポート</link>を前提とした書き方なので、
<link linkend="done-promise-test"><literal>done</literal> を使ったテスト</link>では利用しにくいと思います。</simpara>
<simpara>テストフレームワークのPromiseサポートを使うか、<literal>done</literal> のようにコールバックスタイルのテストを使うかは、
人それぞれのスタイルの問題であるためそこまではっきりした優劣はないと思います。</simpara>
<simpara>たとえば、 <link xl:href="http://coffeescript.org/">CoffeeScript</link>でテストを書いたりすると、
CoffeeScriptには暗黙のreturnがあるので、<literal>done</literal> を使ったほうが分かりやすいかもしれません。</simpara>
<simpara>Promiseのテストは普通に非同期関数のテスト以上に落とし穴があるため、
どのスタイルを取るかは自由ですが、一貫性を持った書き方をすることが大切だといえます。</simpara>
</section>
</section>
</section>
<section xml:id="chapter4-advanced-promise">
<title>Chapter.4 - Advanced</title>
<simpara>この章では、これまでに学んだことの応用や発展した内容について学んでいきます。</simpara>
<section xml:id="promise-library">
<title>Promiseのライブラリ</title>
<simpara>このセクションでは、ブラウザが実装しているPromiseではなく、サードパーティにより作られた
Promise互換のライブラリについて紹介していきたいと思います。</simpara>
<section xml:id="_なぜライブラリが必要か">
<title>なぜライブラリが必要か?</title>
<simpara>なぜライブラリが必要か?という疑問に関する多くの答えとしては、
その実行環境で「<link linkend="es-promises">ES Promises</link>が実装されていないから」というのがまず出てくるでしょう。</simpara>
<simpara>Promiseのライブラリを探すときに、一つ目印になる言葉として<link linkend="promises-aplus">Promises/A+互換</link>があります。</simpara>
<simpara><link linkend="promises-aplus">Promises/A+</link>というのは<link linkend="es-promises">ES Promises</link>の前身となったもので、
Promiseの <literal>then</literal> について取り決めたコミュニティベースの仕様です。</simpara>
<simpara>Promises/A+互換と書かれていた場合は <literal>then</literal> についての動作は互換性があり、
多くの場合はそれに加えて <literal>Promise.all</literal> や <literal>catch</literal> 等と同様の機能が実装されています。</simpara>
<simpara>しかし、Promises/A+は <literal>Promise#then</literal> についてのみの仕様となっているため、
他の機能は実装されていても名前が異なる場合があります。</simpara>
<simpara>また、<literal>then</literal> というメソッドに互換性があるということは、<link linkend="Thenable">Thenable</link>であるということなので、
<link linkend="Promise.resolve">Promise.resolve</link>を使い、ESのPromiseで定められたpromiseオブジェクトに変換することができます。</simpara>
<note>
<simpara>ECMAScriptのPromiseで定められたpromiseオブジェクトというのは、
<literal>catch</literal> というメソッドが使えたり、<literal>Promise.all</literal> で扱う際に問題が起こらないということです。</simpara>
</note>
</section>
<section xml:id="_polyfillとライブラリ">
<title>Polyfillとライブラリ</title>
<simpara>ここでは、大きくわけて2種類のライブラリを紹介したいと思います。</simpara>
<simpara>一つはPolyfillと呼ばれる種類のライブラリで、
もう一つは、<link linkend="promises-aplus">Promises/A+互換</link>に加えて、独自の拡張をもったライブラリです。</simpara>
<note>
<simpara>Promiseのライブラリは星の数ほどあるので、ここで紹介するのは極々一部です。</simpara>
</note>
<section xml:id="promise-polyfill">
<title>Polyfill</title>
<simpara>Polyfillライブラリは読み込むことで、IEといったPromiseが実装されていないブラウザ等でも、
Promiseと同等の機能を同じメソッド名で提供してくれるライブラリのことです。</simpara>
<simpara>つまり、Polyfillを読みこめばこの書籍で紹介しているコードは、
Promiseがサポートされてない環境でも実行できるようになります。</simpara>
<variablelist>
<varlistentry>
<term><link xl:href="https://github.com/zloirock/core-js">zloirock/core-js</link></term>
<listitem>
<simpara>ECMAScriptやウェブ標準で定義されている仕様を実装したPolyfillライブラリです。
多種多様な機能のPolyfillが含まれており、その一つとしてPromiseのPolyfillが実装されています。
<link xl:href="https://babeljs.io/">Babel</link>のプリセットにも組み込まれています。</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link xl:href="https://github.com/jakearchibald/es6-promise">jakearchibald/es6-promise</link></term>
<listitem>
<simpara>ES6(ES2015) Promisesと互換性を持ったPolyfillライブラリです。
<link xl:href="https://github.com/tildeio/rsvp.js">RSVP.js</link> という Promises/A+互換ライブラリがベースとなっており、
これのサブセットとしてES6 PromisesのAPIだけが実装されているライブラリです。</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link xl:href="https://github.com/taylorhakes/promise-polyfill">taylorhakes/promise-polyfill</link></term>
<listitem>
<simpara>ES Promisesのpolyfillとなることを目的としたライブラリです。
実行環境にネイティブのPromiseがある場合はそちらを優先し、上書きしないようにしています。</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_promise拡張ライブラリ">
<title>Promise拡張ライブラリ</title>
<simpara>Promiseを仕様どおりに実装したものに加えて独自のメソッド等を提供してくれるライブラリです。</simpara>
<simpara>Promise拡張ライブラリは本当に沢山ありますが、以下の2つの著名なライブラリを紹介します。</simpara>
<variablelist>
<varlistentry>
<term><link xl:href="https://github.com/kriskowal/q">kriskowal/q</link></term>
<listitem>
<simpara><literal>Q</literal> と呼ばれるPromisesやDeferredsを実装したライブラリです。
2009年から開発されており、Node.js向けのファイルIOのAPIを提供する <link xl:href="https://github.com/kriskowal/q-io">Q-IO</link> 等、
多くの状況で使える機能が用意されているライブラリです。</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link xl:href="https://github.com/petkaantonov/bluebird">petkaantonov/bluebird</link></term>
<listitem>
<simpara>Promise互換に加えて、キャンセルできるPromiseや進行度を取得できるPromise、エラーハンドリングの拡張検出等、
多くの拡張を持っており、またパフォーマンスにも気を配った実装がされているライブラリです。</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>Q と Bluebird どちらのライブラリもブラウザでも動作する他、APIリファレンスが充実しているのも特徴的です。</simpara>
<itemizedlist>
<listitem>
<simpara><link xl:href="https://github.com/kriskowal/q/wiki/API-Reference">API Reference · kriskowal/q Wiki</link></simpara>
</listitem>
</itemizedlist>
<simpara>QのドキュメントにはjQueryがもつDeferredの仕組みとどのように違うのか、移行する場合の対応メソッドについても
<link xl:href="https://github.com/kriskowal/q/wiki/Coming-from-jQuery">Coming from jQuery</link> にまとめられています。</simpara>
<itemizedlist>
<listitem>
<simpara><link xl:href="https://github.com/petkaantonov/bluebird/blob/master/API.md">bluebird/API.md at master · petkaantonov/bluebird</link></simpara>
</listitem>
</itemizedlist>
<simpara>BluebirdではPromiseを使った豊富な機能に加えて、エラーが起きた時の対処法や
<link xl:href="https://github.com/petkaantonov/bluebird/wiki/Promise-anti-patterns">Promiseのアンチパターン</link> について書かれています。</simpara>
<simpara>どちらのドキュメントも優れているため、このライブラリを使ってない場合でも読んでおくと参考になることが多いと思います。</simpara>
</section>
</section>
<section xml:id="_まとめ_5">
<title>まとめ</title>
<simpara>このセクションではPromiseのライブラリとしてPolyfillと拡張ライブラリを紹介しました。</simpara>
<simpara>Promiseのライブラリは多種多様であるため、どれを使用するかは好みの問題といえるでしょう。</simpara>
<simpara>しかし、PromiseはPromises/A+ または ES Promisesという共通のインターフェースを持っているため、
そのライブラリで書かれているコードや独自の拡張などは、他のライブラリを利用している時でも参考になるケースは多いでしょう。</simpara>
<simpara>そのようなPromiseの共通の概念を学び、応用できるようになるのがこの書籍の目的の一つです。</simpara>
</section>
</section>
<section xml:id="resolve-thenable">
<title>Promise.resolveとThenable</title>
<simpara><link linkend="ch2-promise-resolve">第二章のPromise.resolve</link>にて、<literal>Promise.resolve</literal> の大きな特徴の一つとしてthenableなオブジェクトを変換する機能について紹介しました。</simpara>
<simpara>このセクションでは、thenableなオブジェクトからpromiseオブジェクトに変換してどのように利用するかについて学びたいと思います。</simpara>
<section xml:id="_web_notificationsをthenableにする">
<title>Web Notificationsをthenableにする</title>
<simpara><link xl:href="https://developer.mozilla.org/ja/docs/Web/API/notification">Web Notifications</link>という
デスクトップ通知を行うAPIを例に考えてみます。</simpara>
<simpara>Web Notifications APIについて詳しくは以下を参照して下さい。</simpara>
<itemizedlist>
<listitem>
<simpara><link xl:href="https://developer.mozilla.org/ja/docs/WebAPI/Using_Web_Notifications">Web Notifications の使用 - WebAPI | MDN</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://caniuse.com/notifications">Can I use Web Notifications</link></simpara>
</listitem>
</itemizedlist>
<simpara>Web Notifications APIについて簡単に解説すると、以下のように <literal>new Notification</literal> をすることで通知メッセージが表示できます。</simpara>
<programlisting language="javascript" linenumbering="unnumbered">new Notification("Hi!");</programlisting>
<simpara>しかし、通知を行うためには、<literal>new Notification</literal> をする前にユーザーに許可を取る必要があります。</simpara>
<figure>
<title>Notificationの許可ダイアログ</title>
<mediaobject>
<imageobject>
<imagedata fileref="Ch4_AdvancedPromises/img/notification-dialog.png"/>
</imageobject>
<textobject><phrase>Notificationの許可ダイアログ</phrase></textobject>
</mediaobject>
</figure>
<simpara>この許可ダイアログで選択した結果は、<literal>Notification.permission</literal> に入りますが、
値は許可("granted")か不許可("denied")の2種類です。</simpara>
<note>
<simpara>Notificationのダイアログの選択肢は、
Firefoxだと許可、不許可に加えて <emphasis>永続</emphasis> か <emphasis>セッション限り</emphasis> の組み合わせがありますが、値自体は同じです。</simpara>
</note>
<simpara>許可ダイアログは <literal>Notification.requestPermission()</literal> を実行すると表示され、
ユーザーが選択した結果がコールバック関数の <literal>status</literal> に渡されます。</simpara>
<simpara>コールバック関数を受け付けることから分かるように、この許可、不許可は非同期的に行われます。</simpara>
<programlisting role="executable" language="javascript" linenumbering="unnumbered">Notification.requestPermission((status) =&gt; {
    // statusに"granted" or "denied"が入る
    console.log(status);
});</programlisting>
<simpara>通知を行うまでの流れをまとめると以下のようになります。</simpara>
<itemizedlist>
<listitem>
<simpara>ユーザーに通知の許可を受け付ける非同期処理がある</simpara>
</listitem>
<listitem>
<simpara>許可がある場合は <literal>new Notification</literal> で通知を表示できる</simpara>
<itemizedlist>
<listitem>
<simpara>すでに許可済みのケース</simpara>
</listitem>
<listitem>
<simpara>その場で許可を貰うケース</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>許可がない場合は何もしない</simpara>
</listitem>
</itemizedlist>
<simpara>いくつかのパターンが出ますが、最終的には許可か不許可になるので、以下の2パターンにまとめることができます。</simpara>
<variablelist>
<varlistentry>
<term>許可時("granted")</term>
<listitem>
<simpara><literal>new Notification</literal> で通知を作成</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>不許可時("denied")</term>
<listitem>
<simpara>何もしない</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>この2パターンはどこかで見たことがありますね。
そう、PromiseのFulfilled または Rejected となった時の動作で書くことが出来そうな気がします。</simpara>
<variablelist>
<varlistentry>
<term>resolve(成功)した時 == 許可時("granted")</term>
<listitem>
<simpara><literal>onFulfilled</literal> が呼ばれる</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>reject(失敗)した時 == 不許可時("denied")</term>
<listitem>
<simpara><literal>onRejected</literal>  が呼ばれる</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>Promiseで書けそうな目処が見えた所で、まずはコールバックスタイルで書いてみましょう。</simpara>
</section>
<section xml:id="_web_notification_ラッパー">
<title>Web Notification ラッパー</title>
<simpara>まずは先ほどのWeb Notification APIのラッパー関数をコールバックスタイルで書くと次のように書くことができます。</simpara>
<formalpara xml:id="notification-callback.js" role="executable">
<title>notification-callback.js</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">function notifyMessage(message, options, callback) {
    if (typeof Notification === "undefined") {
        callback(new Error("doesn't support Notification API"));
        return;
    }
    if (Notification.permission === "granted") {
        const notification = new Notification(message, options);
        callback(null, notification);
    } else {
        Notification.requestPermission((status) =&gt; {
            if (Notification.permission !== status) {
                Notification.permission = status;
            }
            if (status === "granted") {
                const notification = new Notification(message, options);
                callback(null, notification);
            } else {
                callback(new Error("user denied"));
            }
        });
    }
}

// 実行例
// 第二引数は `Notification` に渡すオプションオブジェクト
notifyMessage("Hi!", {}, function (error, notification) {
    if(error){
        console.error(error);
        return;
    }
    console.log(notification);// 通知のオブジェクト
});</programlisting>
</para>
</formalpara>
<simpara>コールバックスタイルでは、許可がない場合は <literal>error</literal> に値が入り、
許可がある場合は通知が行われて <literal>notification</literal> に値が入ってくるという感じにしました。</simpara>
<formalpara>
<title>コールバック関数はエラーとnotificationオブジェクトを受け取る</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">function callback(error, notification) {

}</programlisting>
</para>
</formalpara>
<simpara>次に、このコールバックスタイルの関数をPromiseとして使える関数を書いてみたいと思います。</simpara>
<note>
<simpara><link xl:href="https://notifications.spec.whatwg.org/">Notifications API</link>の最新仕様では、
コールバック関数を渡さなかった場合にpromiseオブジェクトを返すようになっています。
そのため、ここから先の話は最新の仕様ではもっとシンプルに書ける可能性があります。</simpara>
<simpara>しかし、古いNotification APIの仕様では、コールバック関数のみしか扱う方法がありませんでした。
ここではコールバック関数のみしか扱えないNotification APIを前提にしています。</simpara>
</note>
</section>
<section xml:id="_web_notification_as_promise">
<title>Web Notification as Promise</title>
<simpara>先ほどのコールバックスタイルの <literal>notifyMessage</literal> とは別に、
promiseオブジェクトを返す <literal>notifyMessageAsPromise</literal> を定義してみます。</simpara>
<formalpara xml:id="notification-as-promise.js" role="executable">
<title>notification-as-promise.js</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">function notifyMessage(message, options, callback) {
    if (typeof Notification === "undefined") {
        callback(new Error("doesn't support Notification API"));
        return;
    }
    if (Notification.permission === "granted") {
        const notification = new Notification(message, options);
        callback(null, notification);
    } else {
        Notification.requestPermission((status) =&gt; {
            if (Notification.permission !== status) {
                Notification.permission = status;
            }
            if (status === "granted") {
                const notification = new Notification(message, options);
                callback(null, notification);
            } else {
                callback(new Error("user denied"));
            }
        });
    }
}
function notifyMessageAsPromise(message, options) {
    return new Promise((resolve, reject) =&gt; {
        notifyMessage(message, options, (error, notification) =&gt; {
            if (error) {
                reject(error);
            } else {
                resolve(notification);
            }
        });
    });
}

// 実行例
notifyMessageAsPromise("Hi!").then(function (notification) {
    console.log(notification);// 通知のオブジェクト
}).catch((error) =&gt; {
    console.error(error);
});</programlisting>
</para>
</formalpara>
<simpara>上記の実行例では、許可がある場合 <literal>"Hi!"</literal> という通知が表示されます。</simpara>
<simpara>許可されている場合は <literal>.then</literal> が呼ばれ、
不許可となった場合は <literal>.catch</literal> が呼ばれます。</simpara>
<note>
<simpara>ブラウザはWeb Notifications APIの状態をサイトごとに許可状態を記憶できるため、
実際には以下の4つのパターンが存在します。</simpara>
<variablelist>
<varlistentry>
<term>すでに許可されている</term>
<listitem>
<simpara><literal>.then</literal> が呼ばれる</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>許可ダイアログがでて許可された</term>
<listitem>
<simpara><literal>.then</literal> が呼ばれる</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>すでに不許可となっている</term>
<listitem>
<simpara><literal>.catch</literal> が呼ばれる</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>許可ダイアログが出て不許可となった</term>
<listitem>
<simpara><literal>.catch</literal> が呼ばれる</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>つまり、Web Notifications APIをそのまま扱うと、4つのパターンについて書かないといけませんが、
それを2パターンにできるラッパーを書くと扱いやすくなります。</simpara>
</note>
<simpara>上記の<xref linkend="notification-as-promise.js"/>は、とても便利そうですが実際に使うときには
<emphasis role="strong">Promiseをサポートしてない環境では使えない</emphasis>という問題があります。</simpara>
<simpara><xref linkend="notification-as-promise.js"/>のようなPromiseスタイルで使えるライブラリを作る場合、
ライブラリ作成者には以下の選択肢があると思います。</simpara>
<variablelist xml:id="promise-library-choice">
<varlistentry>
<term>Promiseが使える環境を前提とする</term>
<listitem>
<itemizedlist>
<listitem>
<simpara>利用者に <literal>Promise</literal> があることを保証してもらう</simpara>
</listitem>
<listitem>
<simpara>Promiseをサポートしてない環境では動かないことにする</simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term>ライブラリ自体に <literal>Promise</literal> の実装を入れてしまう</term>
<listitem>
<itemizedlist>
<listitem>
<simpara>ライブラリ自体にPromiseの実装を取り込む</simpara>
</listitem>
<listitem>
<simpara>例) <link xl:href="https://github.com/mozilla/localForage">localForage</link></simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term>コールバックでも <literal>Promise</literal> でも使えるようにする</term>
<listitem>
<itemizedlist>
<listitem>
<simpara>利用者がどちらを使うかを選択できるようにする</simpara>
</listitem>
<listitem>
<simpara>Thenableを返せるようにする</simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>
<simpara><xref linkend="notification-as-promise.js"/>は <literal>Promise</literal> があることを前提としたような書き方です。</simpara>
<simpara>本題に戻り<link linkend="Thenable">Thenable</link>はここでいう<emphasis role="strong">コールバックでも <literal>Promise</literal> でも使えるようにする</emphasis>ということを
実現するのに役立つ概念です。</simpara>
</section>
<section xml:id="_web_notifications_as_thenable">
<title>Web Notifications As Thenable</title>
<simpara><link linkend="Thenable">thenable</link>というのは <literal>.then</literal> というメソッドを持ってるオブジェクトのことを言いましたね。
次は<xref linkend="notification-callback.js"/>に <literal>thenable</literal> を返すメソッドを追加してみましょう。</simpara>
<formalpara xml:id="notification-thenable.js" role="executable">
<title>notification-thenable.js</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">function notifyMessage(message, options, callback) {
    if (typeof Notification === "undefined") {
        callback(new Error("doesn't support Notification API"));
        return;
    }
    if (Notification.permission === "granted") {
        const notification = new Notification(message, options);
        callback(null, notification);
    } else {
        Notification.requestPermission((status) =&gt; {
            if (Notification.permission !== status) {
                Notification.permission = status;
            }
            if (status === "granted") {
                const notification = new Notification(message, options);
                callback(null, notification);
            } else {
                callback(new Error("user denied"));
            }
        });
    }
}
// `thenable` を返す
function notifyMessageAsThenable(message, options) {
    return {
        "then": function(resolve, reject) {
            notifyMessage(message, options, (error, notification) =&gt; {
                if (error) {
                    reject(error);
                } else {
                    resolve(notification);
                }
            });
        }
    };
}
// 実行例
Promise.resolve(notifyMessageAsThenable("message")).then(function (notification) {
    console.log(notification);// 通知のオブジェクト
}).catch((error) =&gt; {
    console.error(error);
});</programlisting>
</para>
</formalpara>
<simpara><xref linkend="notification-thenable.js"/> には <literal>notifyMessageAsThenable</literal> というそのままのメソッドを追加してみました。
返すオブジェクトには <literal>then</literal> というメソッドがあります。</simpara>
<simpara><literal>then</literal> メソッドの仮引数には <literal>new Promise(function (resolve, reject){})</literal> と同じように、
解決した時に呼ぶ <literal>resolve</literal> と、棄却した時に呼ぶ <literal>reject</literal> が渡ります。</simpara>
<simpara><literal>then</literal> メソッドがやっている中身は<xref linkend="notification-as-promise.js"/>の <literal>notifyMessageAsPromise</literal> と同じですね。</simpara>
<simpara>この <literal>thenable</literal> を <literal>Promise.resolve(thenable)</literal> を使いpromiseオブジェクトにしてから、
Promiseとして利用していることが分かりますね。</simpara>
<programlisting language="javascript" linenumbering="unnumbered">Promise.resolve(notifyMessageAsThenable("message")).then((notification) =&gt; {
    console.log(notification);// 通知のオブジェクト
}).catch((error) =&gt; {
    console.error(error);
});</programlisting>
<simpara>Thenableを使った<xref linkend="notification-thenable.js"/>とPromiseに依存した<xref linkend="notification-as-promise.js"/>は、
非常に似た使い方ができることがわかります。</simpara>
<simpara><xref linkend="notification-thenable.js"/>には<xref linkend="notification-as-promise.js"/>と比べた時に、次のような違いがあります。</simpara>
<itemizedlist>
<listitem>
<simpara>ライブラリ側に <literal>Promise</literal> 実装そのものはでてこない</simpara>
<itemizedlist>
<listitem>
<simpara>利用者が <literal>Promise.resolve(thenable)</literal> を使い <literal>Promise</literal> の実装を与える</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Promiseとして使う時に <literal>Promise.resolve(thenable)</literal> と一枚挟む必要がある</simpara>
</listitem>
</itemizedlist>
<simpara><link linkend="Thenable">Thenable</link>オブジェクトを利用することで、
既存のコールバックスタイルとPromiseスタイルの中間的な実装をすることができました。</simpara>
</section>
<section xml:id="_まとめ_6">
<title>まとめ</title>
<simpara>このセクションではThenableとは何かやThenableを <literal>Promise.resolve(thenable)</literal> を使って、
promiseオブジェクトとして利用する方法について学びました。</simpara>
<simpara>Callback&#8201;&#8212;&#8201;Thenable&#8201;&#8212;&#8201;Promise</simpara>
<simpara>Thenableスタイルは、コールバックスタイルとPromiseスタイルの中間的な表現で、
ライブラリが公開するAPIとしては中途半端なためあまり見かけることがないと思います。</simpara>
<simpara>Thenable自体は <literal>Promise</literal> という機能に依存してはいませんが、Promise以外からの利用方法は特にないため、
間接的にはPromiseに依存しています。</simpara>
<simpara>また、使うためには利用者が <literal>Promise.resolve(thenable)</literal> について理解している必要があるため、
ライブラリの公開APIとしては難しい部分があります。
Thenable自体は公開APIより、内部的に使われてるケースが多いでしょう。</simpara>
<note>
<simpara>非同期処理を行うライブラリを書く際には、まずはコールバックスタイルの関数を書いて公開APIとすることをオススメします。</simpara>
<simpara>Node.jsのCore moduleがこの方法をとっているように、ライブラリが提供するのは基本となるコールバックスタイル関数としたほうが、
利用者がPromiseやGenerator等の好きな方法で実装ができるためです。</simpara>
<simpara>最初からPromiseで利用することを目的としたライブラリや、その機能がPromiseに依存している場合は、
promiseオブジェクトを返す関数を公開APIとしても問題ないと思います。</simpara>
</note>
<section xml:id="_thenableの使われているところ">
<title>Thenableの使われているところ</title>
<simpara>では、どのような場面でThenableは使われてるのでしょうか?</simpara>
<simpara>恐らく、一番多く使われている所は<link linkend="promise-library">Promiseのライブラリ</link>間での相互変換でしょう。</simpara>
<simpara>たとえば、 QライブラリのPromiseのインスタンスであるQ promiseオブジェクトは、
<link linkend="es-promises">ES Promises</link>のpromiseオブジェクトが持っていないメソッドを持っています。
Q promiseオブジェクトには <literal>promise.finally(callback)</literal> や <literal>promise.nodeify(callback)</literal> などのメソッドが用意されてます。</simpara>
<simpara>ES PromisesのpromiseオブジェクトをQ promiseオブジェクトに変換するときに使われるのが、
まさにこのThenableです。</simpara>
<formalpara>
<title>thenableを使ってQ promiseオブジェクトにする</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">const Q = require("Q");
// このpromiseオブジェクトはESのもの
const promise = new Promise((resolve) =&gt; {
    resolve(1);
});
// Q promiseオブジェクトに変換する
Q(promise).then((value) =&gt; {
    console.log(value);
}).finally(() =&gt; { <co xml:id="CO12-1"/>
    console.log("finally");
});</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO12-1">
<para>Q promiseオブジェクトとなったため <literal>finally</literal> が利用できる</para>
</callout>
</calloutlist>
<simpara>最初に作成したpromiseオブジェクトは <literal>then</literal> というメソッドを持っているので、もちろんThenableです。
<literal>Q(thenable)</literal> とすることでThenableなオブジェクトをQ promiseオブジェクトへと変換することができます。</simpara>
<simpara>これは、<literal>Promise.resolve(thenable)</literal> と同じ仕組みといえるので、もちろん逆も可能です。</simpara>
<simpara>このように、Promiseライブラリはそれぞれ独自に拡張したpromiseオブジェクトを持っていますが、
Thenableという共通の概念を使うことでライブラリ間(もちろんネイティブPromiseも含めて)で相互にpromiseオブジェクトを変換することができます。</simpara>
<simpara>このようにThenableが使われる所の多くはライブラリ内部の実装であるため、あまり目にする機会はないかもしれません。
しかしこのThenableはPromiseでも大事な概念であるため知っておくとよいでしょう。</simpara>
</section>
</section>
</section>
<section xml:id="not-throw-use-reject">
<title>throwしないで、rejectしよう</title>
<simpara>Promiseコンストラクタや、<literal>then</literal> で実行される関数は基本的に、
<literal>try&#8230;&#8203;catch</literal> で囲まれてるような状態なので、その中で <literal>throw</literal> してもプログラムは終了しません。</simpara>
<simpara>Promiseの中で <literal>throw</literal> による例外が発生した場合は自動的に <literal>try&#8230;&#8203;catch</literal> され、そのpromiseオブジェクトはRejectedとなります。</simpara>
<programlisting role="executable" language="javascript" linenumbering="unnumbered">const promise = new Promise((resolve, reject) =&gt; {
    throw new Error("message");
});
promise.catch((error) =&gt; {
    console.error(error);// =&gt; "message"
});</programlisting>
<simpara>このように書いても動作的には問題ありませんが、<link linkend="promise-states">promiseオブジェクトの状態</link>をRejectedにしたい場合は
<literal>reject</literal> という与えられた関数を呼び出すのが一般的です。</simpara>
<simpara>先ほどのコードは以下のように書くことができます。</simpara>
<programlisting role="executable" language="javascript" linenumbering="unnumbered">const promise = new Promise((resolve, reject) =&gt; {
    reject(new Error("message"));
});
promise.catch((error) =&gt; {
    console.error(error);// =&gt; "message"
});</programlisting>
<simpara><literal>throw</literal> が <literal>reject</literal> に変わったと考えれば、<literal>reject</literal> にはErrorオブジェクトを渡すべきであるということが分かりやすいかもしれません。</simpara>
<section xml:id="_なぜrejectした方がいいのか">
<title>なぜrejectした方がいいのか</title>
<simpara>そもそも、promiseオブジェクトの状態をRejectedにしたい場合に、
なぜ <literal>throw</literal> ではなく <literal>reject</literal> した方がいいのでしょうか?</simpara>
<simpara>ひとつは <literal>throw</literal> が意図したものか、それとも本当に<emphasis role="strong">例外</emphasis>なのか区別が難しくなってしまうことにあります。</simpara>
<simpara>たとえば、Chrome等の開発者ツールには例外が発生した時に、
デバッガーが自動でbreakする機能が用意されています。</simpara>
<figure>
<title>Pause On Caught Exceptions</title>
<mediaobject>
<imageobject>
<imagedata fileref="Ch4_AdvancedPromises/img/chrome_on_caught_exception.png"/>
</imageobject>
<textobject><phrase>Pause On Caught Exceptions</phrase></textobject>
</mediaobject>
</figure>
<simpara>この機能を有効にしていた場合、以下のように <literal>throw</literal> するとbreakしてしまいます。</simpara>
<programlisting language="javascript" linenumbering="unnumbered">const promise = new Promise((resolve, reject) =&gt; {
    throw new Error("message");
});</programlisting>
<simpara>本来デバッグとは関係ない場所でbreakしてしまうため、
Promiseの中で <literal>throw</literal> している箇所があると、この機能が殆ど使い物にならなくなってしまうでしょう。</simpara>
</section>
<section xml:id="_thenでもrejectする">
<title>thenでもrejectする</title>
<simpara>Promiseコンストラクタの中では <literal>reject</literal> という関数そのものがあるので、
<literal>throw</literal> を使わないでpromiseオブジェクトをRejectedにするのは簡単でした。</simpara>
<simpara>では、次のような <literal>then</literal> の中でrejectしたい場合はどうすればいいでしょうか?</simpara>
<programlisting language="javascript" linenumbering="unnumbered">const promise = Promise.resolve();
promise.then((value) =&gt; {
    setTimeout(() =&gt; {
        // 一定時間経って終わらなかったらrejectしたい - 2
    }, 1000);
    // 時間がかかる処理 - 1
    somethingHardWork();
}).catch((error) =&gt; {
    // タイムアウトエラー - 3
});</programlisting>
<simpara>いわゆるタイムアウト処理ですが、<literal>then</literal> の中で <literal>reject</literal> を呼びたいと思った場合に、
コールバック関数に渡ってくるのは一つ前のpromiseオブジェクトの返した値だけなので困ってしまいます。</simpara>
<note>
<simpara>Promiseを使ったタイムアウト処理の実装については <link linkend="race-delay-timeout">Promise.raceとdelayによるXHRのキャンセル</link> にて詳しく解説しています。</simpara>
</note>
<simpara>ここで少し <literal>then</literal> の挙動について思い出してみましょう。</simpara>
<simpara><literal>then</literal> に登録するコールバック関数では値を <literal>return</literal> することができます。
このときreturnした値が、次の <literal>then</literal> や <literal>catch</literal> のコールバックに渡されます。</simpara>
<simpara>また、returnするものはプリミティブな値に限らずオブジェクト、そしてpromiseオブジェクトも返すことができます。</simpara>
<simpara>このとき、returnしたものがpromiseオブジェクトである場合、そのpromiseオブジェクトの状態によって、
次の <literal>then</literal> に登録されたonFulfilledとonRejectedのうち、どちらが呼ばれるかを決めることができます。</simpara>
<programlisting language="javascript" linenumbering="unnumbered">const promise = Promise.resolve();
promise.then(() =&gt; {
    const retPromise = new Promise((resolve, reject) =&gt; {
        // resolve or reject で onFulfilled or onRejected どちらを呼ぶか決まる
    });
    return retPromise;<co xml:id="CO13-1"/>
}).then(onFulfilled, onRejected);</programlisting>
<calloutlist>
<callout arearefs="CO13-1">
<para>次に呼び出されるthenのコールバックはpromiseオブジェクトの状態によって決定される</para>
</callout>
</calloutlist>
<simpara>つまり、この <literal>retPromise</literal> がRejectedになった場合は、<literal>onRejected</literal> が呼び出されるので、
<literal>throw</literal> を使わなくても <literal>then</literal> の中でrejectすることができます。</simpara>
<programlisting role="executable" language="javascript" linenumbering="unnumbered">const onRejected = console.error.bind(console);
const promise = Promise.resolve();
promise.then(() =&gt; {
    const retPromise = new Promise((resolve, reject) =&gt; {
        reject(new Error("this promise is rejected"));
    });
    return retPromise;
}).catch(onRejected);</programlisting>
<simpara>これは、<xref linkend="Promise.reject"/> を使うことでもっと簡潔に書くことができます。</simpara>
<programlisting role="executable" language="javascript" linenumbering="unnumbered">const onRejected = console.error.bind(console);
const promise = Promise.resolve();
promise.then(() =&gt; {
    return Promise.reject(new Error("this promise is rejected"));
}).catch(onRejected);</programlisting>
</section>
<section xml:id="_まとめ_7">
<title>まとめ</title>
<simpara>このセクションでは、以下のことについて学びました。</simpara>
<itemizedlist>
<listitem>
<simpara><literal>throw</literal> ではなくて <literal>reject</literal> した方が安全</simpara>
</listitem>
<listitem>
<simpara><literal>then</literal> の中でも <literal>reject</literal> する方法</simpara>
</listitem>
</itemizedlist>
<simpara>中々使いどころが多くはないかもしれませんが、安易に <literal>throw</literal> してしまうよりはいいことが多いので、
覚えておくといいでしょう。</simpara>
<simpara>これを利用した具体的な例としては、
<link linkend="race-delay-timeout">Promise.raceとdelayによるXHRのキャンセル</link> で解説しています。</simpara>
</section>
</section>
<section xml:id="deferred-and-promise">
<title>DeferredとPromise</title>
<simpara>このセクションではDeferredとPromiseの関係について簡潔に学んでいきます。</simpara>
<section xml:id="_deferredとは何か">
<title>Deferredとは何か</title>
<simpara>Deferredという単語はPromiseと同じコンテキストで聞いたことがあるかもしれません。
有名な所だと <link xl:href="http://api.jquery.com/category/deferred-object/">jQuery.Deferred</link> や <link xl:href="http://cho45.stfuawsc.com/jsdeferred/">JSDeferred</link> 等があげられるでしょう。</simpara>
<simpara>DeferredはPromiseと違い、共通の仕様があるわけではなく、各ライブラリがそのような目的の実装をそう呼んでいます。</simpara>
<simpara>今回は <link xl:href="http://api.jquery.com/category/deferred-object/">jQuery.Deferred</link> のようなDeferredの実装を中心にして話を進めます。</simpara>
</section>
<section xml:id="_deferredとpromiseの関係">
<title>DeferredとPromiseの関係</title>
<simpara>DeferredとPromiseの関係を簡単に書くと以下のようになります。</simpara>
<itemizedlist>
<listitem>
<simpara>Deferred は Promiseを持っている</simpara>
</listitem>
<listitem>
<simpara>Deferred は Promiseの状態を操作する特権的なメソッドを持っている</simpara>
</listitem>
</itemizedlist>
<figure>
<title>DeferredとPromise</title>
<mediaobject>
<imageobject>
<imagedata fileref="Ch4_AdvancedPromises/img/deferred-and-promise.png"/>
</imageobject>
<textobject><phrase>DeferredとPromise</phrase></textobject>
</mediaobject>
</figure>
<simpara>この図を見ると分かりますが、DeferredとPromiseは比べるような関係ではなく、
DeferredがPromiseを内蔵しているような関係になっていることが分かります。</simpara>
<note>
<simpara>jQuery.Deferredの構造を簡略化したものです。Promiseを使わないDeferredの実装もあります。</simpara>
</note>
<simpara>図だけだと分かりにくいので、実際にPromiseを使ってDeferredクラスを実装してみましょう。</simpara>
<note>
<simpara>ECMAScript 2015ではクラスを定義する <literal>class</literal> 構文が導入されています。
<literal>class</literal> 構文を使ったクラス定義については、次のページを参照してください。</simpara>
<itemizedlist>
<listitem>
<simpara><link xl:href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Classes">クラス - JavaScript | MDN</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://jsprimer.net/basic/class/">クラス · JavaScript Primer #jsprimer</link></simpara>
</listitem>
</itemizedlist>
</note>
</section>
<section xml:id="_deferred_top_on_promise">
<title>Deferred top on Promise</title>
<simpara>Promiseの上にDeferredクラスを実装した例です。</simpara>
<formalpara xml:id="deferred.js">
<title>deferred.js</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">class Deferred {
    constructor() {
        this.promise = new Promise((resolve, reject) =&gt; {
            // Arrow Functionを利用しているため、`this`がDeferredのインスタンスを参照する
            this._resolve = resolve;
            this._reject = reject;
        });
    }

    // Deferred#resolveメソッドは、`value`でPromiseインスタンスをresolveする
    resolve(value) {
        this._resolve(value);
    }

    // Deferred#rejectメソッドは、`reason`でPromiseインスタンスをrejectする
    reject(reason) {
        this._reject(reason);
    }
}</programlisting>
</para>
</formalpara>
<simpara>以前Promiseを使って実装した<link linkend="xhr-promise.js"><literal>fetchURL</literal></link>をこのDeferredで実装しなおしてみます。</simpara>
<formalpara xml:id="xhr-deferred.js" role="executable">
<title>xhr-deferred.js</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">class Deferred {
    constructor() {
        this.promise = new Promise((resolve, reject) =&gt; {
            // Arrow Functionを利用しているため、`this`がDeferredのインスタンスを参照する
            this._resolve = resolve;
            this._reject = reject;
        });
    }

    // Deferred#resolveメソッドは、`value`でPromiseインスタンスをresolveする
    resolve(value) {
        this._resolve(value);
    }

    // Deferred#rejectメソッドは、`reason`でPromiseインスタンスをrejectする
    reject(reason) {
        this._reject(reason);
    }
}
function fetchURL(URL) {
    const deferred = new Deferred();
    const req = new XMLHttpRequest();
    req.open("GET", URL, true);
    req.onload = () =&gt; {
        if (200 &lt;= req.status &amp;&amp; req.status &lt; 300) {
            deferred.resolve(req.responseText);
        } else {
            deferred.reject(new Error(req.statusText));
        }
    };
    req.onerror = () =&gt; {
        deferred.reject(new Error(req.statusText));
    };
    req.send();
    return deferred.promise;
}

// 実行例
const URL = "https://httpbin.org/get";
fetchURL(URL).then(function onFulfilled(value){
    console.log(value);
}).catch(console.error.bind(console));</programlisting>
</para>
</formalpara>
<simpara>Promiseの状態を操作する特権的なメソッドというのは、
promiseオブジェクトの状態をresolve、rejectすることができるメソッドで、
通常のPromiseだとコンストラクタで渡した関数の中でしか操作することができません。</simpara>
<simpara>通常のPromiseで実装したものと見比べていきたいと思います。</simpara>
<formalpara role="executable">
<title>xhr-promise.js</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">function fetchURL(URL) {
    return new Promise((resolve, reject) =&gt; {
        const req = new XMLHttpRequest();
        req.open("GET", URL, true);
        req.onload = () =&gt; {
            if (200 &lt;= req.status &amp;&amp; req.status &lt; 300) {
                resolve(req.responseText);
            } else {
                reject(new Error(req.statusText));
            }
        };
        req.onerror = () =&gt; {
            reject(new Error(req.statusText));
        };
        req.send();
    });
}

// 実行例
const URL = "https://httpbin.org/get";
fetchURL(URL).then(function onFulfilled(value){
    console.log(value);
}).catch(console.error.bind(console));</programlisting>
</para>
</formalpara>
<simpara>2つの <literal>fetchURL</literal> を見比べて見ると以下のような違いがあることが分かります。</simpara>
<itemizedlist>
<listitem>
<simpara>Deferred の場合は全体がPromiseで囲まれていない</simpara>
<itemizedlist>
<listitem>
<simpara>関数で囲んでないため、1段ネストが減っている</simpara>
</listitem>
<listitem>
<simpara>Promiseコンストラクタの中で処理が行われていないため、自動的に例外をキャッチしない</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<simpara>逆に以下の部分は同じことをやっています。</simpara>
<itemizedlist>
<listitem>
<simpara>全体的な処理の流れ</simpara>
<itemizedlist>
<listitem>
<simpara><literal>resolve</literal>、<literal>reject</literal> を呼ぶタイミング</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>関数はpromiseオブジェクトを返す</simpara>
</listitem>
</itemizedlist>
<simpara>このDeferredはPromiseを持っているため、大きな流れは同じですが、
Deferredには特権的なメソッドを持っていることや自分で流れを制御する裁量が大きいことが分かります。</simpara>
<simpara>たとえば、Promiseの場合はコンストラクタの中に処理を書くことが通例なので、
<literal>resolve</literal>、<literal>reject</literal> を呼ぶタイミングが大体みて分かります。</simpara>
<programlisting language="javascript" linenumbering="unnumbered">new Promise((resolve, reject) =&gt; {
    // この中に解決する処理を書く
});</programlisting>
<simpara>一方Deferredの場合は、関数的なまとまりはないのでdeferredオブジェクトを作ったところから、
任意のタイミングで <literal>resolve</literal>、<literal>reject</literal> を呼ぶ感じになります。</simpara>
<programlisting language="javascript" linenumbering="unnumbered">const deferred = new Deferred();

// どこかのタイミングでdeferred.resolve or deferred.rejectを呼ぶ</programlisting>
<simpara>このように小さな<emphasis role="strong">Deferred</emphasis>の実装ですが<emphasis role="strong">Promise</emphasis>との違いが出ていることが分かります。</simpara>
<simpara>これは、Promiseが値を抽象化したオブジェクトなのに対して、
Deferredはまだ処理が終わってないという状態や操作を抽象化したオブジェクトである違いがでているのかもしれません。</simpara>
<simpara>言い換えると、
Promiseはこの値は将来的に正常な値(Fulfilled)か異常な値(Rejected)が入るというものを予約したオブジェクトなのに対して、
Deferredはまだ処理が終わってないということを表すオブジェクトで、
処理が終わった時の結果を取得する機構(Promise)に加えて処理を進める機構をもったものといえるかもしれません。</simpara>
<simpara>より詳しくDeferredについて知りたい人は以下を参照するといいでしょう。</simpara>
<itemizedlist>
<listitem>
<simpara><link xl:href="http://blog.mediumequalsmessage.com/promise-deferred-objects-in-javascript-pt1-theory-and-semantics">Promise &amp; Deferred objects in JavaScript Pt.1: Theory and Semantics.</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="http://skitazaki.appspot.com/translation/twisted-intro-ja/index.html">Twisted 入門 — Twisted Intro</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://github.com/petkaantonov/bluebird/wiki/Promise-anti-patterns#the-deferred-anti-pattern">Promise anti patterns · petkaantonov/bluebird Wiki</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://github.com/kriskowal/q/wiki/Coming-from-jQuery">Coming from jQuery · kriskowal/q Wiki</link></simpara>
</listitem>
</itemizedlist>
<note>
<simpara>DeferredはPythonの <link xl:href="https://twistedmatrix.com/trac/">Twisted</link> というフレームワークが最初に定義した概念です。
JavaScriptへは <link xl:href="http://mochi.github.io/mochikit/doc/html/MochiKit/Async.html">MochiKit.Async</link> 、 <link xl:href="http://dojotoolkit.org/reference-guide/1.9/dojo/Deferred.html">dojo/Deferred</link> 等のライブラリがその概念を持ってきたと言われています。</simpara>
</note>
</section>
</section>
<section xml:id="race-delay-timeout">
<title>Promise.raceとdelayによるXHRのキャンセル</title>
<simpara>このセクションでは<link linkend="ch2-promise-race">2章</link>で紹介した<link linkend="Promise.race"><literal>Promise.race</literal></link>のユースケースとして、
Promise.raceを使ったタイムアウトの実装を学んでいきます。</simpara>
<simpara>もちろんXHRは <link xl:href="https://developer.mozilla.org/ja/docs/XMLHttpRequest/Synchronous_and_Asynchronous_Requests">timeout</link> プロパティを持っているので、
これを利用すると簡単にできますが、複数のXHRを束ねたタイムアウトや他の機能でも応用が効くため、
分かりやすい非同期処理であるXHRにおけるタイムアウトによるキャンセルを例にしています。</simpara>
<section xml:id="_promiseで一定時間待つ">
<title>Promiseで一定時間待つ</title>
<simpara>まずはタイムアウトをPromiseでどう実現するかを見ていきたいと思います。</simpara>
<simpara>タイムアウトというのは一定時間経ったら何かするという処理なので、<literal>setTimeout</literal> を使えばいいことが分かりますね。</simpara>
<simpara>まずは単純に <literal>setTimeout</literal> をPromiseでラップした関数を作ってみましょう。</simpara>
<formalpara xml:id="delayPromise.js">
<title>delayPromise.js</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">function delayPromise(ms) {
    return new Promise((resolve) =&gt; {
        setTimeout(resolve, ms);
    });
}</programlisting>
</para>
</formalpara>
<simpara><literal>delayPromise(ms)</literal> は引数で指定したミリ秒後にonFulfilledを呼ぶpromiseオブジェクトを返すので、
通常の <literal>setTimeout</literal> を直接使ったものと比較すると以下のように書けるだけの違いです。</simpara>
<programlisting language="javascript" linenumbering="unnumbered">setTimeout(() =&gt; {
    alert("100ms 経ったよ!");
}, 100);
// == ほぼ同様の動作
delayPromise(100).then(() =&gt; {
    alert("100ms 経ったよ!");
});</programlisting>
<simpara>ここでは<emphasis role="strong">promiseオブジェクト</emphasis>であるということが重要になってくるので覚えておいて下さい。</simpara>
</section>
<section xml:id="_promise_raceでタイムアウト">
<title>Promise.raceでタイムアウト</title>
<simpara><literal>Promise.race</literal> について簡単に振り返ると、
以下のようにどれか一つでもpromiseオブジェクトが解決状態になったら次の処理を実行する静的メソッドでした。</simpara>
<programlisting language="javascript" linenumbering="unnumbered">const winnerPromise = new Promise((resolve) =&gt; {
    setTimeout(() =&gt; {
        console.log("this is winner");
        resolve("this is winner");
    }, 4);
});
const loserPromise = new Promise((resolve) =&gt; {
    setTimeout(() =&gt; {
        console.log("this is loser");
        resolve("this is loser");
    }, 1000);
});

// 一番最初のものがresolveされた時点で終了
Promise.race([winnerPromise, loserPromise]).then((value) =&gt; {
    console.log(value); // =&gt; 'this is winner'
});</programlisting>
<simpara>先ほどの<link linkend="delayPromise.js">delayPromise</link>と別のpromiseオブジェクトを、
<literal>Promise.race</literal> によって競争させることで簡単にタイムアウトが実装できます。</simpara>
<formalpara xml:id="simple-timeout-promise.js">
<title>simple-timeout-promise.js</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">function delayPromise(ms) {
    return new Promise((resolve) =&gt; {
        setTimeout(resolve, ms);
    });
}
function timeoutPromise(promise, ms) {
    const timeout = delayPromise(ms).then(() =&gt; {
        throw new Error("Operation timed out after " + ms + " ms");
    });
    return Promise.race([promise, timeout]);
}</programlisting>
</para>
</formalpara>
<simpara><literal>timeoutPromise(比較対象のpromise, ms)</literal> はタイムアウト処理を入れたい
promiseオブジェクトとタイムアウトの時間を受け取り、<literal>Promise.race</literal> により競争させたpromiseオブジェクトを返します。</simpara>
<simpara><literal>timeoutPromise</literal> を使うことで以下のようにタイムアウト処理を書くことができるようになります。</simpara>
<programlisting role="executable" language="javascript" linenumbering="unnumbered">function delayPromise(ms) {
    return new Promise((resolve) =&gt; {
        setTimeout(resolve, ms);
    });
}
function timeoutPromise(promise, ms) {
    const timeout = delayPromise(ms).then(() =&gt; {
        throw new Error("Operation timed out after " + ms + " ms");
    });
    return Promise.race([promise, timeout]);
}

// 実行例
var taskPromise = new Promise(function(resolve){
    // 何らかの処理
    var delay = Math.random() * 2000;
    setTimeout(function(){
        resolve(delay + "ms");
    }, delay);
});
timeoutPromise(taskPromise, 1000).then(function(value){
    console.log("taskPromiseが時間内に終わった : " + value);
}).catch((error) =&gt; {
    console.log("タイムアウトになってしまった", error);
});</programlisting>
<simpara>タイムアウトになった場合はエラーが呼ばれるようにできましたが、
このままでは<emphasis>通常のエラー</emphasis>と<emphasis>タイムアウトのエラー</emphasis>の区別がつかなくなってしまいます。</simpara>
<simpara>この <literal>Error</literal> オブジェクトの区別をしやすくするため、
<literal>Error</literal> オブジェクトのサブクラスとして <literal>TimeoutError</literal> を定義したいと思います。</simpara>
</section>
<section xml:id="_カスタムerrorオブジェクト">
<title>カスタムErrorオブジェクト</title>
<simpara><literal>Error</literal> オブジェクトはECMAScriptのビルトインオブジェクトです。</simpara>
<simpara>ECMAScript5では完璧に <literal>Error</literal> を継承したものを作ることは不可能ですが(スタックトレース周り等)、
今回は通常のErrorとは区別を付けたいという目的なので、それを満たせる <literal>TimeoutError</literal> オブジェクトを作成します。</simpara>
<note>
<simpara>ECMAScript 2015から <literal>class</literal> 構文を使うことで内部的にも正確に継承を行うことができます。</simpara>
<programlisting language="javascript" linenumbering="unnumbered">class MyError extends Error {
    // Errorを継承したオブジェクト
}</programlisting>
</note>
<simpara><literal>error instanceof TimeoutError</literal> というように利用できる <literal>TimeoutError</literal> を定義すると
以下のようになります。</simpara>
<formalpara xml:id="TimeoutError.js">
<title>TimeoutError.js</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">function copyOwnFrom(target, source) {
    Object.getOwnPropertyNames(source).forEach((propName) =&gt; {
        Object.defineProperty(target, propName,
            Object.getOwnPropertyDescriptor(source, propName));
    });
    return target;
}
function TimeoutError() {
    const superInstance = Error.apply(null, arguments);
    copyOwnFrom(this, superInstance);
}
TimeoutError.prototype = Object.create(Error.prototype);
TimeoutError.prototype.constructor = TimeoutError;</programlisting>
</para>
</formalpara>
<simpara><literal>TimeoutError</literal> というコンストラクタ関数を定義して、このコンストラクタにErrorをprototype継承させています。</simpara>
<simpara>使い方は通常の <literal>Error</literal> オブジェクトと同じで以下のように <literal>throw</literal> するなどして利用できます。</simpara>
<programlisting language="javascript" linenumbering="unnumbered">const promise = new Promise(() =&gt; {
    throw new TimeoutError("timeout");
});

promise.catch((error) =&gt; {
    console.log(error instanceof TimeoutError);// true
});</programlisting>
<simpara>この <literal>TimeoutError</literal> を使えば、タイムアウトによるErrorオブジェクトなのか、他の原因のErrorオブジェクトなのかが容易に判定できるようになります。</simpara>
<note>
<simpara>今回紹介したビルトインオブジェクトを継承したオブジェクトの作成方法については
<link xl:href="http://speakingjs.com/es5/ch28.html">Chapter 28. Subclassing Built-ins</link> で詳しく紹介されています。
また、 <link xl:href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error">Error - JavaScript | MDN</link> にもErrorオブジェクトについて書かれています。</simpara>
</note>
</section>
<section xml:id="_タイムアウトによるxhrのキャンセル">
<title>タイムアウトによるXHRのキャンセル</title>
<simpara>ここまでくれば、どのようにPromiseを使ったXHRのキャンセルを実装するか見えてくるかもしれません。</simpara>
<simpara>XHRのキャンセル自体は <literal>XMLHttpRequest</literal> オブジェクトの <literal>abort()</literal> メソッドを呼ぶだけなので難しくないですね。</simpara>
<simpara><literal>abort()</literal> メソッドを外から呼べるようにするために、今までのセクションにもでてきた<link linkend="xhr-promise.js"><literal>fetchURL</literal></link>を少し拡張して、
XHRを包んだpromiseオブジェクトと共にそのXHRを中止するメソッドをもつオブジェクトを返すようにしています。</simpara>
<formalpara xml:id="delay-race-cancel.js">
<title>delay-race-cancel.js</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">function cancelableXHR(URL) {
    const req = new XMLHttpRequest();
    const promise = new Promise((resolve, reject) =&gt; {
        req.open("GET", URL, true);
        req.onload = () =&gt; {
            if (200 &lt;= req.status &amp;&amp; req.status &lt; 300) {
                resolve(req.responseText);
            } else {
                reject(new Error(req.statusText));
            }
        };
        req.onerror = () =&gt; {
            reject(new Error(req.statusText));
        };
        req.onabort = function() {
            reject(new Error("this request is aborted"));
        };
        req.send();
    });
    const abort = function() {
        // 既にrequestが止まってなければabortする
        // https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest
        if (req.readyState !== XMLHttpRequest.UNSENT) {
            req.abort();
        }
    };
    return {
        promise: promise,
        abort: abort
    };
}</programlisting>
</para>
</formalpara>
<simpara>これで必要な要素は揃ったので後は、Promiseを使った処理のフローに並べていくだけです。
大まかな流れとしては以下のようになります。</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara><literal>cancelableXHR</literal> を使いXHRのpromiseオブジェクトと中止を呼び出すメソッドを取得する</simpara>
</listitem>
<listitem>
<simpara><literal>timeoutPromise</literal> を使いXHRのpromiseとタイムアウト用のpromiseを <literal>Promise.race</literal> で競争させる</simpara>
<itemizedlist>
<listitem>
<simpara>XHRが時間内に取得できた場合</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>通常のpromiseと同様に <literal>then</literal> で中身を取得する</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>タイムアウトとなった場合は</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara><literal>throw new TimeoutError</literal> されるので <literal>catch</literal> する</simpara>
</listitem>
<listitem>
<simpara>catchしたエラーオブジェクトが <literal>TimeoutError</literal> のものだったら <literal>abort</literal> を呼び出してXHRをキャンセルする</simpara>
</listitem>
</orderedlist>
</listitem>
</itemizedlist>
</listitem>
</orderedlist>
<simpara>これらの要素を全てまとめると次のように書けます。</simpara>
<formalpara xml:id="delay-race-cancel-play.js" role="executable">
<title>delay-race-cancel-play.js</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">function copyOwnFrom(target, source) {
    Object.getOwnPropertyNames(source).forEach((propName) =&gt; {
        Object.defineProperty(target, propName,
            Object.getOwnPropertyDescriptor(source, propName));
    });
    return target;
}
function TimeoutError() {
    const superInstance = Error.apply(null, arguments);
    copyOwnFrom(this, superInstance);
}
TimeoutError.prototype = Object.create(Error.prototype);
TimeoutError.prototype.constructor = TimeoutError;
function delayPromise(ms) {
    return new Promise((resolve) =&gt; {
        setTimeout(resolve, ms);
    });
}
function timeoutPromise(promise, ms) {
    const timeout = delayPromise(ms).then(() =&gt; {
        return Promise.reject(new TimeoutError("Operation timed out after " + ms + " ms"));
    });
    return Promise.race([promise, timeout]);
}

function cancelableXHR(URL) {
    const req = new XMLHttpRequest();
    const promise = new Promise((resolve, reject) =&gt; {
        req.open("GET", URL, true);
        req.onload = () =&gt; {
            if (200 &lt;= req.status &amp;&amp; req.status &lt; 300) {
                resolve(req.responseText);
            } else {
                reject(new Error(req.statusText));
            }
        };
        req.onerror = () =&gt; {
            reject(new Error(req.statusText));
        };
        req.onabort = function() {
            reject(new Error("this request is aborted"));
        };
        req.send();
    });
    const abort = function() {
        // 既にrequestが止まってなければabortする
        // https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest
        if (req.readyState !== XMLHttpRequest.UNSENT) {
            req.abort();
        }
    };
    return {
        promise: promise,
        abort: abort
    };
}
const object = cancelableXHR("https://httpbin.org/get");
// main
timeoutPromise(object.promise, 1000)
    .then((contents) =&gt; {
        console.log("Contents", contents);
    }).
    catch((error) =&gt; {
        if (error instanceof TimeoutError) {
            object.abort();
            console.error(error);
            return;
        }
        console.log("XHR Error :", error);
    });</programlisting>
</para>
</formalpara>
<simpara>これで、一定時間後に解決されるpromiseオブジェクトを使ったタイムアウト処理が実現できました。</simpara>
<note>
<simpara>通常の開発の場合は繰り返し使えるように、それぞれファイルに分割して定義しておくといいですね。</simpara>
</note>
</section>
<section xml:id="_promiseと操作メソッド">
<title>promiseと操作メソッド</title>
<simpara>先ほどの<link linkend="delay-race-cancel.js"><literal>cancelableXHR</literal></link>はpromiseオブジェクトと操作のメソッドが
一緒になったオブジェクトを返すようにしていたため少し分かりにくかったかもしれません。</simpara>
<simpara>一つの関数は一つの値(promiseオブジェクト)を返すほうが見通しがいいと思いますが、
<literal>cancelableXHR</literal> の中で生成した <literal>req</literal> は外から参照できないので、特定のメソッド(先ほどのケースは <literal>abort</literal>)からは触れるようにする必要があります。</simpara>
<simpara>返すpromiseオブジェクト自体を拡張して <literal>abort</literal> できるようにするという手段もあると思いますが、
promiseオブジェクトは値を抽象化したオブジェクトであるため、何でも操作用のメソッドをつけていくと複雑になってしまうかもしれません。</simpara>
<simpara>一つの関数で全てやろうとしてるのがそもそも良くないので、
以下のように関数に分離していくというのが妥当な気がします。</simpara>
<itemizedlist>
<listitem>
<simpara>XHRを行うpromiseオブジェクトを返す</simpara>
</listitem>
<listitem>
<simpara>promiseオブジェクトを渡したら該当するXHRを止める</simpara>
</listitem>
</itemizedlist>
<simpara>これらの処理をまとめたモジュールを作れば今後の拡張がしやすいですし、
一つの関数がやることも小さくて済むので見通しも良くなると思います。</simpara>
<simpara>モジュールの作り方は色々作法(AMD,CommonJS,ES module etc..)があるので
ここでは、先ほどの <literal>cancelableXHR</literal> をNode.jsのモジュールとして作りなおしてみます。</simpara>
<formalpara xml:id="cancelableXHR.js">
<title>cancelableXHR.js</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">"use strict";
const requestMap = {};
function createXHRPromise(URL) {
    const req = new XMLHttpRequest();
    const promise = new Promise((resolve, reject) =&gt; {
        req.open("GET", URL, true);
        req.onreadystatechange = function() {
            if (req.readyState === XMLHttpRequest.DONE) {
                delete requestMap[URL];
            }
        };
        req.onload = () =&gt; {
            if (200 &lt;= req.status &amp;&amp; req.status &lt; 300) {
                resolve(req.responseText);
            } else {
                reject(new Error(req.statusText));
            }
        };
        req.onerror = () =&gt; {
            reject(new Error(req.statusText));
        };
        req.onabort = () =&gt; {
            reject(new Error("abort this req"));
        };
        req.send();
    });
    requestMap[URL] = {
        promise: promise,
        request: req
    };
    return promise;
}

function abortPromise(promise) {
    if (typeof promise === "undefined") {
        return;
    }
    let request;
    Object.keys(requestMap).some((URL) =&gt; {
        if (requestMap[URL].promise === promise) {
            request = requestMap[URL].request;
            return true;
        }
    });
    if (request != null &amp;&amp; request.readyState !== XMLHttpRequest.UNSENT) {
        request.abort();
    }
}
module.exports.createXHRPromise = createXHRPromise;
module.exports.abortPromise = abortPromise;</programlisting>
</para>
</formalpara>
<simpara>使い方もシンプルに <literal>createXHRPromise</literal> でXHRのpromiseオブジェクトを作成して、
そのXHRを <literal>abort</literal> したい場合は <literal>abortPromise(promise)</literal> にpromiseオブジェクトを渡すという感じで利用できるようになります。</simpara>
<programlisting language="javascript" linenumbering="unnumbered">const cancelableXHR = require("./cancelableXHR");

const xhrPromise = cancelableXHR.createXHRPromise("https://httpbin.org/get");<co xml:id="CO14-1"/>
xhrPromise.catch((error) =&gt; {
    // abort されたエラーが呼ばれる
});
cancelableXHR.abortPromise(xhrPromise);<co xml:id="CO14-2"/></programlisting>
<calloutlist>
<callout arearefs="CO14-1">
<para>XHRをラップしたpromiseオブジェクトを作成</para>
</callout>
<callout arearefs="CO14-2">
<para>1で作成したpromiseオブジェクトのリクエストをキャンセル</para>
</callout>
</calloutlist>
</section>
<section xml:id="_まとめ_8">
<title>まとめ</title>
<simpara>ここでは以下のことについて学びました。</simpara>
<itemizedlist>
<listitem>
<simpara>一定時間後に解決されるdelayPromise</simpara>
</listitem>
<listitem>
<simpara>delayPromiseとPromise.raceを使ったタイムアウトの実装</simpara>
</listitem>
<listitem>
<simpara>XHRのpromiseのリクエストのキャンセル</simpara>
</listitem>
<listitem>
<simpara>モジュール化によるpromiseオブジェクトと操作の分離</simpara>
</listitem>
</itemizedlist>
<simpara>Promiseは処理のフローを制御する力に優れているため、
それを最大限活かすためには一つの関数でやり過ぎないで処理を小さく分けること等、
今までのJavaScriptで言われているようなことをより意識していいのかもしれません。</simpara>
<note>
<title>Fetch APIでのキャンセル</title>
<simpara>XHRの現代的なバージョンである <link xl:href="https://developer.mozilla.org/ja/docs/Web/API/Fetch_API">Fetch API</link> では、 <link xl:href="https://developer.mozilla.org/en-US/docs/Web/API/AbortController">AbortController</link> というAPIによってリクエストをキャンセルを実現できます。</simpara>
<simpara>Fetch APIでは、次のようにリクエストをキャンセルできます。</simpara>
<formalpara role="executable">
<title>AbortControllerでのFetchのキャンセル</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">// AbortControllerのインスタンスの作成
const controller = new AbortController()
// キャンセルを通知するための siganl を取得する
const signal = controller.signal
// signal をfetchメソッドの第二引数に渡す
fetch("https://httpbin.org/get", { signal })
.then((result) =&gt; {
    // 結果の正常処理
    console.log(result);
})
.catch((error) =&gt; {
    if (error.name == "AbortError") {
        // 中断の場合の処理
        console.error("Fetchが中断されました", error);
        return;
    }
    // 中断以外のエラー
    console.error(err);
})
// Fetchをキャンセルする
controller.abort();</programlisting>
</para>
</formalpara>
<simpara><literal>AbortController</literal>という今回実装したものと似たような操作メソッドをもつオブジェクトを利用することがわかります。</simpara>
</note>
</section>
</section>
<section xml:id="promise-done">
<title>Promise.prototype.done とは何か?</title>
<simpara>既存のPromise実装ライブラリを利用したことがある人は、
<literal>then</literal> の代わりに使う <literal>done</literal> というメソッドを見たことがあるかもしれません。</simpara>
<simpara>それらのライブラリでは <literal>Promise.prototype.done</literal> というような実装が存在し、
使い方は <literal>then</literal> と同じですが、promiseオブジェクトを返さないようになっています。</simpara>
<simpara><literal>Promise.prototype.done</literal> は、<link linkend="es-promises">ES Promises</link>や<link linkend="promises-aplus">Promises/A+</link>の仕様には
存在していない記述ですが、多くのライブラリが実装しています。</simpara>
<simpara>このセクションでは、<literal>Promise.prototype.done</literal> とは何か?
またなぜこのようなメソッドが多くのライブラリで実装されているかについて学んでいきましょう。</simpara>
<section xml:id="_doneを使ったコード例">
<title>doneを使ったコード例</title>
<simpara>実際にdoneを使ったコードを見てみると <literal>done</literal> の挙動が分かりやすいと思います。</simpara>
<formalpara xml:id="promise-done-example.js" role="executable">
<title>promise-done-example.js</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">if (typeof Promise.prototype.done === "undefined") {
    Promise.prototype.done = function(onFulfilled, onRejected) {
        this.then(onFulfilled, onRejected).catch((error) =&gt; {
            setTimeout(() =&gt; {
                throw error;
            }, 0);
        });
    };
}
const promise = Promise.resolve();
promise.done(() =&gt; {
    JSON.parse("this is not json");
    // =&gt; SyntaxError: JSON.parse
});
// =&gt; ブラウザの開発ツールのコンソールを開いてみましょう</programlisting>
</para>
</formalpara>
<simpara>最初に述べたように、<literal>Promise.prototype.done</literal> は仕様としては存在しないため、
利用する際は実装されているライブラリを使うか自分で実装する必要があります。</simpara>
<simpara>実装については後で解説しますが、まずは <literal>then</literal> を使った場合と <literal>done</literal> を使ったものを比較してみます。</simpara>
<formalpara role="executable">
<title>thenを使った場合</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">const promise = Promise.resolve();
promise.then(() =&gt; {
    JSON.parse("this is not json");
}).catch((error) =&gt; {
    console.error(error);// =&gt; "SyntaxError: JSON.parse"
});</programlisting>
</para>
</formalpara>
<simpara>比べて見ると以下のような違いがあることが分かります。</simpara>
<itemizedlist>
<listitem>
<simpara><literal>done</literal> はpromiseオブジェクトを返さない</simpara>
<itemizedlist>
<listitem>
<simpara>つまり、doneの後に <literal>catch</literal> 等のメソッドチェーンはできない</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara><literal>done</literal> の中で発生したエラーはそのまま外に例外として投げられる</simpara>
<itemizedlist>
<listitem>
<simpara>つまり、Promiseによるエラーハンドリングが行われない</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<simpara><literal>done</literal> はpromiseオブジェクトを返していないので、
Promise chainの最後におくメソッドというのは分かると思います。</simpara>
<simpara>また、Promiseには強力なエラーハンドリング機能があると紹介していましたが、
<literal>done</literal> の中ではそのエラーハンドリングをワザと突き抜けて例外を出すようになっています。</simpara>
<simpara>なぜこのようなPromiseの機能とは相反するメソッドが、多くのライブラリで実装されているかについては
次のようなPromiseの失敗例を見ていくと分かるかもしれません。</simpara>
</section>
<section xml:id="_沈黙したエラー">
<title>沈黙したエラー</title>
<simpara>Promiseには強力なエラーハンドリング機能がありますが、
(デバッグツールが上手く働かない場合に)
この機能がヒューマンエラーをより複雑なものにしてしまう一面があります。</simpara>
<simpara>これは、<link linkend="then-or-catch">then or catch?</link>でも同様の内容が出てきたことを覚えているかもしれません。</simpara>
<simpara>次のような、promiseオブジェクトを返す関数を考えてみましょう。</simpara>
<formalpara xml:id="json-promise.js">
<title>json-promise.js</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">function JSONPromise(value) {
    return new Promise((resolve) =&gt; {
        resolve(JSON.parse(value));
    });
}</programlisting>
</para>
</formalpara>
<simpara>渡された値を <literal>JSON.parse</literal> してpromiseオブジェクトを返す関数ですね。</simpara>
<simpara>以下のように使うことができ、<literal>JSON.parse</literal> はパースに失敗すると例外を投げるので、
それを <literal>catch</literal> することができます。</simpara>
<programlisting role="executable" language="javascript" linenumbering="unnumbered">function JSONPromise(value) {
    return new Promise((resolve) =&gt; {
        resolve(JSON.parse(value));
    });
}

// 実行例
var string = "jsonではない文字列";
JSONPromise(string).then(function (object) {
    console.log(object);
}).catch((error) =&gt; {
    // =&gt; JSON.parseで例外が発生した時
    console.error(error);
});</programlisting>
<simpara>ちゃんと <literal>catch</literal> していれば何も問題がないのですが、その処理を忘れてしまうというミスを
した時にどこでエラーが発生してるのかわからなくなるというヒューマンエラーを助長させる面があります。</simpara>
<formalpara>
<title>catchによるエラーハンドリングを忘れてしまった場合</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">const string = "jsonではない文字列";
JSONPromise(string).then((object) =&gt; {
    console.log(object);
}); <co xml:id="CO15-1"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO15-1">
<para>例外が投げられても何も処理されない</para>
</callout>
</calloutlist>
<simpara><literal>JSON.parse</literal> のような分かりやすい例の場合はまだよいですが、
メソッドをtypoしたことによるSyntax Errorなどはより深刻な問題となりやすいです。</simpara>
<formalpara>
<title>typoによるエラー</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">const string = "{}";
JSONPromise(string).then((object) =&gt; {
    conosle.log(object);<co xml:id="CO16-1"/>
});</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO16-1">
<para>conosle というtypoがある</para>
</callout>
</calloutlist>
<simpara>この場合は、<literal>console</literal> を <literal>conosle</literal> とtypoしているため、以下のようなエラーが発生するはずです。</simpara>
<blockquote>
<simpara>ReferenceError: conosle is not defined</simpara>
</blockquote>
<simpara>しかし、Promiseではtry-catchされるため、エラーが握りつぶされてしまうという現象が起きてしまいます。
毎回、正しく <literal>catch</literal> の処理を書くことができる場合は何も問題ありませんが、
Promiseの実装によってはこのようなミスが検知しにくくなるケースがあることを知っておくべきでしょう。</simpara>
<simpara>このようなエラーの握りつぶしは<emphasis>unhandled rejection</emphasis>と言われることがあります。
"Rejectedされた時の処理がない"というそのままの意味ですね。</simpara>
<note>
<simpara>このunhandled rejectionが検知しにくい問題はPromiseの実装と実行環境に依存します。</simpara>
<simpara>たとえば、 <link xl:href="https://github.com/petkaantonov/bluebird">Bluebird</link> では、
明らかに人間のミスにみえるReferenceErrorの場合などをコンソールにエラーとして表示してくれます。</simpara>
<blockquote>
<simpara>"Possibly unhandled ReferenceError. conosle is not defined</simpara>
</blockquote>
<simpara>また、このunhandled rejectionに関する仕組みが <link xl:href="https://github.com/tc39/ecma262/releases/tag/es2016-draft-20151201">ECMAScript 2016</link> で仕様に追加されています。そのためネイティブPromiseでは、この仕様を活用したGC-based unhandled rejection trackingというものが搭載されているケースが増えています。</simpara>
<simpara>これはpromiseオブジェクトがガーベッジコレクションによって回収されるときに、
それがunhandled rejectionであるなら、エラー表示をするという仕組みがベースになっています。</simpara>
<simpara><link xl:href="https://twitter.com/domenic/status/461154989856264192">Firefox</link> や <link xl:href="https://code.google.com/p/v8/issues/detail?id=3093">Chrome</link> のネイティブPromiseでは一部実装されています。</simpara>
</note>
</section>
<section xml:id="_doneの実装">
<title>doneの実装</title>
<simpara>Promiseにおける <literal>done</literal> は先程のエラーの握りつぶしを避けるにはどうするかという方法論として、
そもそもエラーハンドリングをしなければいい という豪快な解決方法を提供するメソッドです。</simpara>
<simpara><literal>done</literal> はPromiseの上に実装することができるので、
<literal>Promise.prototype.done</literal> というPromiseのprototype拡張として実装してみましょう。</simpara>
<formalpara xml:id="promise-prototype-done.js">
<title>promise-prototype-done.js</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">"use strict";
if (typeof Promise.prototype.done === "undefined") {
    Promise.prototype.done = function(onFulfilled, onRejected) {
        this.then(onFulfilled, onRejected).catch((error) =&gt; {
            setTimeout(() =&gt; {
                throw error;
            }, 0);
        });
    };
}</programlisting>
</para>
</formalpara>
<simpara>どのようにPromiseの外へ例外を投げているかというと、
setTimeoutの中でthrowをすることで、外へそのまま例外を投げられることを利用しています。</simpara>
<formalpara>
<title>setTimeoutのコールバック内での例外</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">try {
    setTimeout(() =&gt; {
        throw new Error("error");<co xml:id="CO17-1"/>
    }, 0);
} catch (error) {
    console.error(error);
}</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO17-1">
<para>この例外はキャッチされない</para>
</callout>
</calloutlist>
<note>
<simpara>なぜ非同期の <literal>callback</literal> 内での例外をキャッチ出来ないのかは以下が参考になります。</simpara>
<itemizedlist>
<listitem>
<simpara><link xl:href="http://techblog.yahoo.co.jp/programming/javascript_error/">JavaScriptと非同期のエラー処理 - Yahoo! JAPAN Tech Blog</link></simpara>
</listitem>
</itemizedlist>
</note>
<simpara><link linkend="promise-prototype-done.js"><literal>Promise.prototype.done</literal></link> をよく見てみると、何も <literal>return</literal> していないことも分かると思います。
つまり、<literal>done</literal> は「ここでPromise chainは終了して、例外が起きた場合はそのままpromiseの外へ投げ直す」という処理になっています。</simpara>
<simpara>現在では多くの実行環境で、<emphasis>unhandled rejection</emphasis>を検知してコンソールに警告を表示するため、<literal>done</literal> が必要な場合は少なくなっています。
また今回の<link linkend="promise-prototype-done.js"><literal>Promise.prototype.done</literal></link>のように、<literal>done</literal> は既存のPromiseの上に実装することができるため、
<link linkend="es-promises">ES Promises</link>の仕様そのものには入らなかったといえるかもしれません。</simpara>
<note>
<simpara>今回の <literal>Promise.prototype.done</literal> の実装は <link xl:href="https://www.promisejs.org/">promisejs.org</link> を参考にしています。</simpara>
</note>
</section>
<section xml:id="_まとめ_9">
<title>まとめ</title>
<simpara>このセクションでは、 <link xl:href="https://github.com/kriskowal/q/wiki/API-Reference#promisedoneonfulfilled-onrejected-onprogress">Q</link> や <link xl:href="https://github.com/petkaantonov/bluebird">Bluebird</link> や <link xl:href="https://github.com/cscott/prfun#promisedone&#8212;&#8203;undefined">prfun</link> 等
多くのPromiseライブラリで実装されている <literal>done</literal> の基礎的な実装と、<literal>then</literal> とはどのような違いがあるかについて学びました。</simpara>
<simpara><literal>done</literal> には次の2つの側面があることがわかりました。</simpara>
<itemizedlist>
<listitem>
<simpara><literal>done</literal> の中で起きたエラーは外へ例外として投げ直す</simpara>
</listitem>
<listitem>
<simpara>Promise chain を終了するという宣言</simpara>
</listitem>
</itemizedlist>
<simpara><link linkend="then-or-catch">then or catch?</link> と同様にPromiseにより沈黙してしまったエラーについては、
デバッグツールやライブラリの改善で問題となるケースは少なくなっています。</simpara>
<simpara>また、<literal>done</literal> は値を返さないことでそれ以上Promise chainを繋げることができなくなるため、
そのような統一感を持たせるという用途で <literal>done</literal> を使うこともできます。</simpara>
<simpara><link linkend="es-promises">ES Promises</link> では根本に用意されてる機能はあまり多くありません。
そのため、自ら拡張したり、拡張したライブラリ等を利用するケースが多いと思います。</simpara>
<simpara>そのときでも何でもやり過ぎると、せっかく非同期処理をPromiseでまとめても複雑化してしまう場合があるため、
統一感を持たせるというのは抽象的なオブジェクトであるPromiseにおいては大事な部分といえるかもしれません。</simpara>
<note>
<simpara><link xl:href="http://blog.getify.com/promises-part-4/">Promises: The Extension Problem (part 4) | getiblog</link> では、
Promiseの拡張を書く手法について書かれています。</simpara>
<itemizedlist>
<listitem>
<simpara><literal>Promise.prototype</literal> を拡張する方法</simpara>
</listitem>
<listitem>
<simpara>Wrapper/Delegate を使った抽象レイヤーを作る方法</simpara>
</listitem>
</itemizedlist>
<simpara>また、Delegateを利用した方法については、 <link xl:href="http://speakingjs.com/es5/ch28.html">Chapter 28. Subclassing Built-ins</link> にて
詳しく解説されています。</simpara>
</note>
</section>
</section>
<section xml:id="promise-and-method-chain">
<title>Promiseとメソッドチェーン</title>
<simpara>Promiseは <literal>then</literal> や <literal>catch</literal> 等のメソッドを繋げて書いていきます。
これはDOMやjQuery等でよくみられるメソッドチェーンとよく似ています。</simpara>
<simpara>一般的なメソッドチェーンは <literal>this</literal> を返すことで、メソッドを繋げて書けるようになっています。</simpara>
<note>
<simpara>メソッドチェーンの作り方については <link xl:href="http://taiju.hatenablog.com/entry/20100307/1267962826">メソッドチェーンの作り方 - あと味</link> などを参照するといいでしょう。</simpara>
</note>
<simpara>一方、Promiseは<link linkend="then-return-new-promise">毎回新しいpromiseオブジェクトを返す</link>ようになっていますが、
一般的なメソッドチェーンと見た目は全く同じです。</simpara>
<simpara>このセクションでは、一般的なメソッドチェーンで書かれたものを
インターフェースはそのままで内部的にはPromiseで処理されるようにする方法について学んでいきたいと思います。</simpara>
<section xml:id="_fsのメソッドチェーン">
<title>fsのメソッドチェーン</title>
<simpara>以下のような <link xl:href="http://nodejs.org/api/fs.html">Node.jsのfs</link>モジュールを例にしてみたいと思います。</simpara>
<simpara>また、今回の例は見た目のわかりやすさを重視しているため、
現実的にはあまり有用なケースとはいえないかもしれません。</simpara>
<formalpara xml:id="fs-method-chain.js">
<title>fs-method-chain.js</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">"use strict";
const fs = require("fs");
function File() {
    this.lastValue = null;
}
// Static method for File.prototype.read
File.read = function FileRead(filePath) {
    const file = new File();
    return file.read(filePath);
};
File.prototype.read = function(filePath) {
    this.lastValue = fs.readFileSync(filePath, "utf-8");
    return this;
};
File.prototype.transform = function(fn) {
    this.lastValue = fn.call(this, this.lastValue);
    return this;
};
File.prototype.write = function(filePath) {
    this.lastValue = fs.writeFileSync(filePath, this.lastValue);
    return this;
};
module.exports = File;</programlisting>
</para>
</formalpara>
<simpara>このモジュールは以下のようにread &#8594; transform &#8594; writeという流れを
メソッドチェーンで表現することができます。</simpara>
<programlisting language="javascript" linenumbering="unnumbered">const File = require("./fs-method-chain");
const inputFilePath = "input.txt";
const outputFilePath = "output.txt";
File.read(inputFilePath)
    .transform((content) =&gt; {
        return "&gt;&gt;" + content;
    })
    .write(outputFilePath);</programlisting>
<simpara><literal>transform</literal> は引数で受け取った値を変更する関数を渡して処理するメソッドです。
この場合は、readで読み込んだ内容の先頭に <literal>&gt;&gt;</literal> という文字列を追加しているだけです。</simpara>
</section>
<section xml:id="_promiseによるfsのメソッドチェーン">
<title>Promiseによるfsのメソッドチェーン</title>
<simpara>次に先ほどの<link linkend="fs-method-chain.js">メソッドチェーン</link>をインターフェースはそのまま維持して
内部的にPromiseを使った処理にしてみたいと思います。</simpara>
<formalpara xml:id="fs-promise-chain.js">
<title>fs-promise-chain.js</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">"use strict";
const fs = require("fs");
function File() {
    this.promise = Promise.resolve();
}
// Static method for File.prototype.read
File.read = function(filePath) {
    const file = new File();
    return file.read(filePath);
};

File.prototype.then = function(onFulfilled, onRejected) {
    this.promise = this.promise.then(onFulfilled, onRejected);
    return this;
};
File.prototype["catch"] = function(onRejected) {
    this.promise = this.promise.catch(onRejected);
    return this;
};
File.prototype.read = function(filePath) {
    return this.then(() =&gt; {
        return fs.readFileSync(filePath, "utf-8");
    });
};
File.prototype.transform = function(fn) {
    return this.then(fn);
};
File.prototype.write = function(filePath) {
    return this.then((data) =&gt; {
        return fs.writeFileSync(filePath, data);
    });
};
module.exports = File;</programlisting>
</para>
</formalpara>
<simpara>内部に持ってるpromiseオブジェクトに対するエイリアスとして
<literal>then</literal> と <literal>catch</literal> を持たせていますが、それ以外のインターフェースは全く同じ使い方となっています。</simpara>
<simpara>そのため、先ほどのコードで <literal>require</literal> するモジュールを変更しただけで動作します。</simpara>
<programlisting language="javascript" linenumbering="unnumbered">const File = require("./fs-promise-chain");
const inputFilePath = "input.txt";
const outputFilePath = "output.txt";
File.read(inputFilePath)
    .transform((content) =&gt; {
        return "&gt;&gt;" + content;
    })
    .write(outputFilePath);</programlisting>
<simpara><literal>File.prototype.then</literal> というメソッドは、
<literal>this.promise.then</literal> が返す新しいpromiseオブジェクトを <literal>this.promise</literal> に対して代入しています。</simpara>
<simpara>これはどういうことなのかというと、以下のように擬似的に展開してみると分かりやすいでしょう。</simpara>
<programlisting language="javascript" linenumbering="unnumbered">const File = require("./fs-promise-chain");
File.read(inputFilePath)
    .transform((content) =&gt; {
        return "&gt;&gt;" + content;
    })
    .write(outputFilePath);
// =&gt; 擬似的に以下のような流れに展開できる
promise.then(() =&gt; {
    return fs.readFileSync(filePath, "utf-8");
}).then((content) =&gt; {
    return "&gt;&gt;" + content;
}).then(() =&gt; {
    return fs.writeFileSync(filePath, data);
});</programlisting>
<simpara><literal>promise = promise.then(&#8230;&#8203;)</literal> という書き方は一見すると、上書きしているようにみえるため、
それまでのpromiseのchainが途切れてしまうと思うかもしれません。</simpara>
<simpara>イメージとしては <literal>promise = addPromiseChain(promise, fn);</literal> のような感じになっていて、
既存のpromiseオブジェクトに対して新たな処理を<emphasis role="strong">追加</emphasis>したpromiseオブジェクトを作って返すため、
自分で逐次的に処理する機構を実装しなくても問題ないわけです。</simpara>
</section>
<section xml:id="_両者の違い">
<title>両者の違い</title>
<section xml:id="_同期と非同期">
<title>同期と非同期</title>
<simpara><xref linkend="fs-method-chain.js"/>と<link linkend="fs-promise-chain.js">Promise版</link>の違いを見ていくと、
そもそも両者には同期的、非同期的という大きな違いがあります。</simpara>
<simpara><xref linkend="fs-method-chain.js"/> のようなメソッドチェーンでもキュー等の処理を実装すれば、
非同期的なほぼ同様のメソッドチェーンを実装できますが、複雑になるため今回は単純な同期的なメソッドチェーンにしました。</simpara>
<simpara>Promise版は<link linkend="promise-is-always-async">コラム: Promiseは常に非同期?</link>で紹介したように
常に非同期処理となるため、promiseを使ったメソッドチェーンも非同期となっています。</simpara>
</section>
<section xml:id="_エラーハンドリング">
<title>エラーハンドリング</title>
<simpara><xref linkend="fs-method-chain.js"/>にはエラーハンドリングの処理は入っていないですが、
同期処理であるため全体を <literal>try-catch</literal> で囲むことで行えます。</simpara>
<simpara><link linkend="fs-promise-chain.js">Promise版</link> では内部で利用するpromiseオブジェクトの
<literal>then</literal> と <literal>catch</literal> へのエイリアスを用意してあるため、通常のpromiseと同じように <literal>catch</literal> によってエラーハンドリングが行えます。</simpara>
<formalpara>
<title>fs-promise-chainでのエラーハンドリング</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">const File = require("./fs-promise-chain");
File.read(inputFilePath)
    .transform((content) =&gt; {
        return "&gt;&gt;" + content;
    })
    .write(outputFilePath)
    .catch((error) =&gt; {
        console.error(error);
    });</programlisting>
</para>
</formalpara>
<simpara><xref linkend="fs-method-chain.js"/>に非同期処理を加えたものを自力で実装する場合、
エラーハンドリングが大きな問題となるため、非同期処理にしたい時は
Promiseを使うと比較的簡単に実装できるといえるかもしれません。</simpara>
</section>
</section>
<section xml:id="_promise以外での非同期処理">
<title>Promise以外での非同期処理</title>
<simpara>このメソッドチェーンと非同期処理を見てNode.jsに慣れている方は <link xl:href="http://nodejs.org/api/stream.html">Stream</link> が思い浮かぶと思います。</simpara>
<simpara><link xl:href="http://nodejs.org/api/stream.html">Stream</link> を使うと、
<literal>this.lastValue</literal> のような値を保持する必要がなくなることや大きなファイルの扱いが改善されます。
また、Promiseを使った例に比べるとより高速に処理できる可能性が高いと思います。</simpara>
<formalpara>
<title>streamによるread&#8594;transform&#8594;write</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">readableStream.pipe(transformStream).pipe(writableStream);</programlisting>
</para>
</formalpara>
<simpara>そのため、非同期処理には常にPromiseが最適という訳ではなく、
目的と状況にあった実装をしていくことを考えていくべきでしょう。</simpara>
<note>
<simpara>Node.jsのStreamはEventをベースにしている技術</simpara>
</note>
<simpara>Node.jsのStreamについて詳しくは以下を参照して下さい。</simpara>
<itemizedlist>
<listitem>
<simpara><link xl:href="http://jxck.hatenablog.com/entry/20111204/1322966453">Node.js の Stream API で「データの流れ」を扱う方法 - Block Rockin’ Codes</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="http://www.slideshare.net/shigeki_ohtsu/stream2-kihon">Stream2の基本</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="http://www.slideshare.net/shigeki_ohtsu/node-v012tng12">Node-v0.12の新機能について</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_promiseラッパー">
<title>Promiseラッパー</title>
<simpara>話を戻して<xref linkend="fs-method-chain.js"/>と<link linkend="fs-promise-chain.js">Promise版</link>の両者を比べると、
内部的にもかなり似ていて、同期版のものがそのまま非同期版でも使えるような気がします。</simpara>
<simpara>JavaScriptでは動的にメソッドを定義することもできるため、
自動的にPromise版を生成できないかということを考えると思います。
(もちろん静的に定義する方が扱いやすいですが)</simpara>
<simpara>そのような仕組みは<link linkend="es-promises">ES Promises</link>にはありませんが、
著名なサードパーティのPromise実装である <link xl:href="https://github.com/petkaantonov/bluebird/">bluebird</link> などには
<link xl:href="https://github.com/petkaantonov/bluebird/blob/master/API.md#promisification">Promisification</link> という機能が用意されています。
また、Node.jsのコアモジュールである<literal>util</literal>モジュールには、 <link xl:href="https://nodejs.org/api/util.html#util_util_promisify_original">util.promisify</link> というAPIが用意されています。</simpara>
<simpara>これを利用すると以下のように、その場でPromise版のメソッドを作成して利用できるようになります。</simpara>
<programlisting language="javascript" linenumbering="unnumbered">const fs = require("fs");
const util = require("util");
// コールバック版のAPIからPromise版を作成する
const readFile = util.promisify(fs.readFile);

readFile("myfile.js", "utf8").then((contents) =&gt; {
    console.log(contents);
}).catch((e) =&gt; {
    console.error(e.stack);
});</programlisting>
<section xml:id="_arrayのpromiseラッパー">
<title>ArrayのPromiseラッパー</title>
<simpara>先ほどの<literal>util.promisify</literal>が何をやっているのか少しイメージしにくいので、
次のようなネイティブ <literal>Array</literal> のPromise版となるメソッドを動的に定義する例を考えてみましょう。</simpara>
<simpara>JavaScriptにはネイティブにもDOMやString等メソッドチェーンが行える機能が多くあります。
<literal>Array</literal> もその一つで、<literal>map</literal> や <literal>filter</literal> 等のメソッドは配列を返すため、メソッドチェーンが利用しやすい機能です</simpara>
<formalpara xml:id="array-promise-chain.js">
<title>array-promise-chain.js</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">"use strict";
function ArrayAsPromise(array) {
    this.array = array;
    this.promise = Promise.resolve();
}
ArrayAsPromise.prototype.then = function(onFulfilled, onRejected) {
    this.promise = this.promise.then(onFulfilled, onRejected);
    return this;
};
ArrayAsPromise.prototype["catch"] = function(onRejected) {
    this.promise = this.promise.catch(onRejected);
    return this;
};
Object.getOwnPropertyNames(Array.prototype).forEach((methodName) =&gt; {
    // Don't overwrite
    if (typeof ArrayAsPromise[methodName] !== "undefined") {
        return;
    }
    const arrayMethod = Array.prototype[methodName];
    if (typeof  arrayMethod !== "function") {
        return;
    }
    ArrayAsPromise.prototype[methodName] = function() {
        const that = this;
        const args = arguments;
        this.promise = this.promise.then(() =&gt; {
            that.array = Array.prototype[methodName].apply(that.array, args);
            return that.array;
        });
        return this;
    };
});

module.exports = ArrayAsPromise;
module.exports.array = function newArrayAsPromise(array) {
    return new ArrayAsPromise(array);
};</programlisting>
</para>
</formalpara>
<simpara>ネイティブのArrayと <literal>ArrayAsPromise</literal> を使った場合の違いは
<link linkend="array-promise-chain.js">上記のコード</link>のテストを見てみるのが分かりやすいでしょう。</simpara>
<formalpara xml:id="array-promise-chain-test.js">
<title>array-promise-chain-test.js</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">const assert = require("assert");
const ArrayAsPromise = require("../src/promise-chain/array-promise-chain");
describe("array-promise-chain", () =&gt; {
    function isEven(value) {
        return value % 2 === 0;
    }

    function double(value) {
        return value * 2;
    }

    beforeEach(function() {
        this.array = [1, 2, 3, 4, 5];
    });
    describe("Native array", () =&gt; {
        it("can method chain", function() {
            const result = this.array.filter(isEven).map(double);
            assert.deepEqual(result, [4, 8]);
        });
    });
    describe("ArrayAsPromise", () =&gt; {
        it("can promise chain", function(done) {
            const array = new ArrayAsPromise(this.array);
            array.filter(isEven).map(double).then((value) =&gt; {
                assert.deepEqual(value, [4, 8]);
            }).then(done, done);
        });
    });
});</programlisting>
</para>
</formalpara>
<simpara><literal>ArrayAsPromise</literal> でもArrayのメソッドを利用できているのが分かります。
先ほどと同じように、ネイティブのArrayは同期処理で、<literal>ArrayAsPromise</literal> は非同期処理という違いがあります。</simpara>
<simpara><literal>ArrayAsPromise</literal> の実装を見て気づくと思いますが、<literal>Array.prototype</literal> のメソッドを全て実装しています。
しかし、<literal>array.indexOf</literal> など <literal>Array.prototype</literal> には配列を返さないものもあるため、全てをメソッドチェーンにするのは不自然なケースがあると思います。</simpara>
<simpara>ここで大事なのが、同じ値を受けるインターフェースを持っているAPIはこのような手段でPromise版のAPIを自動的に作成できるという点です。
このようなAPIの規則性を意識してみるとまた違った使い方が見つかるかもしれません。</simpara>
<note>
<simpara>先ほどの  <link xl:href="https://nodejs.org/api/util.html#util_util_promisify_original">util.promisify</link> は、
Node.jsのCoreモジュールの非同期処理には <literal>function(error, result){}</literal> というように第一引数に <literal>error</literal> が来るというルール（エラーファーストコールバック）を利用して、自動的にPromiseでラップしたメソッドを生成しています。</simpara>
<simpara>また、Node.js 10からは <literal>fs</literal> モジュールに <link xl:href="https://nodejs.org/api/fs.html#fs_fs_promises_api">Promise版のAPI</link> が追加されています。</simpara>
</note>
</section>
</section>
<section xml:id="_まとめ_10">
<title>まとめ</title>
<simpara>このセクションでは以下のことについて学びました。</simpara>
<itemizedlist>
<listitem>
<simpara>Promise版のメソッドチェーンの実装</simpara>
</listitem>
<listitem>
<simpara>Promiseが常に非同期の最善の手段ではない</simpara>
</listitem>
<listitem>
<simpara>Promisification</simpara>
</listitem>
<listitem>
<simpara>統一的なインターフェースの再利用</simpara>
</listitem>
</itemizedlist>
<simpara><link linkend="es-promises">ES Promises</link>はCoreとなる機能しか用意されていません。
そのため、自分でPromiseを使った既存の機能のラッパー的な実装をすることがあるかもしれません。</simpara>
<simpara>しかし、何度もコールバックを呼ぶEventのような処理がPromiseには不向きなように、
Promiseが常に最適な非同期処理という訳ではありません。</simpara>
<simpara>その機能にPromiseを使うのが最適なのかを考えることはこの書籍の目的でもあるため、
何でもPromiseにするというわけではなく、その目的にPromiseが合うのかどうかを考えてみるのもいいと思います。</simpara>
</section>
</section>
<section xml:id="promise-sequence">
<title>Promiseによる逐次処理</title>
<simpara>第2章の<link linkend="ch2-promise-all">Promise.all</link>では、
複数のpromiseオブジェクトをまとめて処理する方法について学びました。</simpara>
<simpara>しかし、<literal>Promise.all</literal> は全ての処理を並行に行うため、
Aの処理 が終わったら Bの処理 というような逐次的な処理を扱うことができません。</simpara>
<simpara>また、同じ2章の<link linkend="ch2-promise-and-array">Promiseと配列</link>では、
効率的ではないですが、<link linkend="multiple-xhr.js">thenを連ねた書き方</link>でそのような逐次処理を行っていました。</simpara>
<simpara>このセクションでは、Promiseを使った逐次処理の書き方について学んで行きたいと思います。</simpara>
<section xml:id="_ループと逐次処理">
<title>ループと逐次処理</title>
<simpara><link linkend="multiple-xhr.js">thenを連ねた書き方</link>では以下のような書き方でしたね。</simpara>
<programlisting role="executable" language="javascript" linenumbering="unnumbered">function fetchURL(URL) {
    return new Promise((resolve, reject) =&gt; {
        const req = new XMLHttpRequest();
        req.open("GET", URL, true);
        req.onload = () =&gt; {
            if (200 &lt;= req.status &amp;&amp; req.status &lt; 300) {
                resolve(req.responseText);
            } else {
                reject(new Error(req.statusText));
            }
        };
        req.onerror = () =&gt; {
            reject(new Error(req.statusText));
        };
        req.send();
    });
}
const request = {
    comment() {
        return fetchURL("https://azu.github.io/promises-book/json/comment.json").then(JSON.parse);
    },
    people() {
        return fetchURL("https://azu.github.io/promises-book/json/people.json").then(JSON.parse);
    }
};
function main() {
    function recordValue(results, value) {
        results.push(value);
        return results;
    }
    // [] は記録する初期値を部分適用している
    const pushValue = recordValue.bind(null, []);
    return request.comment()
        .then(pushValue)
        .then(request.people)
        .then(pushValue);
}



// 実行例
main().then((value) =&gt; {
    console.log(value);
}).catch((error) =&gt; {
    console.error(error);
});</programlisting>
<simpara>この書き方だと、<literal>request</literal> の数が増える分 <literal>then</literal> を書かないといけなくなってしまいます。</simpara>
<simpara>そこで、処理を配列にまとめて、forループで処理していければ、数が増えた場合も問題無いですね。
まずはforループを使って先ほどと同じ処理を書いてみたいと思います。</simpara>
<formalpara xml:id="promise-foreach-xhr.js" role="executable">
<title>promise-foreach-xhr.js</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">function fetchURL(URL) {
    return new Promise((resolve, reject) =&gt; {
        const req = new XMLHttpRequest();
        req.open("GET", URL, true);
        req.onload = () =&gt; {
            if (200 &lt;= req.status &amp;&amp; req.status &lt; 300) {
                resolve(req.responseText);
            } else {
                reject(new Error(req.statusText));
            }
        };
        req.onerror = () =&gt; {
            reject(new Error(req.statusText));
        };
        req.send();
    });
}
const request = {
    comment() {
        return fetchURL("https://azu.github.io/promises-book/json/comment.json").then(JSON.parse);
    },
    people() {
        return fetchURL("https://azu.github.io/promises-book/json/people.json").then(JSON.parse);
    }
};
function main() {
    function recordValue(results, value) {
        results.push(value);
        return results;
    }

    // [] は記録する初期値を部分適用してる
    const pushValue = recordValue.bind(null, []);
    // promiseオブジェクトを返す関数の配列
    const tasks = [request.comment, request.people];
    let promise = Promise.resolve();// スタート地点
    for (let i = 0; i &lt; tasks.length; i++) {
        const task = tasks[i];
        promise = promise.then(task).then(pushValue);
    }
    return promise;
}



// 実行例
main().then((value) =&gt; {
    console.log(value);
}).catch((error) =&gt; {
    console.error(error);
});</programlisting>
</para>
</formalpara>
<simpara>forループで書く場合、<link linkend="then-return-new-promise">コラム: thenは常に新しいpromiseオブジェクトを返す</link>や<link linkend="promise-and-method-chain">Promiseとメソッドチェーン</link>で学んだように、
<link linkend="promise.then">Promise#then</link> は新しいpromiseオブジェクトを返しています。</simpara>
<simpara>そのため、<literal>promise = promise.then(task).then(pushValue);</literal> というのは <literal>promise</literal> という変数に上書きするというよりは、
そのpromiseオブジェクトに処理を追加していくような処理になっています。</simpara>
<simpara>しかし、この書き方だと一時変数として <literal>promise</literal> が必要で、処理の内容的にもあまりスッキリしません。</simpara>
<simpara>このループの書き方は <literal>Array.prototype.reduce</literal> を使うともっとスマートに書くことができます。</simpara>
</section>
<section xml:id="_promise_chainとreduce">
<title>Promise chainとreduce</title>
<simpara><literal>Array.prototype.reduce</literal> を使って書き直すと以下のようになります。</simpara>
<formalpara xml:id="promise-reduce-xhr.js" role="executable">
<title>promise-reduce-xhr.js</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">function fetchURL(URL) {
    return new Promise((resolve, reject) =&gt; {
        const req = new XMLHttpRequest();
        req.open("GET", URL, true);
        req.onload = () =&gt; {
            if (200 &lt;= req.status &amp;&amp; req.status &lt; 300) {
                resolve(req.responseText);
            } else {
                reject(new Error(req.statusText));
            }
        };
        req.onerror = () =&gt; {
            reject(new Error(req.statusText));
        };
        req.send();
    });
}
const request = {
    comment() {
        return fetchURL("https://azu.github.io/promises-book/json/comment.json").then(JSON.parse);
    },
    people() {
        return fetchURL("https://azu.github.io/promises-book/json/people.json").then(JSON.parse);
    }
};
function main() {
    function recordValue(results, value) {
        results.push(value);
        return results;
    }

    const pushValue = recordValue.bind(null, []);
    const tasks = [request.comment, request.people];
    return tasks.reduce((promise, task) =&gt; {
        return promise.then(task).then(pushValue);
    }, Promise.resolve());
}



// 実行例
main().then((value) =&gt; {
    console.log(value);
}).catch((error) =&gt; {
    console.error(error);
});</programlisting>
</para>
</formalpara>
<simpara><literal>main</literal> 以外の処理はforループのものと同様です。</simpara>
<simpara><literal>Array.prototype.reduce</literal> は第二引数に初期値を入れることができます。
つまりこの場合、最初の <literal>promise</literal> には <literal>Promise.resolve()</literal> が入り、
そのときの <literal>task</literal> は <literal>request.comment</literal> となります。</simpara>
<simpara>reduceの中で <literal>return</literal> したものが、次のループで <literal>promise</literal> に入ります。
つまり、<literal>then</literal> を使って作成した新たなpromiseオブジェクトを返すことで、
forループの場合と同じように<link linkend="promise-chain">Promise chain</link>を繋げることができます。</simpara>
<note>
<simpara><literal>Array.prototype.reduce</literal> については詳しくは以下を参照して下さい。</simpara>
<itemizedlist>
<listitem>
<simpara><link xl:href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce">Array.prototype.reduce() - JavaScript | MDN</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://azu.github.io/slide/JSGohan/reduce.html">Array.prototype.reduce Dance</link></simpara>
</listitem>
</itemizedlist>
</note>
<simpara>forループと異なる点は、一時変数としての <literal>promise</literal> が不要になることに伴い、
<literal>promise = promise.then(task).then(pushValue);</literal> という不格好な書き方がなくなる点が大きな違いだと思います。</simpara>
<simpara><literal>Array.prototype.reduce</literal> とPromiseの逐次処理は相性がよいので覚えておくといいのですが、
初めて見た時にどのような動作をするのかがまだ分かりにくいという問題があります。</simpara>
<simpara>そこで、処理するTaskとなる関数の配列を受け取って逐次処理を行う
<literal>sequenceTasks</literal> というものを作ってみます。</simpara>
<simpara>以下のように書くことができれば、<literal>tasks</literal> が順番に処理されていくことが関数名から見て分かるようになります。</simpara>
<programlisting language="javascript" linenumbering="unnumbered">const tasks = [request.comment, request.people];
sequenceTasks(tasks);</programlisting>
</section>
<section xml:id="_逐次処理を行う関数を定義する">
<title>逐次処理を行う関数を定義する</title>
<simpara>基本的には、<link linkend="promise-reduce-xhr.js">reduceを使ったやり方</link>を関数として切り離せばいいだけですね。</simpara>
<formalpara xml:id="promise-sequence.js">
<title>promise-sequence.js</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">function sequenceTasks(tasks) {
    function recordValue(results, value) {
        results.push(value);
        return results;
    }

    const pushValue = recordValue.bind(null, []);
    return tasks.reduce((promise, task) =&gt; {
        return promise.then(task).then(pushValue);
    }, Promise.resolve());
}</programlisting>
</para>
</formalpara>
<simpara>一つ注意点として、<literal>Promise.all</literal> 等と違い、引数に受け取るのは関数の配列です。</simpara>
<simpara>なぜ、渡すのがpromiseオブジェクトの配列ではないのかというと、
promiseオブジェクトを作った段階ですでにXHRが実行されている状態なので、
それを逐次処理しても意図とは異なる動作になるためです。</simpara>
<simpara>そのため <literal>sequenceTasks</literal> では関数(promiseオブジェクトを返す)の配列を引数に受け取ります。</simpara>
<simpara>最後に、<literal>sequenceTasks</literal> を使って最初の例を書き換えると以下のようになります。</simpara>
<formalpara xml:id="promise-sequence-xhr.js" role="executable">
<title>promise-sequence-xhr.js</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">function sequenceTasks(tasks) {
    function recordValue(results, value) {
        results.push(value);
        return results;
    }

    const pushValue = recordValue.bind(null, []);
    return tasks.reduce((promise, task) =&gt; {
        return promise.then(task).then(pushValue);
    }, Promise.resolve());
}
function fetchURL(URL) {
    return new Promise((resolve, reject) =&gt; {
        const req = new XMLHttpRequest();
        req.open("GET", URL, true);
        req.onload = () =&gt; {
            if (200 &lt;= req.status &amp;&amp; req.status &lt; 300) {
                resolve(req.responseText);
            } else {
                reject(new Error(req.statusText));
            }
        };
        req.onerror = () =&gt; {
            reject(new Error(req.statusText));
        };
        req.send();
    });
}
const request = {
    comment() {
        return fetchURL("https://azu.github.io/promises-book/json/comment.json").then(JSON.parse);
    },
    people() {
        return fetchURL("https://azu.github.io/promises-book/json/people.json").then(JSON.parse);
    }
};
function main() {
    return sequenceTasks([request.comment, request.people]);
}



// 実行例
main().then((value) =&gt; {
    console.log(value);
}).catch((error) =&gt; {
    console.error(error);
});</programlisting>
</para>
</formalpara>
<simpara><literal>main()</literal> の中がかなりスッキリしたことが分かります。</simpara>
<simpara>このようにPromiseでは、逐次処理ということをするのに色々な書き方ができると思います。</simpara>
<itemizedlist>
<listitem>
<simpara><link linkend="multiple-xhr.js">thenをその場に並べた書き方</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="promise-foreach-xhr.js">forループを使った書き方</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="promise-reduce-xhr.js">reduceを使った書き方</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="promise-sequence.js">逐次処理する関数を分けた書き方</link></simpara>
</listitem>
</itemizedlist>
<simpara>さらに、ここではまだ紹介していませんが、<link linkend="chapter5-async-function">Async Function</link>を使う方法もあります。</simpara>
<simpara>しかし、これはJavaScriptで配列を扱うのにforループや <literal>forEach</literal> 等、色々やり方があるのと本質的には違いはありません。
そのため、Promiseを扱う場合も処理をまとめられるところは小さく関数に分けて、実装していくのがいいといえるでしょう。</simpara>
</section>
<section xml:id="_まとめ_11">
<title>まとめ</title>
<simpara>このセクションでは、<link linkend="Promise.all"><literal>Promise.all</literal></link>とは違い、
一つづつ順番に処理したい場合に、Promiseでどのように実装していくかについて学びました。</simpara>
<simpara>手続き的な書き方から、逐次処理を行う関数を定義するところまで見ていき、
Promiseであっても関数に処理を分けるという基本的なことは変わらないことを示しました。</simpara>
<simpara>Promiseで書くとPromise chainを繋げすぎて縦に長い処理を書いてしまうことがあります。</simpara>
<simpara>そんな時は基本に振り返り、処理を関数に分けることで全体の見通しを良くすることは大切です。</simpara>
<simpara>また、Promiseのコンストラクタ関数や <literal>then</literal> 等は高階関数なので、
処理を関数に分けておくと組み合わせが行い易いという副次的な効果もあるため、意識してみるといいかもしれません。</simpara>
<note>
<simpara>高階関数とは引数に関数オブジェクトを受け取る関数のこと</simpara>
</note>
</section>
</section>
</section>
<section xml:id="chapter5-async-function">
<title>Chapter.5 - Async Function</title>
<simpara>この章では、ECMAScript 2017で導入されたAsync Function(<literal>async</literal>/<literal>await</literal>)について学んでいきます。</simpara>
<section xml:id="async-function">
<title>Async Functionとは</title>
<simpara>Async Functionとは非同期処理を行う関数を定義する構文です。
Async Functionは通常の関数とは異なり、必ず<literal>Promise</literal>インスタンスを返す関数を定義する構文です。</simpara>
<simpara>Async Functionは次のように関数の前に<literal>async</literal>をつけることで定義できます。
この<literal>doAsync</literal>関数は常に<literal>Promise</literal>インスタンスを返します。</simpara>
<programlisting role="executable" language="javascript" linenumbering="unnumbered">async function doAsync() {
    return "値";
}
// doAsync関数はPromiseを返す
doAsync().then((value) =&gt; {
    console.log(value); // =&gt; "値"
});</programlisting>
<simpara>Async Functionでは<literal>return</literal>した値の代わりに、<literal>Promise.resolve(返り値)</literal>のように返り値をラップした<literal>Promise</literal>インスタンスを返します。
そのため、このAsync Functionは次のように書いた場合と同じ意味になります。</simpara>
<programlisting role="executable" language="javascript" linenumbering="unnumbered">// 通常の関数でPromiseインスタンスを返している
function doAsync() {
    return Promise.resolve("値");
}
doAsync().then((value) =&gt; {
    console.log(value); // =&gt; "値"
});</programlisting>
<simpara>またAsync Function内では<literal>await</literal>式というPromiseの非同期処理が完了するまで待つ構文が利用できます。
<literal>await</literal>式を使うことで非同期処理を同期処理のように扱えるため、Promiseチェーンで実現していた処理の流れを読みやすくかけます。</simpara>
<simpara>Async Functionと<literal>await</literal>式の大まかな動きをイメージするために、まずはPromise APIで書いたものと比較してみます。</simpara>
<simpara>ここでは、XHRの現代的なバージョンである <link xl:href="https://developer.mozilla.org/ja/docs/Web/API/Fetch_API">Fetch API</link> を使います。Fetch APIは指定したURLのリソースを読み書きでき、デフォルトでES Promisesに対応しています。</simpara>
<simpara>次のサンプルコードでは、<literal><link xl:href="https://azu.github.io/promises-book/json/book.json">https://azu.github.io/promises-book/json/book.json</link></literal>というURLからJSONデータを取得して、<literal>title</literal>プロパティを取り出す<literal>getBookTitle</literal>関数を実装していきます。</simpara>
<simpara>取得する<literal><link xl:href="https://azu.github.io/promises-book/json/book.json">https://azu.github.io/promises-book/json/book.json</link></literal>は次のような内容になっています。</simpara>
<formalpara xml:id="book.json">
<title>/json/book.json</title>
<para>
<programlisting language="json" linenumbering="unnumbered">{
    "title": "JavaScript Promiseの本",
    "repository": "https://github.com/azu/promises-book"
}</programlisting>
</para>
</formalpara>
<simpara>まずは、Fetch APIを使って<literal>fetchBookTitle</literal>関数で取得したタイトルをコンソールに出力してみます。</simpara>
<simpara><literal>fetch</literal>メソッドはPromiseを返します。このPromiseインスタンスはリクエストのレスポンスを表す<literal>Response</literal>オブジェクトでresolveされます。
<literal>Response#json</literal>メソッドもPromiseを返します。このPromiseインスタンスは取得したリソースをJSONとしてパースしたオブジェクトでresolveされます。</simpara>
<simpara><literal>fetchBookTitle</literal>関数は、次のように<literal>fetch</literal>メソッドで取得したJSONの<literal>title</literal>プロパティでresolveされるPromiseインスタンスを返します。</simpara>
<programlisting role="executable" language="javascript" linenumbering="unnumbered">function fetchBookTitle() {
    // Fetch APIは指定URLのリソースを取得しPromiseを返す関数
    return fetch("https://azu.github.io/promises-book/json/book.json").then((res) =&gt; {
        return res.json(); // レスポンスをJSON形式としてパースする
    }).then((json) =&gt; {
        return json.title; // JSONからtitleプロパティを取り出す
    });
}

function main() {
    // `fetchBookTitle`関数は、取得したJSONの`title`プロパティでresolveされる
    fetchBookTitle().then((title) =&gt; {
        console.log(title); // =&gt; "JavaScript Promiseの本"
    });
}

main();</programlisting>
<simpara>次は、同様の処理をAsync Functionと<literal>await</literal>式で実装してみます。
ここではまだ挙動を理解しなくても問題ありませんが、
Promise APIを使っていた場合に比べて、<literal>then</literal>メソッドやコールバック関数がなくなっていることが分かります。</simpara>
<programlisting role="executable" language="javascript" linenumbering="unnumbered">// `async`をつけて`fetchBookTitle`関数をAsync Functionとして定義
async function fetchBookTitle() {
    // リクエストしてリソースを取得する
    const res = await fetch("https://azu.github.io/promises-book/json/book.json");
    // レスポンスをJSON形式としてパースする
    const json = await res.json();
    // JSONからtitleプロパティを取り出す
    return json.title;
}

// `async`をつけて`main`関数をAsync Functionとして定義
async function main() {
    // `await`式で`fetchBookTitle`の非同期処理が完了するまで待つ
    // `fetchBookTitle`がresolveした値が返り値になる
    const title = await fetchBookTitle();
    console.log(title); // =&gt; "JavaScript Promiseの本"
}

main();</programlisting>
<simpara>Async FunctionではPromiseの状態が変化するまで待つ<literal>await</literal>式という機能を利用できます。
Promiseでは結果を<literal>then</literal>メソッドのコールバック関数で取得していたのが、<literal>await</literal>式の右辺にあるPromiseのresolveされた値が左辺の変数へと代入されます。そのため、Async Functionと<literal>await</literal>式を使うことで非同期処理をまるで同期処理のように書けます。</simpara>
<simpara>この章では、このAsync Functionと<literal>await</literal>式について詳しく見ていきます。</simpara>
<simpara>重要なこととしてAsync FunctionはPromiseの上に作られた構文です。
そのためAsync Functionを理解するには、Promiseを理解する必要があることに注意してください。</simpara>
</section>
<section xml:id="async-function-syntax">
<title>Async Functionの構文</title>
<simpara>Async Functionは関数の定義に<literal>async</literal>キーワードをつけることで定義できます。
JavaScriptの関数定義には関数宣言や関数式、Arrow Function、メソッドの短縮記法などがあります。
どの定義方法でも<literal>async</literal>キーワードを前につけるだけでAsync Functionとして定義できます。</simpara>
<programlisting language="javascript" linenumbering="unnumbered">// 関数宣言のAsync Function版
async function fn1() {}
// 関数式のAsync Function版
const fn2 = async function() {};
// Arrow FunctionのAsync Function版
const fn3 = async() =&gt; {};
// メソッドの短縮記法のAsync Function版
const object = {
    async method() {}
};</programlisting>
<simpara>これらのAsync Functionは、次のこと以外は通常の関数と同じ性質を持ちます。</simpara>
<itemizedlist>
<listitem>
<simpara>Async Functionは必ずPromiseを返す</simpara>
</listitem>
<listitem>
<simpara>Async Function内では<literal>await</literal>式が利用できる</simpara>
</listitem>
</itemizedlist>
<section xml:id="async-function-return-promise">
<title>Async FunctionはPromiseを返す</title>
<simpara>Async Functionとして定義した関数は必ず<literal>Promise</literal>インスタンスを返します。
返される<literal>Promise</literal>インスタンスの状態は関数の返り値によって異なり、次の3つのケースが考えられます。</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Async FunctionはPromise以外の値をreturnした場合、その返り値をもつ<emphasis role="strong">Fulfilled</emphasis>なPromiseを返す</simpara>
</listitem>
<listitem>
<simpara>Async FunctionがPromiseをreturnした場合、その返り値のPromiseをそのまま返す</simpara>
</listitem>
<listitem>
<simpara>Async Function内で例外が発生した場合は、そのエラーをもつ<emphasis role="strong">Rejected</emphasis>なPromiseを返す</simpara>
</listitem>
</orderedlist>
<simpara>これらの挙動は<literal>Promise#then</literal>メソッドの返り値とそのコールバック関数が返す値の関係とほぼ同じです。</simpara>
<simpara>具体的な例を順番に見ていきます。</simpara>
<simpara>まず、Async FunctionはPromise以外の値をreturnした場合、その返り値で解決される<emphasis role="strong">Fulfilled</emphasis>なPromiseを返します。
これは、返した値が<literal>Promise.resolve</literal>されているのとほとんど同じ感覚です。</simpara>
<programlisting role="executable" language="javascript" linenumbering="unnumbered">// `Promise.resolve(undefined)`を返したのと同じ
async function resolveUndefined() {
    // 何も値を返さない場合は`undefined`を返すのと同じ
}
resolveUndefined().then((value) =&gt; {
    console.log(value); // =&gt; undefined
});
// `Promise.resolve("値")`を返したのと同じ
async function resolveFn() {
    return "値";
}
resolveFn().then((value) =&gt; {
    console.log(value); // =&gt; "値"
});</programlisting>
<simpara>次に、 Async FunctionがPromiseをreturnした場合、その返り値のPromiseをそのまま返します。
これは、<literal>Promise#then</literal>メソッドで<emphasis role="strong">Rejected</emphasis>なPromiseを返すことで、<literal>throw</literal>文を使わずにPromiseをrejectする方法と同じです。</simpara>
<programlisting role="executable" language="javascript" linenumbering="unnumbered">// resolveFnは**Fulfilled**なPromiseインスタンスを返している
// Async Functionは自動的にPromiseを返すので、単に値を返しても同じ
async function resolveFn() {
    return Promise.resolve("値");
}
resolveFn().then((value) =&gt; {
    console.log(value); // =&gt; "値"
});

// rejectFnは**Rejected**なPromiseインスタンスを返している
async function rejectFn() {
    return Promise.reject(new Error("エラーメッセージ"));
}
rejectFn().catch((error) =&gt; {
    console.log(error.message); // =&gt; "エラーメッセージ"
});</programlisting>
<simpara>最後に、Async Function内で例外が発生した場合は、そのエラーをもつ<emphasis role="strong">Rejected</emphasis>なPromiseを返します。
これは、Promise内での処理が自動的に<literal>try&#8230;&#8203;catch</literal>されているのと同じで、Async Functionでも例外が発生した場合は自動的にキャッチされます。</simpara>
<programlisting role="executable" language="javascript" linenumbering="unnumbered">// exceptionFnは例外を投げている
async function exceptionFn() {
    throw new Error("例外が発生しました");
    // 例外が発生したため、この行は実行されません
}

// Async Functionで例外が発生するとRejectedなPromiseが返される
exceptionFn().catch((error) =&gt; {
    console.log(error.message); // =&gt; "例外が発生しました"
});</programlisting>
<simpara>どの場合でも、Async Functionは必ずPromiseを返すことがわかります。
このようにAsync Functionを呼び出す側から見れば、Async FunctionはPromiseを返すただの関数と何も変わりません。</simpara>
</section>
</section>
<section xml:id="async-function-await">
<title><literal>await</literal>式</title>
<simpara>Async Functionはasync/awaitとも呼ばれることがあります。
この呼ばれ方からも分かるように、Async Functionと<literal>await</literal>式は共に利用します。</simpara>
<simpara><literal>await</literal>式はAsync Function内でのみ利用できます。
<literal>await</literal>式は右辺の<literal>Promise</literal>インスタンスが<emphasis role="strong">Fulfilled</emphasis>または<emphasis role="strong">Rejected</emphasis>になるまで、その行（文）で非同期処理の完了を待ちます。
そして<literal>Promise</literal>インスタンスの状態が変わると、次の行（文）から処理を再開します。</simpara>
<programlisting language="js" linenumbering="unnumbered">async function asyncMain() {
    // PromiseがFulfilledまたはRejectedとなるまで待つ
    await Promiseインスタンス;
    // Promiseインスタンスの状態が変わったら処理を再開する
}</programlisting>
<simpara>通常の処理の流れでは、非同期処理を実行した場合にその非同期処理の完了を待つことなく、次の行（次の文）を実行します。
しかし<literal>await</literal>式では非同期処理を実行し完了するまで、次の行（次の文）を実行しません。
そのため<literal>await</literal>式を使うことで非同期処理が同期処理のように上から下へと順番に実行するような流れで書けます。</simpara>
<programlisting language="js" linenumbering="unnumbered">// async functionは必ずPromiseを返す
async function doAsync() {
    // 非同期処理
}
async function asyncMain() {
    // doAsyncの非同期処理が完了するまでまつ
    await doAsync();
    // 次の行はdoAsyncの非同期処理が完了されるまで実行されない
    console.log("この行は非同期処理が完了後に実行される");
}</programlisting>
<simpara><literal>await</literal>式は<emphasis role="strong">式</emphasis>であるため右辺（<literal>Promise</literal>インスタンス）の評価結果を値として返します。
この<literal>await</literal>式の評価方法は評価するPromiseの状態（<emphasis role="strong">Fulfilled</emphasis>または<emphasis role="strong">Rejected</emphasis>）によって異なります。</simpara>
<simpara><literal>await</literal>式の右辺のPromiseが<emphasis role="strong">Fulfilled</emphasis>となった場合は、resolveされた値が<literal>await</literal>式の返り値となります。</simpara>
<simpara>次のコードでは、<literal>await</literal>式の右辺にある<literal>Promise</literal>インスタンスは<literal>42</literal>という値でresolveされています。
そのため<literal>await</literal>式の返り値は<literal>42</literal>となり、<literal>value</literal>変数にもその値が入ります。</simpara>
<programlisting role="executable" language="javascript" linenumbering="unnumbered">async function asyncMain() {
    const value = await Promise.resolve(42);
    console.log(value); // =&gt; 42
}
asyncMain(); // Promiseインスタンスを返す</programlisting>
<simpara>これはPromiseを使って書くと次のコードと同様の意味となります。
<literal>await</literal>式を使うことでコールバック関数を使わずに非同期処理の流れを表現できていることがわかります。</simpara>
<programlisting role="executable" language="javascript" linenumbering="unnumbered">function asyncMain() {
    return Promise.resolve(42).then((value) =&gt; {
        console.log(value); // =&gt; 42
    });
}
asyncMain(); // Promiseインスタンスを返す</programlisting>
<simpara><literal>await</literal>式の右辺のPromiseが<emphasis role="strong">Rejected</emphasis>となった場合は、その場でエラーを<literal>throw</literal>します。
また「<link linkend="async-function-syntax">async-function-syntax</link>」で紹介したように、Async Function内で発生した例外は自動的にキャッチされます。
そのため<literal>await</literal>式でPromiseが<emphasis role="strong">Rejected</emphasis>となった場合は、そのAsync Functionが<emphasis role="strong">Rejected</emphasis>なPromiseを返すことになります。</simpara>
<simpara>次のコードでは、<literal>await</literal>式の右辺にある<literal>Promise</literal>インスタンスが<emphasis role="strong">Rejected</emphasis>の状態になっています。
そのため<literal>await</literal>式は<literal>エラー</literal>を<literal>throw</literal>します。そのエラーを自動的にキャッチするため、<literal>asyncMain</literal>関数は<emphasis role="strong">Rejected</emphasis>なPromiseを返します。</simpara>
<programlisting role="executable" language="javascript" linenumbering="unnumbered">async function asyncMain() {
    const value = await Promise.reject(new Error("エラーメッセージ"));
    // await式で例外が発生したため、この行は実行されません
}
// Async Functionは自動的に例外をキャッチできる
asyncMain().catch((error) =&gt; {
    console.log(error.message); // =&gt; "エラーメッセージ"
});</programlisting>
<simpara><literal>await</literal>式がエラーを<literal>throw</literal>するということは、そのエラーは<literal>try&#8230;&#8203;catch</literal>構文でキャッチできます。
通常の非同期処理では完了する前に次の行が実行されてしまうため<literal>try&#8230;&#8203;catch</literal>構文ではエラーをキャッチできませんでした。
そのためPromiseでは<literal>catch</literal>メソッドを使いPromise内で発生したエラーをキャッチしていました。（<link linkend="promise-done">Promise.prototype.done とは何か?</link>を参照）</simpara>
<simpara>次のコードでは、<literal>await</literal>式で発生した例外を<literal>try&#8230;&#8203;catch</literal>構文でキャッチしています。</simpara>
<programlisting role="executable" language="javascript" linenumbering="unnumbered">async function asyncMain() {
    // await式のエラーはtry...catchできる
    try {
        // `await`式で評価した右辺のPromiseがRejectedとなったため、例外がthrowされる
        const value = await Promise.reject(new Error("エラーメッセージ"));
        // await式で例外が発生したため、この行は実行されません
    } catch (error) {
        console.log(error.message); // =&gt; "エラーメッセージ"
    }
}
asyncMain().then(() =&gt; {
    console.log("この行は実行されます");
}, (error) =&gt; {
    // すでにtry...catchされているため、この行は実行されません
});</programlisting>
<simpara>このように<literal>await</literal>式を使うことで、<literal>try&#8230;&#8203;catch</literal>構文のように非同期処理を同期処理と同じ構文を使って扱えます。
またコードの見た目も同期処理と同じように、その行（その文）の処理が完了するまで次の行を評価しないという分かりやすい形になるのは大きな利点です。</simpara>
</section>
<section xml:id="promise-chain-to-async-function">
<title>Async Functionと配列</title>
<simpara><link linkend="ch2-promise-and-array">Promiseと配列</link>のように、配列を元にした複数の非同期処理を扱う場合のAsync Functionについて見ていきます。</simpara>
<simpara>例として、複数のリソースを順番に取得する処理をPromiseで書いていきます。</simpara>
<simpara>まずは、Promiseを使った非同期処理を行う関数として、リソースを擬似的に取得する<literal>dummyFetch</literal>という関数を実装していきます。
<literal>dummyFetch</literal>関数は擬似的にデータ取得する関数で、1000ミリ秒未満のランダムなタイミングでレスポンスを返す非同期的な処理です。
パスが<literal>/resource</literal>から始まるリソースを取得した場合は、そのレスポンスをもった<emphasis role="strong">Resolved</emphasis>状態のPromiseオブジェクトを返します。
それ以外の場合は、リソースの取得に失敗したとして<emphasis role="strong">Rejected</emphasis>状態のPromiseオブジェクトを返します。</simpara>
<programlisting role="executable" language="javascript" linenumbering="unnumbered">/**
 * 1000ミリ秒未満のランダムなタイミングでレスポンスを擬似的にデータ取得する関数
 * 指定した`path`にデータがある場合、成功として**Resolved**状態のPromiseオブジェクトを返す
 * 指定した`path`にデータがない場合、失敗として**Rejected**状態のPromiseオブジェクトを返す
 */
function dummyFetch(path) {
    return new Promise((resolve, reject) =&gt; {
        setTimeout(() =&gt; {
            if (path.startsWith("/resource")) {
                resolve({ body: `Response body of ${path}` });
            } else {
                reject(new Error("NOT FOUND"));
            }
        }, 1000 * Math.random());
    });
}
// `then`メソッドで成功時と失敗時に呼ばれるコールバック関数を登録
// /resource/A のリソースは存在するので成功しonFulfilledが呼ばれる
dummyFetch("/resource/A").then((response) =&gt; {
    console.log(response); // =&gt; { body: "Response body of /resource/A" }
}, (error) =&gt; {
    // この行は実行されません
});
// /not_found のリソースは存在しないのでonRejectedが呼ばれる
dummyFetch("/not_found").then((response) =&gt; {
    // この行は実行されません
}, (error) =&gt; {
    console.log(error.message); // =&gt; "NOT FOUND"
});</programlisting>
<simpara>この<literal>dymmyFetch</literal>関数を使い、複数のリソースを順番に取得する<literal>fetchResources</literal>関数を実装していきます。
<literal>fetchResources</literal>関数は、配列で複数のリソースへのパスを受け取り、取得したリソースの中身(<literal>body</literal>)を配列として返すことにします。</simpara>
<simpara>まずは、Promise APIのみを使って<literal>fetchResources</literal>関数を実装してみましょう。
Promise APIでは、<literal>Array#reduce</literal>メソッドを使った逐次処理を実装することで、複数の非同期処理を順番に実行できます。
（詳細は<link linkend="promise-sequence">Promiseによる逐次処理</link>を参照）</simpara>
<programlisting role="executable" language="javascript" linenumbering="unnumbered">function dummyFetch(path) {
    return new Promise((resolve, reject) =&gt; {
        setTimeout(() =&gt; {
            if (path.startsWith("/resource")) {
                resolve({ body: `Response body of ${path}` });
            } else {
                reject(new Error("NOT FOUND"));
            }
        }, 1000 * Math.random());
    });
}
// 複数のリソースを取得し、レスポンスボディの配列を返す
function fetchResources(resources) {
    const results = [];
    // 配列をpromise chainにして順番に処理する
    return resources.reduce((promise, resource) =&gt; {
        return promise.then(() =&gt; {
            return dummyFetch(resource).then((response) =&gt; {
                results.push(response.body);
                return results;
            });
        });
    }, Promise.resolve());
}
const resources = ["/resource/A", "/resource/B"];
// リソースを取得して出力する
fetchResources(resources).then((results) =&gt; {
    console.log(results); // =&gt; ["Response body of /resource/A", "Response body of /resource/B"]
});</programlisting>
<simpara>次に、先ほどと同じ処理をする<literal>fetchResources</literal>をAsync Functionと<literal>await</literal>式で書いてみます。
Async Functionとして定義した<literal>fetchResources</literal>関数では、forループの中で<literal>await</literal>式を使うことで複数の非同期処理を順番に実行できます。</simpara>
<simpara>次のコードでは、リソースのパスをforループで順番に、<literal>dummyFetch</literal>関数を使ってリソースの中身を取得しています。
forループによる反復処理も<literal>await</literal>式で<literal>dummyFetch</literal>関数の完了を待っているため、その非同期処理が終ってから次の反復処理を行います。
すべてのforループの処理が終わると、<literal>fetchResources</literal>関数が返したPromiseオブジェクトが変数<literal>results</literal>が参照する値でresolveされます。</simpara>
<programlisting role="executable" language="javascript" linenumbering="unnumbered">function dummyFetch(path) {
    return new Promise((resolve, reject) =&gt; {
        setTimeout(() =&gt; {
            if (path.startsWith("/resource")) {
                resolve({ body: `Response body of ${path}` });
            } else {
                reject(new Error("NOT FOUND"));
            }
        }, 1000 * Math.random());
    });
}
// 複数のリソースを取得し、レスポンスボディの配列を返す
async function fetchResources(resources) {
    const results = [];
    for (let i = 0; i &lt; resources.length; i++) {
        const resource = resources[i];
        const response = await dummyFetch(resource);
        results.push(response.body);
    }
    return results;
}
const resources = ["/resource/A", "/resource/B"];
// リソースを取得して出力する
fetchResources(resources).then((results) =&gt; {
    console.log(results); // =&gt; ["Response body of /resource/A", "Response body of /resource/B"]
});</programlisting>
<simpara>Promise APIのみで<literal>fetchResources</literal>関数書いた場合は、コールバックの中で処理するためややこしい見た目になりがちです。
一方で、Async Functionと<literal>await</literal>式を使った場合は、非同期処理での取得と追加を順番に行うだけとなりネストがなく見た目はシンプルです。</simpara>
<section xml:id="await-in-async-function">
<title><literal>await</literal>式はAsync Functionの中でのみ利用可能</title>
<simpara>先ほどの<literal>fetchResources</literal>関数ではforループを利用していました。
このとき、配列の反復処理に<literal>Array#forEach</literal>メソッドを利用したくなるかもしれません。</simpara>
<simpara>しかし、次のようにforループを<literal>Array#forEach</literal>に変更するだけでは、構文エラー（Syntax Error）となってしまいます。</simpara>
<programlisting role="executable" language="javascript" linenumbering="unnumbered">async function fetchResources(resources) {
    const results = [];
    // Syntax Errorとなる例
    resources.forEach(function(resources) {
        const resource = resources[i];
        // Async Functionではないスコープで`await`式を利用しているためSyntax Errorとなる
        const response = await dummyFetch(resource);
        results.push(response.body);
    });
    return results;
}</programlisting>
<simpara>これは、<literal>await</literal>式はAsync Functionの直下でのみ利用できるからです。</simpara>
<simpara>Async Functionではない通常の関数で<literal>await</literal>式を使うとSyntax Errorとなります。
これは間違った<literal>await</literal>式の使い方を防止するための仕様です。</simpara>
<programlisting role="executable" language="javascript" linenumbering="unnumbered">function main(){
    // Syntax Error
    await Promise.resolve();
}</programlisting>
<simpara>Async Function内で<literal>await</literal>式を使って処理を待っている間も、関数の外側では通常とおり処理が進みます。
次のコードを実行してみると、Async Function内で<literal>await</literal>しても、Async Function外の処理は停止していないことがわかります。</simpara>
<programlisting role="executable" language="javascript" linenumbering="unnumbered">async function asyncMain() {
    // 中でawaitしても、Async Functionの外側の処理まで止まるわけではない
    await new Promise((resolve) =&gt; {
        setTimeout(resolve, 16);
    });
}
console.log("1. asyncMain関数を呼び出します");
// Async Functionは外から見れば単なるPromiseを返す関数
asyncMain().then(() =&gt; {
    console.log("3. asyncMain関数が完了しました");
});
// Async Functionの外側の処理はそのまま進む
console.log("2. asyncMain関数外では、次の行が同期的に呼び出される");</programlisting>
<simpara>このように<literal>await</literal>式で非同期処理を一時停止しても、Async Function外の処理が停止するわけではありません。
Async Function外の処理も停止できてしまうと、JavaScriptでは基本的にメインスレッドで多くの処理をするため、UIを含めた他の処理が止まってしまいます。
これが<literal>await</literal>式がAsync Functionの外で利用できない理由の一つです。</simpara>
<simpara><literal>await</literal>式はAsync Functionの中でのみ利用可能なため、コールバック関数もAsync Functionとして定義しないと<literal>await</literal>式が利用できないことに注意してください。</simpara>
<simpara>そのため、<literal>fetchResources</literal>関数の<literal>Array#forEach</literal>メソッドのコールバック関数に対して、<literal>async</literal>キーワードをつけることで構文エラーは発生しなくなります。
この場合は、コールバック関数がAsync Functionとなるため、コールバック関数内で<literal>await</literal>式が利用できます。
しかし、コールバック関数をAsync Functionに修正するだけでは、<literal>fetchResources</literal>関数が意図した結果を返しません。</simpara>
<simpara>次のように<literal>Array#forEach</literal>メソッドのコールバック関数をAsync Functionにしてみます。
このコードを実行してみると、<literal>fetchResources</literal>関数の返したPromiseの結果は空の配列となり、意図した結果にならないことが分かります。</simpara>
<programlisting role="executable" language="javascript" linenumbering="unnumbered">function dummyFetch(path) {
    return new Promise((resolve, reject) =&gt; {
        setTimeout(() =&gt; {
            if (path.startsWith("/resource")) {
                resolve({ body: `Response body of ${path}` });
            } else {
                reject(new Error("NOT FOUND"));
            }
        }, 1000 * Math.random());
    });
}
// リソースを順番に取得する
async function fetchResources(resources) {
    const results = [];
    resources.forEach(async(resource) =&gt; {
        const response = await dummyFetch(resource);
        results.push(response.body);
    });
    return results;
}
const resources = ["/resource/A", "/resource/B"];
// リソースを取得して出力する
fetchResources(resources).then((results) =&gt; {
    // resultsは空になってしまう
    console.log(results); // =&gt; []
});</programlisting>
<simpara><literal>forEach</literal>メソッドのコールバック関数としてAsync Functionを渡し、コールバック関数中で<literal>await</literal>式を利用して非同期処理の完了を待っています。
しかし、この非同期処理の完了を待つのはコールバック関数Async Functionの中だけで、外側では<literal>fetchResources</literal>関数の処理が進んでいます。
そのため、コールバック関数で<literal>results</literal>に結果を追加する前に、<literal>fetchResources</literal>関数はその時点の変数<literal>results</literal>の値でresolveしてしまいます。</simpara>
<simpara>次のように<literal>fetchResources</literal>関数にコンソール出力を入れてみると動作が分かりやすいでしょう。
<literal>forEach</literal>メソッドのコールバック関数が完了するのは、<literal>fetchResources</literal>関数の呼び出しがすべて終わった後になります。
そのため<literal>fetchResources</literal>関数はその時点の変数<literal>results</literal>の値である空の配列でresolveします。</simpara>
<programlisting role="executable" language="javascript" linenumbering="unnumbered">function dummyFetch(path) {
    return new Promise((resolve, reject) =&gt; {
        setTimeout(() =&gt; {
            if (path.startsWith("/resource")) {
                resolve({ body: `Response body of ${path}` });
            } else {
                reject(new Error("NOT FOUND"));
            }
        }, 1000 * Math.random());
    });
}
// リソースを順番に取得する
async function fetchResources(resources) {
    const results = [];
    console.log("1. fetchResourcesを開始");
    resources.forEach(async(resource) =&gt; {
        console.log(`2. ${resource}の取得開始`);
        const response = await dummyFetch(resource);
        console.log(`3. ${resource}の取得完了`);
        results.push(response.body);
    });
    console.log("4. fetchResourcesを終了");
    return results;
}
const resources = ["/resource/A", "/resource/B"];
// リソースを取得して出力する
fetchResources(resources).then((results) =&gt; {
    console.log(results); // =&gt; []
});</programlisting>
<simpara>この問題を解決する方法として、先ほどのようにコールバック関数を使わずにforループを使う方法があります。
また、リソースを順番が重要ではない場合は、<literal>Promise.all</literal>メソッドを使い、複数の非同期処理を1つのPromiseとしてまとめる方法があります。</simpara>
</section>
<relationship-promise-async-function xml:id="_promiseとasync_functionを組み合わせる">
<title>PromiseとAsync Functionを組み合わせる</title>
<simpara>Async Functionと<literal>await</literal>式でも非同期処理を同期処理のような見た目で書けます。
しかし、非同期処理は必ずしも順番に処理することが重要ではない場合があります。
その際に、forループと<literal>await</literal>式で書くと複数の非同期処理を順番に行ってしまい無駄な待ち時間を作ってしまうコードになってしまいます。</simpara>
<simpara>先ほど<literal>fetchResources</literal>関数ではリソースAを取得し終わってから、リソースBを取得していました。
このとき、取得順が変わっても問題無い場合は、リソースAとリソースBを同時に取得する方が効率的です。</simpara>
<simpara><literal>Promise.all</literal>メソッドを使い、リソースAとリソースBを取得する非同期処理を1つの<literal>Promise</literal>インスタンスにまとめることができます。
<literal>await</literal>式が評価するのは<literal>Promise</literal>インスタンスであるため、<literal>await</literal>式は<literal>Promise.all</literal>メソッドなど<literal>Promise</literal>インスタンスを返す処理と組み合わせて利用できます。</simpara>
<simpara>そのため、先ほど<literal>fetchResources</literal>関数でリソースを同時に取得する場合は、次のように書けます。
<literal>Promise.all</literal>メソッドは複数のPromiseを配列で受け取り、それを1つのPromiseとしてまとめたものを返す関数です。
<literal>Promise.all</literal>メソッドの返す<literal>Promise</literal>インスタンスを<literal>await</literal>することで、非同期処理の結果を配列としてまとめて取得できます。</simpara>
<programlisting role="executable" language="javascript" linenumbering="unnumbered">function dummyFetch(path) {
    return new Promise((resolve, reject) =&gt; {
        setTimeout(() =&gt; {
            if (path.startsWith("/resource")) {
                resolve({ body: `Response body of ${path}` });
            } else {
                reject(new Error("NOT FOUND"));
            }
        }, 1000 * Math.random());
    });
}

// 複数のリソースを取得しレスポンスボディの配列を返す
async function fetchResources(resources) {
    // リソースをまとめて取得する
    const promises = resources.map((resource) =&gt; {
        return dummyFetch(resource);
    });
    // すべてのリソースが取得できるまで待つ
    // Promise.allは [ResponseA, ResponseB] のように結果が配列となる
    const responses = await Promise.all(promises);
    // 取得した結果からレスポンスのボディだけを取り出す
    return responses.map((response) =&gt; {
        return response.body;
    });
}
const resources = ["/resource/A", "/resource/B"];
// リソースを取得して出力する
fetchResources(resources).then((results) =&gt; {
    console.log(results); // =&gt; ["Response body of /resource/A", "Response body of /resource/B"]
});</programlisting>
<simpara>このようにAsync Functionや<literal>await</literal>式は既存のPromise APIと組み合わせて利用できます。
Async Functionも内部的にPromiseの仕組みを利用した構文です。
そのため、Async FunctionとPromiseのAPIを組み合わせて考えることは重要です。</simpara>
</relationship-promise-async-function>
</section>
</section>
<section xml:id="promise-api-reference">
<title>Promises API Reference</title>
<section xml:id="promise.then">
<title>Promise#then</title>
<programlisting language="javascript" linenumbering="unnumbered">promise.then(onFulfilled, onRejected);</programlisting>
<formalpara role="executable">
<title>thenコード例</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">const promise = new Promise((resolve, reject) =&gt; {
    resolve("thenに渡す値");
});
promise.then((value) =&gt; {
    console.log(value);
}, (error) =&gt; {
    console.error(error);
});</programlisting>
</para>
</formalpara>
<simpara>promiseオブジェクトに対してonFulfilledとonRejectedのハンドラを定義し、
新たなpromiseオブジェクトを作成して返す。</simpara>
<simpara>このハンドラはpromiseがresolve または rejectされた時にそれぞれ呼ばれる。</simpara>
<itemizedlist>
<listitem>
<simpara>定義されたハンドラ内で返した値は、新たなpromiseオブジェクトのonFulfilledに対して渡される。</simpara>
</listitem>
<listitem>
<simpara>定義されたハンドラ内で例外が発生した場合は、新たなpromiseオブジェクトのonRejectedに対して渡される。</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="promise.catch">
<title>Promise#catch</title>
<programlisting language="javascript" linenumbering="unnumbered">promise.catch(onRejected);</programlisting>
<formalpara role="executable">
<title>catchのコード例</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">const promise = new Promise((resolve, reject) =&gt; {
    resolve("thenに渡す値");
});
promise.then((value) =&gt; {
    console.log(value);
}).catch((error) =&gt; {
    console.error(error);
});</programlisting>
</para>
</formalpara>
<simpara><literal>promise.then(undefined, onRejected)</literal> と同等の意味をもつシンタックスシュガー。</simpara>
</section>
<section xml:id="promise.finally">
<title>Promise#finally</title>
<programlisting language="javascript" linenumbering="unnumbered">promise.finally(onFinally);</programlisting>
<formalpara role="executable">
<title>finallyのコード例</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">let isLoading = true;

fetch("https://httpbin.org/get").then((response) =&gt; {
    if (response.ok) {
        return response.json();
    }
    throw new TypeError("正しくデータを取得できなかった");
  })
  .then((json) =&gt; {
      console.log("リクエストが成功した", json);
   })
  .catch((error) =&gt; {
      console.error("リクエストが失敗した", error);
   })
  .finally(() =&gt; {
      // 成功、失敗どちらの場合も必ず呼ばれる処理
      isLoading = false;
  });</programlisting>
</para>
</formalpara>
<simpara>Promise chainが成功、失敗どちらの場合でも呼ばれるハンドラを登録し、新しいpromiseオブジェクトを作成して返す。
返したpromiseオブジェクトは、finallyの呼び出し元となったpromiseオブジェクトの状態を引き継ぐ。</simpara>
</section>
<section xml:id="Promise.resolve">
<title>Promise.resolve</title>
<programlisting language="javascript" linenumbering="unnumbered">Promise.resolve(promise);
Promise.resolve(thenable);
Promise.resolve(object);</programlisting>
<formalpara role="executable">
<title>Promise.resolveのコード例</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">const taskName = "task 1";
asyncTask(taskName).then((value) =&gt; {
    console.log(value);
}).catch((error) =&gt; {
    console.error(error);
});
function asyncTask(name) {
    return Promise.resolve(name).then((value) =&gt; {
        return "Done! " + value;
    });
}</programlisting>
</para>
</formalpara>
<simpara>受け取った値に応じたpromiseオブジェクトを返す。</simpara>
<simpara>どの場合でもpromiseオブジェクトを返すが、大きく分けて以下の3種類となる。</simpara>
<variablelist>
<varlistentry>
<term>promiseオブジェクトを受け取った場合</term>
<listitem>
<simpara>受け取ったpromiseオブジェクトをそのまま返す</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>thenableなオブジェクトを受け取った場合</term>
<listitem>
<simpara><literal>then</literal> をもつオブジェクトを新たなpromiseオブジェクトにして返す</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>その他の値(オブジェクトやnull等も含む)を受け取った場合</term>
<listitem>
<simpara>その値でresolveされる新たなpromiseオブジェクトを作り返す</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="Promise.reject">
<title>Promise.reject</title>
<programlisting language="javascript" linenumbering="unnumbered">Promise.reject(object);</programlisting>
<formalpara>
<title>Promise.rejectのコード例</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">const failureStub = sinon.stub(xhr, "request").returns(Promise.reject(new Error("bad!")));</programlisting>
</para>
</formalpara>
<simpara>受け取った値でrejectされた新たなpromiseオブジェクトを返す。</simpara>
<simpara>Promise.rejectに渡す値は <literal>Error</literal> オブジェクトとすべきである。</simpara>
<simpara>また、Promise.resolveとは異なり、promiseオブジェクトを渡した場合も常に新たなpromiseオブジェクトを作成する。</simpara>
<programlisting role="executable" language="javascript" linenumbering="unnumbered">const r = Promise.reject(new Error("error"));
console.log(r === Promise.reject(r));// false</programlisting>
</section>
<section xml:id="Promise.all">
<title>Promise.all</title>
<programlisting language="javascript" linenumbering="unnumbered">Promise.all(promiseArray);</programlisting>
<formalpara role="executable">
<title>Promise.allのコード例</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">const p1 = Promise.resolve(1);
const p2 = Promise.resolve(2);
const p3 = Promise.resolve(3);
Promise.all([p1, p2, p3]).then((results) =&gt; {
    console.log(results);  // [1, 2, 3]
});</programlisting>
</para>
</formalpara>
<simpara>新たなpromiseオブジェクトを作成して返す。</simpara>
<simpara>渡されたpromiseオブジェクトの配列が全てresolveされた時に、
新たなpromiseオブジェクトはその値でresolveされる。</simpara>
<simpara>どれかの値がrejectされた場合は、その時点で新たなpromiseオブジェクトはrejectされる。</simpara>
<simpara>渡された配列の値はそれぞれ <literal>Promise.resolve</literal> にラップされるため、
promiseオブジェクト以外が混在している場合も扱える。</simpara>
</section>
<section xml:id="Promise.race">
<title>Promise.race</title>
<programlisting language="javascript" linenumbering="unnumbered">Promise.race(promiseArray);</programlisting>
<formalpara role="executable">
<title>Promise.raceのコード例</title>
<para>
<programlisting language="javascript" linenumbering="unnumbered">const p1 = Promise.resolve(1);
const p2 = Promise.resolve(2);
const p3 = Promise.resolve(3);
Promise.race([p1, p2, p3]).then((value) =&gt; {
    console.log(value);  // 1
});</programlisting>
</para>
</formalpara>
<simpara>新たなpromiseオブジェクトを作成して返す。</simpara>
<simpara>渡されたpromiseオブジェクトの配列のうち、
一番最初にresolve または rejectされたpromiseにより、
新たなpromiseオブジェクトはその値でresolve または rejectされる。</simpara>
</section>
</section>
<section xml:id="promise-glossary">
<title>用語集</title>
<variablelist>
<varlistentry>
<term>Promises</term>
<listitem>
<simpara>プロミスという仕様そのもの</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>promiseオブジェクト</term>
<listitem>
<simpara>プロミスオブジェクト、<literal>Promise</literal> のインスタンスオブジェクトのこと</simpara>
</listitem>
</varlistentry>
</variablelist>
<variablelist xml:id="es-promises">
<varlistentry>
<term>ES Promises</term>
<listitem>
<simpara><link xl:href="https://tc39.es/ecma262/">ECMAScriptの仕様</link> を明示的に示す場合にprefixとして <emphasis>ES</emphasis> をつける</simpara>
</listitem>
</varlistentry>
</variablelist>
<variablelist xml:id="promises-aplus">
<varlistentry>
<term>Promises/A+</term>
<listitem>
<simpara><link xl:href="http://promises-aplus.github.io/promises-spec/">Promises/A+</link>のこと。
ES Promisesの前身となったコミュニティベースの仕様であり、ES Promisesとは多くの部分が共通している。</simpara>
</listitem>
</varlistentry>
</variablelist>
<variablelist xml:id="Thenable">
<varlistentry>
<term>Thenable</term>
<listitem>
<simpara>Promiseライクなオブジェクトのこと。
<literal>.then</literal> というメソッドをもつオブジェクト。</simpara>
</listitem>
</varlistentry>
</variablelist>
<variablelist xml:id="promise-chain">
<varlistentry>
<term>promise chain</term>
<listitem>
<simpara>promiseオブジェクトを <literal>then</literal> や <literal>catch</literal> のメソッドチェーンでつなげたもの。
この用語は書籍中のものであり、<link linkend="es-promises">ES6 Promises</link>で定められた用語ではありません。</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="resouce-link">
<title>参考サイト</title>
<variablelist>
<varlistentry>
<term><link xl:href="https://github.com/w3ctag/promises-guide">w3ctag/promises-guide</link> <link xl:href="https://triple-underscore.github.io/promises-guide-ja.html">（日本語訳）</link></term>
<listitem>
<simpara>Promisesのガイド - 概念的な説明はここから得たものが多い</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link xl:href="https://github.com/domenic/promises-unwrapping">domenic/promises-unwrapping</link></term>
<listitem>
<simpara>ES Promisesの仕様の元となったリポジトリ - issueを検索して得た経緯や情報も多い</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link xl:href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-promise-objects">ECMAScript 2015 Language Specification – ECMA-262 6th Edition</link></term>
<listitem>
<simpara>ECMAScript 2015におけるPromiseの仕様書 - PromiseはES2015で導入された</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link xl:href="https://tc39.es/ecma262/">ECMAScript® Language Specification</link></term>
<listitem>
<simpara>ECMAScriptの仕様書 - 最新の仕様</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link xl:href="http://www.html5rocks.com/ja/tutorials/es6/promises/">JavaScript Promises: There and back again - HTML5 Rocks</link></term>
<listitem>
<simpara>Promisesについての記事 - 完成度がとても高くサンプルコードやリファレンス等を参考にした</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link xl:href="http://d.hatena.ne.jp/jovi0608/20140319/1395199285">Node.jsにPromiseが再びやって来た！ - ぼちぼち日記</link></term>
<listitem>
<simpara>Node.jsとPromiseの記事 - <emphasis>thenable</emphasis>について参考にした</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link xl:href="https://exploringjs.com/">Exploring JS: JavaScript books for programmers</link></term>
<listitem>
<simpara>ECMAScript全般について詳しく書かれている書籍</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="about-author">
<title>著者について</title>
<simpara><inlinemediaobject>
<imageobject>
<imagedata fileref="Appendix-Glossary/img/simple320_320.png" contentwidth="32" contentdepth="32"/>
</imageobject>
<textobject><phrase>azu</phrase></textobject>
</inlinemediaobject>
<emphasis role="strong"><link xl:href="https://github.com/azu/">azu</link></emphasis> (Twitter : @<link xl:href="https://twitter.com/azu_re">azu_re</link> )</simpara>
<simpara>ブラウザ、JavaScriptの最新技術を常に追いかけている。</simpara>
<simpara>目的を手段にしてしまうことを得意としている(この書籍もその結果できた)。</simpara>
<simpara><link xl:href="https://efcl.info/">Web Scratch</link> や <link xl:href="https://jser.info/">JSer.info</link> といったサイトを運営している。</simpara>
<section xml:id="omake-message">
<title>著者へのメッセージ/おまけ</title>
<simpara>以下の <link xl:href="https://gumroad.com/l/javascript-promise">おまけ.pdf</link> では、
この書籍を書き始めた理由や、どのように書いていったか、テストなどについて書かれています。</simpara>
<itemizedlist>
<listitem>
<simpara><link xl:href="https://gumroad.com/l/javascript-promise">JavaScript Promiseの本のおまけ</link></simpara>
</listitem>
</itemizedlist>
<simpara>Gumroadから無料 または 好きな値段でダウンロードすることができます。</simpara>
<simpara>ダウンロードする際に作者へのメッセージも書けるので、
メッセージを残すついでにダウンロードして行ってください。</simpara>
<simpara>問題の指摘などがありましたら、GitHubやGitterに書いてくださると解決できます。</simpara>
<itemizedlist>
<listitem>
<simpara><link xl:href="https://github.com/azu/promises-book/issues?state=open">Issues · azu/promises-book</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://gitter.im/azu/promises-book">azu/promises-book - Gitter</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
</article>