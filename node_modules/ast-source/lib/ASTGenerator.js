// LICENSE : MIT
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _assert = _interopRequireDefault(require("assert"));

var _escodegen = require("escodegen");

var _generator = _interopRequireDefault(require("@babel/generator"));

var _filepathUtil = require("./utils/filepath-util");

var _findParser = require("./utils/find-parser");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var ASTGenerator =
/*#__PURE__*/
function () {
  /**
   * @param {ASTSourceOptions} options
   */
  function ASTGenerator(options) {
    _classCallCheck(this, ASTGenerator);

    /**
     * @type {ASTSourceOptions}
     */
    this.options = options;
    this.type = (0, _findParser.findParserType)(options);
  }

  _createClass(ASTGenerator, [{
    key: "_sourceCodePath",
    value: function _sourceCodePath() {
      return (0, _filepathUtil.adjustFilePath)(this.options.filePath, this.options.sourceRoot);
    }
    /**
     * generate code(only)
     * @param {Object}AST
     * @returns {string}
     */

  }, {
    key: "generateCode",
    value: function generateCode(AST) {
      if (this.type === _findParser.ParserTypes.Esprima) {
        return (0, _escodegen.generate)(AST, {
          comment: this.options.comment
        });
      } else if (this.type === _findParser.ParserTypes.Babylon) {
        return (0, _generator.default)(AST);
      }
    }
    /**
     * generate code and source map
     * @param {Object} AST
     * @param {{sourceContent: string}} sourceContent sourceContent is original code for SourceMap
     * @returns {{code: string, map: Object}}
     */

  }, {
    key: "generateCodeWithMap",
    value: function generateCodeWithMap(AST, _ref) {
      var sourceContent = _ref.sourceContent;
      (0, _assert.default)(sourceContent != null, "sourceContent is required. `generate(AST, {sourceContent})`");

      if (this.type === _findParser.ParserTypes.Esprima) {
        var generateOption = {
          comment: this.options.comment,
          sourceMap: this._sourceCodePath(),
          sourceContent: sourceContent,
          sourceMapWithCode: true
        };

        var _generate = (0, _escodegen.generate)(AST, generateOption),
            code = _generate.code,
            map = _generate.map;

        return {
          code: code,
          map: map
        };
      } else if (this.type === _findParser.ParserTypes.Babylon) {
        return (0, _generator.default)(AST, {}, sourceContent);
      }
    }
  }]);

  return ASTGenerator;
}();

exports.default = ASTGenerator;
//# sourceMappingURL=ASTGenerator.js.map