// LICENSE : MIT
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _findParser = require("./utils/find-parser");

var _babelParseToEsprima = require("./babel-parse-to-esprima");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

// FIXME: why wrong import for espower-babel?
var esprima = require("esprima");

var debug = require("debug")("ASTSource");

function attachComments(ast, comments, tokens) {
  if (comments.length) {
    var firstComment = comments[0];
    var lastComment = comments[comments.length - 1]; // fixup program start

    if (!tokens.length) {
      // if no tokens, the program starts at the end of the last comment
      ast.start = lastComment.end;
      ast.loc.start.line = lastComment.loc.end.line;
      ast.loc.start.column = lastComment.loc.end.column;
    } else if (firstComment.start < tokens[0].start) {
      // if there are comments before the first token, the program starts at the first token
      var token = tokens[0];
      ast.start = token.start;
      ast.loc.start.line = token.loc.start.line;
      ast.loc.start.column = token.loc.start.column; // estraverse do not put leading comments on first node when the comment
      // appear before the first token

      if (ast.body.length) {
        var node = ast.body[0];
        node.leadingComments = [];
        var firstTokenStart = token.start;
        var len = comments.length;

        for (var i = 0; i < len && comments[i].start < firstTokenStart; i++) {
          node.leadingComments.push(comments[i]);
        }
      }
    } // fixup program end


    if (tokens.length) {
      var lastToken = tokens[tokens.length - 1];

      if (lastComment.end > lastToken.end) {
        // If there is a comment after the last token, the program ends at the
        // last token and not the comment
        ast.end = lastToken.end;
        ast.loc.end.line = lastToken.loc.end.line;
        ast.loc.end.column = lastToken.loc.end.column;
      }
    }
  }
}

var ASTParser =
/*#__PURE__*/
function () {
  /**
   * @param {ASTSourceOptions} options
   */
  function ASTParser(options) {
    _classCallCheck(this, ASTParser);

    this.options = options;
    this.type = (0, _findParser.findParserType)(options);
    debug("ParserType: %s", this.type);
  }
  /**
   * change parser type
   * @param {ParserTypes} type
   */


  _createClass(ASTParser, [{
    key: "setType",
    value: function setType(type) {
      this.type = type;
    }
  }, {
    key: "parse",
    value: function parse(code) {
      if (this.type === _findParser.ParserTypes.Esprima) {
        return this._parseByEsprima(code, this.options);
      } else if (this.type === _findParser.ParserTypes.Babylon) {
        return this._parseByBabel(code, this.options);
      }

      throw new Error("unreachable #parse");
    }
    /**
     * @param code
     * @param {ASTSourceOptions} options
     * @returns {Object}
     * @private
     */

  }, {
    key: "_parseByEsprima",
    value: function _parseByEsprima(code, options) {
      var esprimaOptions = {
        source: options.filePath,
        loc: options.loc,
        range: options.range,
        comment: options.comment,
        attachComment: options.comment,
        tokens: options.esprimaTokens,
        sourceType: options.sourceType || "module"
      };
      return esprima.parse(code, esprimaOptions);
    }
  }, {
    key: "_parseByBabel",
    value: function _parseByBabel(code, options) {
      var babylonOptions = {
        sourceFile: options.filePath,
        locations: options.loc,
        ranges: options.range,
        sourceType: options.sourceType || "module",
        strictMode: true,
        allowImportExportEverywhere: false,
        // consistent with espree
        allowReturnOutsideFunction: true,
        allowSuperOutsideMethod: true,
        plugins: ["flow", "jsx", "asyncFunctions", "asyncGenerators", "classConstructorCall", "classProperties", "decorators", "doExpressions", "exponentiationOperator", "exportExtensions", "functionBind", "functionSent", "objectRestSpread", "trailingFunctionCommas"]
      };
      return (0, _babelParseToEsprima.parseToEsprima)(code, babylonOptions);
    }
  }]);

  return ASTParser;
}();

exports.default = ASTParser;
//# sourceMappingURL=ASTParser.js.map