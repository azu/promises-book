{"version":3,"sources":["../src/ASTGenerator.js"],"names":["ASTGenerator","options","type","filePath","sourceRoot","AST","ParserTypes","Esprima","comment","Babylon","sourceContent","generateOption","sourceMap","_sourceCodePath","sourceMapWithCode","code","map"],"mappings":"AAAA;AACA;;;;;;;AACA;;AACA;;AACA;;AACA;;AACA;;;;;;;;;;IACqBA,Y;;;AACjB;;;AAGA,wBAAYC,OAAZ,EAAqB;AAAA;;AACjB;;;AAGA,SAAKA,OAAL,GAAeA,OAAf;AACA,SAAKC,IAAL,GAAY,gCAAeD,OAAf,CAAZ;AACH;;;;sCAEiB;AACd,aAAO,kCAAe,KAAKA,OAAL,CAAaE,QAA5B,EAAsC,KAAKF,OAAL,CAAaG,UAAnD,CAAP;AACH;AAED;;;;;;;;iCAKaC,G,EAAK;AACd,UAAI,KAAKH,IAAL,KAAcI,wBAAYC,OAA9B,EAAuC;AACnC,eAAO,yBAASF,GAAT,EAAc;AACjBG,UAAAA,OAAO,EAAE,KAAKP,OAAL,CAAaO;AADL,SAAd,CAAP;AAGH,OAJD,MAIO,IAAI,KAAKN,IAAL,KAAcI,wBAAYG,OAA9B,EAAuC;AAC1C,eAAO,wBAAcJ,GAAd,CAAP;AACH;AACJ;AAED;;;;;;;;;wCAMoBA,G,QAAwB;AAAA,UAAjBK,aAAiB,QAAjBA,aAAiB;AACxC,2BAAOA,aAAa,IAAI,IAAxB,EAA8B,6DAA9B;;AACA,UAAI,KAAKR,IAAL,KAAcI,wBAAYC,OAA9B,EAAuC;AACnC,YAAMI,cAAc,GAAG;AACnBH,UAAAA,OAAO,EAAE,KAAKP,OAAL,CAAaO,OADH;AAEnBI,UAAAA,SAAS,EAAE,KAAKC,eAAL,EAFQ;AAGnBH,UAAAA,aAAa,EAAEA,aAHI;AAInBI,UAAAA,iBAAiB,EAAE;AAJA,SAAvB;;AADmC,wBAOb,yBAAST,GAAT,EAAcM,cAAd,CAPa;AAAA,YAO3BI,IAP2B,aAO3BA,IAP2B;AAAA,YAOrBC,GAPqB,aAOrBA,GAPqB;;AAQnC,eAAO;AAAED,UAAAA,IAAI,EAAJA,IAAF;AAAQC,UAAAA,GAAG,EAAHA;AAAR,SAAP;AACH,OATD,MASO,IAAI,KAAKd,IAAL,KAAcI,wBAAYG,OAA9B,EAAuC;AAC1C,eAAO,wBAAcJ,GAAd,EAAmB,EAAnB,EAAuBK,aAAvB,CAAP;AACH;AACJ","sourcesContent":["// LICENSE : MIT\n\"use strict\";\nimport assert from \"assert\";\nimport { generate } from \"escodegen\";\nimport babelGenerate from \"@babel/generator\";\nimport { adjustFilePath } from \"./utils/filepath-util\";\nimport { ParserTypes, findParserType } from \"./utils/find-parser\";\nexport default class ASTGenerator {\n    /**\n     * @param {ASTSourceOptions} options\n     */\n    constructor(options) {\n        /**\n         * @type {ASTSourceOptions}\n         */\n        this.options = options;\n        this.type = findParserType(options);\n    }\n\n    _sourceCodePath() {\n        return adjustFilePath(this.options.filePath, this.options.sourceRoot);\n    }\n\n    /**\n     * generate code(only)\n     * @param {Object}AST\n     * @returns {string}\n     */\n    generateCode(AST) {\n        if (this.type === ParserTypes.Esprima) {\n            return generate(AST, {\n                comment: this.options.comment\n            });\n        } else if (this.type === ParserTypes.Babylon) {\n            return babelGenerate(AST);\n        }\n    }\n\n    /**\n     * generate code and source map\n     * @param {Object} AST\n     * @param {{sourceContent: string}} sourceContent sourceContent is original code for SourceMap\n     * @returns {{code: string, map: Object}}\n     */\n    generateCodeWithMap(AST, { sourceContent }) {\n        assert(sourceContent != null, \"sourceContent is required. `generate(AST, {sourceContent})`\");\n        if (this.type === ParserTypes.Esprima) {\n            const generateOption = {\n                comment: this.options.comment,\n                sourceMap: this._sourceCodePath(),\n                sourceContent: sourceContent,\n                sourceMapWithCode: true\n            };\n            const { code, map } = generate(AST, generateOption);\n            return { code, map };\n        } else if (this.type === ParserTypes.Babylon) {\n            return babelGenerate(AST, {}, sourceContent);\n        }\n    }\n}\n"],"file":"ASTGenerator.js"}