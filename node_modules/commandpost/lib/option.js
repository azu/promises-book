"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const error_1 = require("./error");
const utils = __importStar(require("./utils"));
// jsdoc, see constructor.
class Option {
    /**
     * class of option.
     * ```
     * cmd --path foo/bar buzz.txt
     *       â†‘ this one!
     * ```
     * @param flags pass '-f, --foo'(boolean) or '--foo'(boolean) or '--foo <bar>'(string[]) or '--foo [bar]'(string[]).
     * @param description
     * @param defaultValue
     * @class
     */
    constructor(flags, description, defaultValue) {
        this.flags = flags;
        this.defaultValue = defaultValue;
        this.required = flags.indexOf("<") !== -1;
        this.optional = flags.indexOf("[") !== -1;
        this.no = flags.indexOf("-no-") === -1;
        let splittedFlags = flags.split(/[ ,|]+/);
        if (splittedFlags.length > 1 && !/^[[<]/.test(splittedFlags[1])) {
            this.short = splittedFlags.shift();
        }
        this.long = splittedFlags.shift();
        this.description = description || "";
        if (typeof this.defaultValue === "undefined") {
            if (this.required || this.optional) {
                this.defaultValue = "";
            }
            else {
                this.defaultValue = !this.no;
            }
        }
    }
    /**
     * name of this option.
     * @returns {any}
     */
    name() {
        return this.long.replace("--", "").replace("no-", "");
    }
    /**
     * check arg is matches this option.
     * @param arg
     * @returns {boolean}
     */
    is(arg) {
        return arg === this.short || arg === this.long;
    }
    /**
     * parse args.
     * build to opts.
     *
     * e.g. #1
     *   instance member:  required=true, optional=false, short=-f, long=--foo
     *   method arguments: opts={}, args=["--foo", "foo!", "bar!"].
     *   opts are modified to { foo: ["foo!"] } and return ["bar!"].
     *
     * e.g. #2
     *   instance member:  required=true, optional=false, short=-f, long=--foo
     *   method arguments: opts={ foo: ["foo?"] }, args=["--foo", "foo!", "bar!"].
     *   opts are modified to { foo: ["foo?", "foo!"] } and return ["bar!"].
     *
     * e.g. #3
     *   instance member:  required=false, optional=false, short=-f, long=--foo
     *   method arguments: opts={}, args=["-f", "foo!", "bar!"].
     *   opts are modified to { foo: true } and return ["foo!", "bar!"].
     *
     * @param opts
     * @param args
     * @returns {string[]}
     */
    parse(opts, args) {
        if (!this.is(args[0])) {
            throw new error_1.CommandpostError({
                message: `${args[0]} is not match ${this.short} or ${this.long}`,
                reason: error_1.ErrorReason.OptionNameMismatch,
                parts: [args[0]],
                params: {
                    option: this,
                    opts,
                    args,
                },
            });
        }
        let next = args[1];
        let propertyName = utils.kebabToLowerCamelCase(this.name());
        if (this.required) {
            if (next == null) {
                throw new error_1.CommandpostError({
                    message: `${args[0]} is required parameter value`,
                    reason: error_1.ErrorReason.OptionValueRequired,
                    parts: [args[0]],
                    params: {
                        option: this,
                        opts,
                        args,
                    },
                });
            }
            opts[propertyName] = opts[propertyName] || [];
            opts[propertyName].push(next);
            return args.slice(2);
        }
        else if (this.optional) {
            if (next != null && !/^-/.test(next)) {
                opts[propertyName] = opts[propertyName] || [];
                opts[propertyName].push(next);
                return args.slice(2);
            }
            else {
                opts[propertyName] = opts[propertyName] || [];
                opts[propertyName].push(this.defaultValue);
                return args.slice(1);
            }
        }
        else {
            opts[propertyName] = this.no ? true : false;
            return args.slice(1);
        }
    }
}
exports.default = Option;
//# sourceMappingURL=option.js.map