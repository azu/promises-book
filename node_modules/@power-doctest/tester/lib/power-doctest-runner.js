"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var vm2_1 = require("vm2");
var power_doctest_1 = require("power-doctest");
var assert = require("power-assert");
var CALLBACK_FUNCTION_NAME = "__power_doctest_runner_callback__";
function run(code, options) {
    if (options === void 0) { options = {}; }
    var filePath = options.filePath || "default.js";
    var runMode = options.runMode || "all";
    var timeout = options.timeout !== undefined ? options.timeout : 2000;
    var postCallbackName = options.powerDoctestCallbackFunctionName || CALLBACK_FUNCTION_NAME;
    var preTransform = options.preTransform ? options.preTransform : function (code) { return code; };
    var context = options.context || {};
    return new Promise(function (resolve, reject) {
        var _a;
        var isSettled = false;
        var timeoutId = setTimeout(function () {
            if (isSettled) {
                return;
            }
            restoreListener();
            reject(new Error("Timeout error\n\n" + (runMode === "all" ? "If you use { \"runMode\": \"all\" }, you should check all condition flow is passed.\n\nTotal Assertion: " + totalAssertionCount + "\nExecuted Assertion: " + countOfExecutedAssertion + "\n\nAlso, you should consider to use { \"runMode\": \"any\" }" : "")));
        }, timeout);
        // Test Runner like mocha listen unhandledRejection and uncaughtException
        // Disable these listener before running code
        var originalUnhandledRejection = process.listeners("unhandledRejection");
        var originalUncaughtException = process.listeners("uncaughtException");
        process.removeAllListeners("uncaughtException");
        process.removeAllListeners("unhandledRejection");
        var unhandledRejection = function (reason, _promise) {
            restoreListener();
            reject(reason);
        };
        var uncaughtException = function (error) {
            restoreListener();
            reject(error);
        };
        var restoreListener = function () {
            isSettled = true;
            process.removeListener("uncaughtException", uncaughtException);
            process.removeListener("unhandledRejection", unhandledRejection);
            // restore
            var currentUncaughtException = process.listeners("uncaughtException");
            var currentUnhandledRejection = process.listeners("unhandledRejection");
            originalUncaughtException.filter(function (listener) {
                // remove duplicated
                return !currentUncaughtException.includes(listener);
            }).forEach(function (listener) {
                process.addListener("uncaughtException", listener);
            });
            originalUnhandledRejection.filter(function (listener) {
                // remove duplicated
                return !currentUnhandledRejection.includes(listener);
            }).forEach(function (listener) {
                process.addListener("unhandledRejection", listener);
            });
            // clearTimeout
            clearTimeout(timeoutId);
        };
        process.on("uncaughtException", uncaughtException);
        process.on("unhandledRejection", unhandledRejection);
        var poweredCode = power_doctest_1.convertCode(preTransform(code), {
            assertAfterCallbackName: postCallbackName,
            filePath: filePath
        });
        // total count of assert
        var totalAssertionCount = poweredCode.split(CALLBACK_FUNCTION_NAME).length - 1;
        // current count of assert
        var countOfExecutedAssertion = 0;
        var vm = new vm2_1.NodeVM({
            console: options.console ? "inherit" : "off",
            timeout: timeout,
            sandbox: __assign((_a = {}, _a[postCallbackName] = function (_id) {
                countOfExecutedAssertion++;
                if (runMode === "all" && countOfExecutedAssertion === totalAssertionCount) {
                    // when all finish
                    restoreListener();
                    resolve();
                }
                else if (runMode === "any") {
                    // when anyone finish
                    restoreListener();
                    resolve();
                }
            }, _a), context),
            require: {
                external: true,
                mock: {
                    "power-assert": assert
                }
            }
        });
        var script = new vm2_1.VMScript(poweredCode, options.filePath);
        vm.run(script, options.filePath);
        // No assertion code
        if (totalAssertionCount === 0) {
            restoreListener();
            resolve();
        }
    });
}
exports.run = run;
//# sourceMappingURL=core-runner.js.map
