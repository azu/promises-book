// LICENSE : MIT
"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var ast_utils_1 = require("./ast-utils");
var core_1 = require("@babel/core");
var types_1 = require("@babel/types");
var parser_1 = require("@babel/parser");
var traverse_1 = __importDefault(require("@babel/traverse"));
function getExpressionNodeFromCommentValue(string) {
    var message = string.trim();
    if (ast_utils_1.ERROR_COMMENT_PATTERN.test(message)) {
        var match = message.match(ast_utils_1.ERROR_COMMENT_PATTERN);
        if (!match) {
            throw new Error("Can not Parse: // => Error: \"message\"");
        }
        return types_1.identifier(match[1]);
    }
    if (ast_utils_1.PROMISE_RESOLVE_COMMENT_PATTERN.test(message)) {
        var match = message.match(ast_utils_1.PROMISE_RESOLVE_COMMENT_PATTERN);
        if (!match) {
            throw new Error("Can not Parse: // => Resolve: value");
        }
        return {
            type: "Resolve",
            node: getExpressionNodeFromCommentValue(match[1])
        };
    }
    else if (ast_utils_1.PROMISE_REJECT_COMMENT_PATTERN.test(message)) {
        var match = message.match(ast_utils_1.PROMISE_REJECT_COMMENT_PATTERN);
        if (!match) {
            throw new Error("Can not Parse: // => Reject: value");
        }
        return {
            type: "Reject",
            node: getExpressionNodeFromCommentValue(match[1])
        };
    }
    try {
        return parser_1.parseExpression(string);
    }
    catch (e) {
        console.error("Can't parse comments // => expression");
        throw e;
    }
}
/**
 * transform code to asserted code
 * if want to source map, use toAssertFromAST.
 */
function toAssertFromSource(code, options) {
    var ast = parser_1.parse(code, __assign({ 
        // parse in strict mode and allow module declarations
        sourceType: "module" }, (options && options.babel ? options.babel : {})));
    if (!ast) {
        throw new Error("Can not parse the code");
    }
    var output = toAssertFromAST(ast, options);
    var babelFileResult = core_1.transformFromAstSync(output, code, { comments: true });
    if (!babelFileResult) {
        throw new Error("can not generate from ast: " + JSON.stringify(output));
    }
    return babelFileResult.code;
}
exports.toAssertFromSource = toAssertFromSource;
/**
 * transform AST to asserted AST.
 */
function toAssertFromAST(ast, options) {
    if (options === void 0) { options = {}; }
    var replaceSet = new Set();
    var id = 0;
    traverse_1.default(ast, {
        exit: function (path) {
            if (!replaceSet.has(path.node) && path.node.trailingComments) {
                var commentExpression = ast_utils_1.tryGetCodeFromComments(path.node.trailingComments);
                if (commentExpression) {
                    var commentExpressionNode = getExpressionNodeFromCommentValue(commentExpression);
                    var actualNode = types_1.isExpressionStatement(path.node) ? path.node.expression : path.node;
                    var replacement = ast_utils_1.wrapAssert({
                        actualNode: actualNode,
                        expectedNode: commentExpressionNode,
                        commentExpression: commentExpression,
                        id: String("id:" + id++)
                    }, options);
                    if (Array.isArray(replacement)) {
                        // prevent âˆž loop
                        path.node.trailingComments = null;
                        path.replaceWithMultiple(replacement);
                    }
                    else {
                        path.replaceWith(replacement);
                    }
                    replaceSet.add(path.node);
                }
            }
        }
    });
    return ast;
}
exports.toAssertFromAST = toAssertFromAST;
//# sourceMappingURL=comment-to-assert.js.map