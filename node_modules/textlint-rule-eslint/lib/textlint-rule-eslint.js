// LICENSE : MIT
"use strict";

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var path = require("path");

var Source = require("structured-source");

var CLIEngine = require("eslint").CLIEngine;

var defaultOptions = {
  // path to .eslintrc file
  "configFile": null,
  // recognize lang of CodeBlock
  "langs": ["js", "javascript", "node", "jsx"]
};

var getConfigBaseDir = function getConfigBaseDir(context) {
  if (typeof context.getConfigBaseDir === "function") {
    return context.getConfigBaseDir();
  } // Fallback that use deprecated `config` value
  // https://github.com/textlint/textlint/issues/294


  var textlintRcFilePath = context.config ? context.config.configFile : null; // .textlinrc directory

  return textlintRcFilePath ? path.dirname(textlintRcFilePath) : process.cwd();
};

var reporter = function reporter(context, options) {
  var Syntax = context.Syntax,
      RuleError = context.RuleError,
      report = context.report,
      fixer = context.fixer,
      getSource = context.getSource;

  if (!options.configFile) {
    throw new Error("Require options: { \"configFile\": \"path/to/.eslintrc\" }");
  }

  var availableLang = options.langs || defaultOptions.langs;
  var textlintRCDir = getConfigBaseDir(context);
  var ESLintOptions = {
    configFile: path.resolve(textlintRCDir, options.configFile)
  };
  var engine = new CLIEngine(ESLintOptions);
  return _defineProperty({}, Syntax.CodeBlock, function (node) {
    if (availableLang.indexOf(node.lang) === -1) {
      return;
    }

    var raw = getSource(node);
    var code = getUntrimmedCode(node, raw);
    var source = new Source(code);
    var resultLinting = engine.executeOnText(code, node.lang);

    if (resultLinting.errorCount === 0) {
      return;
    }

    var results = resultLinting.results;
    results.forEach(function (result) {
      result.messages.forEach(function (message) {
        /*
          1. ```js
         2. CODE
         3. ```
          ESLint message line and column start with 1
         */
        if (options.ignoreParsingErrors && message.message.includes("Parsing error")) {
          return;
        }

        var prefix = message.ruleId ? "".concat(message.ruleId, ": ") : "";

        if (message.fix) {
          var fixedRange = message.fix.range;
          var fixedText = message.fix.text;
          var sourceBlockDiffIndex = raw !== node.value ? raw.indexOf(code) : 0;
          var fixedWithPadding = [fixedRange[0] + sourceBlockDiffIndex, fixedRange[1] + sourceBlockDiffIndex];
          var index = source.positionToIndex({
            line: message.line,
            column: message.column
          });
          var adjustedIndex = index + sourceBlockDiffIndex - 1;
          report(node, new RuleError("".concat(prefix).concat(message.message), {
            index: adjustedIndex,
            fix: fixer.replaceTextRange(fixedWithPadding, fixedText)
          }));
        } else {
          var _sourceBlockDiffIndex = raw !== node.value ? raw.indexOf(code) : 0;

          var _index = source.positionToIndex({
            line: message.line,
            column: message.column
          });

          var _adjustedIndex = _index + _sourceBlockDiffIndex - 1;

          report(node, new RuleError("".concat(prefix).concat(message.message), {
            index: _adjustedIndex
          }));
        }
      });
    });
  });
};
/**
 * [Markdown] get actual code value from CodeBlock node
 * @param {Object} node
 * @param {string} raw raw value include CodeBlock syntax
 * @returns {string}
 */


function getUntrimmedCode(node, raw) {
  if (node.type !== "CodeBlock") {
    return node.value;
  } // Space indented CodeBlock that has not lang


  if (!node.lang) {
    return node.value;
  } // If it is not markdown codeBlock, just use node.value


  if (!(raw.startsWith("```") && raw.endsWith("```"))) {
    if (node.value.endsWith("\n")) {
      return node.value;
    }

    return node.value + "\n";
  } // Markdown(remark) specific hack
  // https://github.com/wooorm/remark/issues/207#issuecomment-244620590


  var lines = raw.split("\n"); // code lines without the first line and the last line

  var codeLines = lines.slice(1, lines.length - 1); // add last new line
  // \n```

  return codeLines.join("\n") + "\n";
}

module.exports = {
  linter: reporter,
  fixer: reporter
};
//# sourceMappingURL=textlint-rule-eslint.js.map