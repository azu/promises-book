{"version":3,"file":"paragraph.js","sourceRoot":"","sources":["paragraph.ts"],"names":[],"mappings":";;AAGA,OAAO;AACP,qBAAqB;AACrB,8DAA8D;AAC9D,+BAA+B;AAC/B,2CAA2C;AAE3C;IAQI,mBAAY,KAAa,EAAE,OAAe;QACtC,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;QACnB,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;QAEvB,8CAA8C;QAC9C,4BAA4B;QAC5B,IAAM,EAAE,GAAG,uCAAuC,CAAC;QACnD,IAAI,CAAC,aAAa,GAAG,EAAE,CAAC;QACxB,IAAI,CAAC,cAAc,GAAG,EAAE,CAAC;QACzB,OAAO,IAAI,EAAE,CAAC;YACV,IAAM,OAAO,GAAG,EAAE,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;YACjC,EAAE,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC;gBACX,KAAK,CAAC;YACV,CAAC;YACD,UAAU;YACV,EAAE,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;gBACd,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC;gBACtB,QAAQ,CAAC;YACb,CAAC;YAED,IAAM,OAAO,GAAG,OAAO,CAAC,CAAC,CAAC,CAAC;YAC3B,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,EAAE,KAAK,EAAE,OAAO,CAAC,KAAK,EAAE,SAAS,EAAE,OAAO,CAAC,KAAK,GAAG,OAAO,CAAC,CAAC,CAAC,CAAC,MAAM,EAAE,CAAC,CAAC;YAChG,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC,MAAI,OAAO,MAAG,EAAE,GAAG,CAAC,CAAC,CAAC;QAC9D,CAAC;IACL,CAAC;IAED,6BAAS,GAAT,UAAU,KAAa;QAAvB,iBAgBC;QAfG,IAAI,KAAK,GAAG,KAAK,CAAC,GAAG,CAAC,UAAA,IAAI,IAAI,OAAA,IAAI,CAAC,SAAS,CAAC,KAAI,CAAC,OAAO,CAAC,EAA5B,CAA4B,CAAC,CAAC,MAAM,CAAC,UAAC,CAAC,EAAE,CAAC,IAAK,OAAA,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,EAAX,CAAW,EAAE,EAAE,CAAC,CAAC;QAC9F,sBAAsB;QACtB,KAAK,GAAG,KAAK,CAAC,MAAM,CAAC,UAAA,IAAI,IAAI,OAAA,KAAI,CAAC,aAAa,CAAC,KAAK,CAAC,UAAA,KAAK,IAAI,OAAA,CAAC,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,EAAtB,CAAsB,CAAC,EAAzD,CAAyD,CAAC,CAAC;QAExF,KAAK,CAAC,OAAO,CAAC,UAAA,IAAI,IAAI,OAAA,IAAI,CAAC,KAAK,IAAI,KAAI,CAAC,KAAK,EAAxB,CAAwB,CAAC,CAAC;QAEhD,EAAE,CAAC,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC;YACjB,MAAM,CAAC,EAAE,CAAC;QACd,CAAC;QAED,MAAM,CAAC,KAAK,CAAC,MAAM,CAAC,UAAA,IAAI;YACpB,MAAM,CAAC,KAAI,CAAC,cAAc,CAAC,MAAM,CAAC,UAAA,aAAa;gBAC3C,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,aAAa,CAAC,CAAC;YAChD,CAAC,CAAC,CAAC,MAAM,KAAK,CAAC,CAAC;QACpB,CAAC,CAAC,CAAC;IACP,CAAC;IACL,gBAAC;AAAD,CAAC,AAnDD,IAmDC;AAnDY,8BAAS","sourcesContent":["import { Rule } from \"./rule\";\nimport { Diff } from \"./changeset/diff\";\n\n// 設計思想\n// 文章の1ブロック毎にデータを保持する\n// ファイル全体→Paragraphに分割→Paragraph毎にChangeSetを作成→ChangeSetをmerge\n// Paragraphでは特定の検出を無効化したい場合がある\n//   例えばてくぶ標準だと 良い→よい と変換するが漢字をわざと使いたい場合がある\n\nexport class Paragraph {\n    index: number;\n    content: string;\n    ignoreAll: boolean;\n    /* @internal */\n    _pragmaRanges: { index: number; tailIndex: number; }[];\n    ignorePatterns: RegExp[];\n\n    constructor(index: number, content: string) {\n        this.index = index;\n        this.content = content;\n\n        // prh:disable:良い|悪い みたいなパターンからチェックをパスさせる表現を作る\n        // prh:disable だけの場合は全部パスさせる\n        const re = /^(?:.*?)prh:disable(?::([^\\n\\s]*))?/gm;\n        this._pragmaRanges = [];\n        this.ignorePatterns = [];\n        while (true) {\n            const matches = re.exec(content);\n            if (!matches) {\n                break;\n            }\n            // : の後の有無\n            if (!matches[1]) {\n                this.ignoreAll = true;\n                continue;\n            }\n\n            const pattern = matches[1];\n            this._pragmaRanges.push({ index: matches.index, tailIndex: matches.index + matches[0].length });\n            this.ignorePatterns.push(new RegExp(`(${pattern})`, \"g\"));\n        }\n    }\n\n    makeDiffs(rules: Rule[]): Diff[] {\n        let diffs = rules.map(rule => rule.applyRule(this.content)).reduce((p, c) => p.concat(c), []);\n        // pragmaに被る範囲の検出は無視する\n        diffs = diffs.filter(diff => this._pragmaRanges.every(range => !diff.isCollide(range)));\n\n        diffs.forEach(diff => diff.index += this.index);\n\n        if (this.ignoreAll) {\n            return [];\n        }\n\n        return diffs.filter(diff => {\n            return this.ignorePatterns.filter(ignorePattern => {\n                return diff.matches[0].match(ignorePattern);\n            }).length === 0;\n        });\n    }\n}\n"]}