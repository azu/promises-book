// LICENSE : MIT
"use strict";

var _textlintRuleHelper = require("textlint-rule-helper");

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * RegExp#flags polyfill
 */
if (RegExp.prototype.flags === undefined) {
  Object.defineProperty(RegExp.prototype, "flags", {
    configurable: true,
    get: function get() {
      return this.toString().match(/[gimuy]*$/)[0];
    }
  });
}

var prh = require("prh");

var path = require("path");

var untildify = require("untildify");

var defaultOptions = {
  checkLink: false,
  checkBlockQuote: false,
  checkEmphasis: false,
  checkHeader: true
};

function createPrhEngine(rulePaths, baseDir) {
  if (rulePaths.length === 0) {
    return null;
  }

  var expandedRulePaths = rulePaths.map(function (rulePath) {
    return untildify(rulePath);
  });
  var prhEngine = prh.fromYAMLFilePath(path.resolve(baseDir, expandedRulePaths[0]));
  expandedRulePaths.slice(1).forEach(function (ruleFilePath) {
    var config = prh.fromYAMLFilePath(path.resolve(baseDir, ruleFilePath));
    prhEngine.merge(config);
  });
  return prhEngine;
}

function createPrhEngineFromContents(yamlContents) {
  if (yamlContents.length === 0) {
    return null;
  }

  var dummyFilePath = "";
  var prhEngine = prh.fromYAML(dummyFilePath, yamlContents[0]);
  yamlContents.slice(1).forEach(function (content) {
    var config = prh.fromYAML(dummyFilePath, content);
    prhEngine.merge(config);
  });
  return prhEngine;
}

function mergePrh() {
  for (var _len = arguments.length, engines = new Array(_len), _key = 0; _key < _len; _key++) {
    engines[_key] = arguments[_key];
  }

  var engines_ = engines.filter(function (engine) {
    return !!engine;
  });
  var mainEngine = engines_[0];
  engines_.slice(1).forEach(function (engine) {
    mainEngine.merge(engine);
  });
  return mainEngine;
}

var assertOptions = function assertOptions(options) {
  if (typeof options.ruleContents === "undefined" && typeof options.rulePaths === "undefined") {
    throw new Error("textlint-rule-prh require Rule Options.\nPlease set .textlinrc:\n{\n    \"rules\": {\n        \"prh\": {\n            \"rulePaths\" :[\"path/to/prh.yml\"]\n        }\n    }\n}\n");
  }
};

var createIgnoreNodeTypes = function createIgnoreNodeTypes(options, Syntax) {
  var nodeTypes = [];

  if (!options.checkLink) {
    nodeTypes.push(Syntax.Link);
  }

  if (!options.checkBlockQuote) {
    nodeTypes.push(Syntax.BlockQuote);
  }

  if (!options.checkEmphasis) {
    nodeTypes.push(Syntax.Emphasis);
  }

  if (!options.checkHeader) {
    nodeTypes.push(Syntax.Header);
  }

  return nodeTypes;
};
/**
 * for each diff of changeSet
 * @param {ChangeSet} changeSet
 * @param {string} str
 * @param {function({
            matchStartIndex: number,
            matchEndIndex: number,
            actual: string
            expected: string
        })}onChangeOfMatch
 */


var forEachChange = function forEachChange(changeSet, str, onChangeOfMatch) {
  var sortedDiffs = changeSet.diffs.sort(function (a, b) {
    return a.index - b.index;
  });
  var delta = 0;
  sortedDiffs.forEach(function (diff) {
    var result = diff.expected.replace(/\$([0-9]{1,2})/g, function (match, g1) {
      var index = parseInt(g1);

      if (index === 0 || diff.matches.length - 1 < index) {
        return match;
      }

      return diff.matches[index] || "";
    }); // matchStartIndex/matchEndIndex value is original position, not replaced position
    // textlint use original position

    var matchStartIndex = diff.index;
    var matchEndIndex = matchStartIndex + diff.matches[0].length; // actual => expected

    var actual = str.slice(diff.index + delta, diff.index + delta + diff.matches[0].length);
    var prh = diff.rule.raw.prh || null;
    onChangeOfMatch({
      matchStartIndex: matchStartIndex,
      matchEndIndex: matchEndIndex,
      actual: actual,
      expected: result,
      prh: prh
    });
    str = str.slice(0, diff.index + delta) + result + str.slice(diff.index + delta + diff.matches[0].length);
    delta += result.length - diff.matches[0].length;
  });
};

var getConfigBaseDir = function getConfigBaseDir(context) {
  if (typeof context.getConfigBaseDir === "function") {
    return context.getConfigBaseDir() || process.cwd();
  } // Old fallback that use deprecated `config` value
  // https://github.com/textlint/textlint/issues/294


  var textlintRcFilePath = context.config ? context.config.configFile : null; // .textlinrc directory

  return textlintRcFilePath ? path.dirname(textlintRcFilePath) : process.cwd();
};

function reporter(context) {
  var userOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assertOptions(userOptions);
  var options = Object.assign({}, defaultOptions, userOptions); // .textlinrc directory

  var textlintRCDir = getConfigBaseDir(context); // create prh config

  var rulePaths = options.rulePaths || [];
  var ruleContents = options.ruleContents || []; // yaml file + yaml contents

  var prhEngineContent = createPrhEngineFromContents(ruleContents);
  var prhEngineFiles = createPrhEngine(rulePaths, textlintRCDir);
  var prhEngine = mergePrh(prhEngineFiles, prhEngineContent);
  var helper = new _textlintRuleHelper.RuleHelper(context);
  var Syntax = context.Syntax,
      getSource = context.getSource,
      report = context.report,
      fixer = context.fixer,
      RuleError = context.RuleError;
  var ignoreNodeTypes = createIgnoreNodeTypes(options, Syntax);
  return _defineProperty({}, Syntax.Str, function (node) {
    if (helper.isChildNode(node, ignoreNodeTypes)) {
      return;
    }

    var text = getSource(node); // to get position from index
    // https://github.com/prh/prh/issues/29

    var dummyFilePath = "";
    var makeChangeSet = prhEngine.makeChangeSet(dummyFilePath, text);
    forEachChange(makeChangeSet, text, function (_ref) {
      var matchStartIndex = _ref.matchStartIndex,
          matchEndIndex = _ref.matchEndIndex,
          actual = _ref.actual,
          expected = _ref.expected,
          prh = _ref.prh;

      // If result is not changed, should not report
      if (actual === expected) {
        return;
      }

      var suffix = prh !== null ? "\n" + prh : "";
      var messages = actual + " => " + expected + suffix;
      report(node, new RuleError(messages, {
        index: matchStartIndex,
        fix: fixer.replaceTextRange([matchStartIndex, matchEndIndex], expected)
      }));
    });
  });
}

module.exports = {
  linter: reporter,
  fixer: reporter
};
//# sourceMappingURL=textlint-rule-prh.js.map