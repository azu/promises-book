// LICENSE : MIT
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.default = parse;

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var asciidoctor = require("asciidoctor.js")();

var Converter = function () {
  function Converter() {
    _classCallCheck(this, Converter);
  }

  _createClass(Converter, [{
    key: "convert",
    value: function convert(text) {
      var doc = asciidoctor.load(text, { sourcemap: true });

      // NOTE: doc.$source_lines() does not contain some whitespaces and lines...
      this.lines = text.split(/\n/);
      this.chars = [0];
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this.lines[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var line = _step.value;

          this.chars.push(this.chars[this.chars.length - 1] + line.length + 1);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      var elements = this.convertElement(doc, {
        min: 1,
        max: this.lines.length,
        update: true
      });
      if (elements.length === 0) {
        return this.createEmptyDocument();
      }
      return elements[0];
    }
  }, {
    key: "convertElement",
    value: function convertElement(elem, lineno) {
      if (elem.context === "document") {
        return this.convertDocument(elem, lineno);
      } else if (elem.context === "paragraph" || elem.context === "literal") {
        return this.convertParagraph(elem, lineno);
      } else if (elem.context === "ulist" || elem.context === "olist") {
        return this.convertList(elem, lineno);
      } else if (elem.context === "list_item") {
        return this.convertListItem(elem, lineno);
      } else if (elem.context === "dlist") {
        return this.convertDefinitionList(elem, lineno);
      } else if (elem.context === "quote") {
        return this.convertQuote(elem, lineno);
      } else if (elem.context === "listing") {
        return this.convertListing(elem, lineno);
      } else if (elem.context === "section") {
        return this.convertSection(elem, lineno);
      } else if (elem.context === "table") {
        return this.convertTable(elem, lineno);
      } else if (elem.context === "admonition" || elem.context === "example") {
        return this.convertElementList(elem.$blocks(), _extends({}, lineno, {
          update: false
        }));
      }
      return [];
    }
  }, {
    key: "convertDocument",
    value: function convertDocument(elem, lineno) {
      var raw = elem.$source();
      var children = this.convertElementList(elem.$blocks(), lineno);
      if (!elem.$header()["$nil?"]()) {
        children = [this.convertHeader(elem.$header(), lineno)].concat(_toConsumableArray(children));
      }
      if (children.length === 0) {
        return [];
      }
      var loc = {
        start: children[0].loc.start,
        end: children[children.length - 1].loc.end
      };
      var range = this.locationToRange(loc);
      return [{ type: "Document", children: children, loc: loc, range: range, raw: raw }];
    }
  }, {
    key: "convertHeader",
    value: function convertHeader(elem, lineno) {
      var raw = elem.title;
      var loc = this.findLocation([raw], lineno);
      var range = this.locationToRange(loc);
      return {
        type: "Header",
        depth: elem.$level() + 1,
        children: [{ type: "Str", value: elem.title, loc: loc, range: range, raw: raw }],
        loc: loc,
        range: range,
        raw: raw
      };
    }
  }, {
    key: "convertSection",
    value: function convertSection(elem, lineno) {
      var raw = elem.title;
      var loc = this.findLocation([raw], lineno);
      if (!loc) {
        return [];
      }
      var range = this.locationToRange(loc);
      var header = {
        type: "Header",
        depth: elem.$level() + 1,
        children: [{ type: "Str", value: elem.title, loc: loc, range: range, raw: raw }],
        loc: loc,
        range: range,
        raw: raw
      };
      var children = this.convertElementList(elem.$blocks(), lineno);
      return [header].concat(_toConsumableArray(children));
    }
  }, {
    key: "convertParagraph",
    value: function convertParagraph(elem, _ref) {
      var min = _ref.min,
          max = _ref.max;

      var raw = elem.$source();
      var loc = this.findLocation(elem.$lines(), { min: min, max: max });
      if (!loc) {
        return [];
      }
      var range = this.locationToRange(loc);
      return [{
        type: "Paragraph",
        children: [{ type: "Str", value: raw, loc: loc, range: range, raw: raw }],
        loc: loc,
        range: range,
        raw: raw
      }];
    }
  }, {
    key: "convertQuote",
    value: function convertQuote(elem, _ref2) {
      var min = _ref2.min,
          max = _ref2.max;

      var raw = ""; // TODO: fix asciidoc/asciidoc
      var children = this.convertElementList(elem.$blocks(), {
        min: min,
        max: max,
        update: false
      });
      if (children.length === 0) {
        return [];
      }
      return [_extends({ type: "BlockQuote", children: children, raw: raw }, this.locAndRangeFrom(children))];
    }
  }, {
    key: "convertListing",
    value: function convertListing(elem, _ref3) {
      var min = _ref3.min,
          max = _ref3.max;

      var raw = elem.$source();
      var loc = this.findLocation(elem.$lines(), { min: min, max: max });
      if (!loc) {
        return [];
      }
      var range = this.locationToRange(loc);
      return [{ type: "CodeBlock", value: raw, loc: loc, range: range, raw: raw }];
    }
  }, {
    key: "convertList",
    value: function convertList(elem, _ref4) {
      var min = _ref4.min,
          max = _ref4.max;

      var raw = ""; // TODO: fix asciidoc/asciidoc
      var children = this.convertElementList(elem.$blocks(), {
        min: min,
        max: max,
        update: false
      });
      if (children.length === 0) {
        return [];
      }
      return [_extends({ type: "List", children: children, raw: raw }, this.locAndRangeFrom(children))];
    }
  }, {
    key: "convertDefinitionList",
    value: function convertDefinitionList(elem, _ref5) {
      var min = _ref5.min,
          max = _ref5.max;

      var raw = ""; // TODO: fix asciidoc/asciidoc
      var concat = Array.prototype.concat;
      var blocks = concat.apply([], elem.$blocks().map(function (_ref6) {
        var _ref7 = _slicedToArray(_ref6, 2),
            terms = _ref7[0],
            item = _ref7[1];

        return [].concat(_toConsumableArray(terms), [item]);
      }));
      var children = this.convertElementList(blocks, {
        min: min,
        max: max,
        update: false
      });
      if (children.length === 0) {
        return [];
      }
      return [_extends({ type: "List", children: children, raw: raw }, this.locAndRangeFrom(children))];
    }
  }, {
    key: "convertListItem",
    value: function convertListItem(elem, lineno) {
      var raw = ""; // TODO: fix asciidoc/asciidoc
      var children = this.convertElementList(elem.$blocks(), lineno);
      if (!elem.text["$nil?"]()) {
        children = [].concat(_toConsumableArray(this.createParagraph(elem.text, lineno)), _toConsumableArray(children));
      }
      if (children.length === 0) {
        return [];
      }
      return [_extends({
        type: "ListItem",
        children: children,
        raw: raw
      }, this.locAndRangeFrom(children))];
    }
  }, {
    key: "convertTableCell",
    value: function convertTableCell(elem, lineno) {
      var raw = elem.text;
      var loc = this.findLocation(raw.split(/\n/), lineno);
      if (!loc) {
        return [];
      }
      var range = this.locationToRange(loc);

      var children = [];
      if (elem.style === "asciidoc") {
        children = this.convertElementList(elem.$inner_document().$blocks(), lineno);
      } else {
        children = [{
          type: "Str",
          value: raw,
          loc: loc,
          range: range,
          raw: raw
        }];
      }

      return [{
        type: "TableCell",
        children: children,
        loc: loc,
        range: range,
        raw: raw
      }];
    }
  }, {
    key: "convertTableRow",
    value: function convertTableRow(row, lineno) {
      var children = [];
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = row[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var cell = _step2.value;

          children = [].concat(_toConsumableArray(children), _toConsumableArray(this.convertTableCell(cell, lineno)));
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      if (children.length === 0) {
        return [];
      }
      var loc = {
        start: children[0].loc.start,
        end: children[children.length - 1].loc.end
      };
      var range = this.locationToRange(loc);
      return [{
        type: "TableRow",
        children: children,
        loc: loc,
        range: range,
        raw: ""
      }];
    }
  }, {
    key: "convertTable",
    value: function convertTable(elem, _ref8) {
      var min = _ref8.min,
          max = _ref8.max;

      var children = [];
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = elem.$rows().$body()[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var row = _step3.value;

          children = [].concat(_toConsumableArray(children), _toConsumableArray(this.convertTableRow(row, { min: min, max: max, update: false })));
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3.return) {
            _iterator3.return();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }

      if (children.length === 0) {
        return [];
      }
      var loc = {
        start: children[0].loc.start,
        end: children[children.length - 1].loc.end
      };
      var range = this.locationToRange(loc);
      return [{
        type: "Table",
        children: children,
        loc: loc,
        range: range,
        raw: ""
      }];
    }
  }, {
    key: "createParagraph",
    value: function createParagraph(raw, lineno) {
      var loc = this.findLocation(raw.split(/\n/), lineno);
      if (!loc) {
        return [];
      }
      var range = this.locationToRange(loc);
      return [{
        type: "Paragraph",
        children: [{ type: "Str", value: raw, loc: loc, range: range, raw: raw }],
        loc: loc,
        range: range,
        raw: raw
      }];
    }
  }, {
    key: "locAndRangeFrom",
    value: function locAndRangeFrom(children) {
      var loc = {
        start: children[0].loc.start,
        end: children[children.length - 1].loc.end
      };
      var range = this.locationToRange(loc);
      return { loc: loc, range: range };
    }
  }, {
    key: "positionToIndex",
    value: function positionToIndex(_ref9) {
      var line = _ref9.line,
          column = _ref9.column;

      return this.chars[line - 1] + column;
    }
  }, {
    key: "locationToRange",
    value: function locationToRange(_ref10) {
      var start = _ref10.start,
          end = _ref10.end;

      return [this.positionToIndex(start), this.positionToIndex(end)];
    }
  }, {
    key: "convertElementList",
    value: function convertElementList(elements, _ref11) {
      var min = _ref11.min,
          max = _ref11.max,
          update = _ref11.update;

      var children = [];
      for (var i = 0; i < elements.length; i++) {
        var next = { min: min, max: max, update: update };
        if (update) {
          next.min = elements[i].$lineno();
          if (i + 1 < elements.length) {
            next.max = elements[i + 1].$lineno();
          }
        }
        children = children.concat(this.convertElement(elements[i], next));
      }
      return children;
    }
  }, {
    key: "findLocation",
    value: function findLocation(lines, _ref12) {
      var min = _ref12.min,
          max = _ref12.max;

      for (var i = min; i + lines.length - 1 <= max; i++) {
        var found = true;
        var offset = 0; // see "comment in paragraph" test case.
        for (var j = 0; j < lines.length; j++) {
          while (this.lines[i + j - 1 + offset].match(/^\/\//)) {
            offset++;
          }
          if (this.lines[i + j - 1 + offset].indexOf(lines[j]) === -1) {
            found = false;
            break;
          }
        }
        if (!found) {
          continue;
        }

        var lastLine = lines[lines.length - 1];
        var endLineNo = i + lines.length - 1 + offset;
        var endColumn = this.lines[endLineNo - 1].indexOf(lastLine) + lastLine.length;
        return {
          start: { line: i, column: this.lines[i - 1].indexOf(lines[0]) },
          end: { line: endLineNo, column: endColumn }
        };
      }
      return null;
    }
  }, {
    key: "createEmptyDocument",
    value: function createEmptyDocument() {
      return {
        type: "Document",
        children: [],
        range: [0, 0],
        loc: { start: { line: 1, column: 0 }, end: { line: 1, column: 0 } },
        raw: ""
      };
    }
  }]);

  return Converter;
}();

function parse(text) {
  return new Converter().convert(text);
}
//# sourceMappingURL=parse.js.map